!#############################################################
! List of subroutines
!#############################################################

!      SUBROUTINE IMB_INITIAL

! 				Subroutine for storing and initializing variables used in the Inmersed Boundary Method

!				Reads first the input file for the geometry defintion "geom.cin"
!				The geometry, the number of layers and number of iterations of the Multi-Direct Forcing method are defined here.




!       SUBROUTINE imb_alpha0	


!       SUBROUTINE PartLoc_Initial

! 				??? This subroutine asigns markers to domains and processors and allocate the Force variables used in the MPI scheme



!       SUBROUTINE IB_previous


!       SUBROUTINE IBM

! 				Subroutine for calculating the for F that the Lagrangian markers exert on the fluid cells
! 				Subroutine IBM is the main atribute controlling the algorithm for obtaining a velocity coreection due to the forces applied by the markers of the Immersed Boundaries


!       SUBROUTINE PartLoc

! 				This subroutine asigns markers to domains and processors 
!				Check: Seems to assign the Lagrangian Markers to subdomains


!       SUBROUTINE Deltah

!	Subroutine for finding out the number of neighbouring Eulerian fluid cells, computing the value of the interpolation function, either a delta function of a moving least square method



!      	SUBROUTINE imb_openmp

!			Subroutine for computing the felocity correction of the inmmersed boundary method and
!			computing the force that the boundary applies over the neighbouring eulerian fluid cells

!			This subroutine practicaly does all the heavy lifting




!	SUBROUTINE caldrag


!	SUBROUTINE imb_pressure


!	SUBROUTINE imb_FEM


!	SUBROUTINE imb_FEM_oneblade


!	SUBROUTINE imb_vel_to_zero


!	SUBROUTINE imb_averaging


!	SUBROUTINE move_ST

!		WARNING: check		subroutine that computes initial torque and angular acceleration of the turbine blades
!					when it statrs to move on its own due to drag and lift forces 	

!#############################################################
      SUBROUTINE IMB_INITIAL
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      DOUBLE PRECISION :: PI,revoltime,anst,iteratime
	  INTEGER:: nn ! ghost cell method
      INTEGER      :: L,I,M,strlen,maxn
      CHARACTER*8  :: char_block
      CHARACTER*31 :: gridfile
      CHARACTER*80 :: dummyline
        PI = 4.D0*DATAN(1.D0)
!        xt = 0.d0	; xdt = 0.d0	; xddt = 0.d0
!	  yt = 0.d0	; ydt = 0.d0	; yddt = 0.d0

	master=0 ! 0 is going to be always the master processor

       open (unit=1, file='geom.cin')
       read (1,*) dummyline
       read (1,*) ibm_out_forces
	   read (1,*) yangcase
	   ! ghost cell method
	   interpolationScheme = 0
       read (1,*) interpolationScheme
	   ! end ghost cell metho
       read (1,*) mdfsteps
       read (1,*) bodynum

!Allocate variables that all MPI need to know:
       allocate(nodes(bodynum),rotating(bodynum),rads(bodynum))
	   ! ghost cell
        ibmSt_k = 1000
        allocate(ibmSt(bodynum))
        allocate(ibmStMkrs(ibmSt_k))
        allocate(ibmMkrsEL(ibmSt_k))
        ibmSt_k = -1
        ibmStMkrs = -1
        ibmMkrsEL = -1


	allocate(imb_shape(bodynum),imbnumber(bodynum))
	allocate(radsin(bodynum),filepoints(bodynum))
	allocate(turax(bodynum),reddelta(bodynum)) 
	allocate(ibturbine(bodynum)) 
	allocate(LSELFST(bodynum))			!Self-starting 07_2017
	nodes=0 	; rotating=.false. 	; rads=0.d0
	imb_shape=1	; imbnumber=1		; ibturbine=.false.
	radsin=0.d0	; turax =1			; reddelta=1.d0      
	LSELFST=.FALSE.	 !SET HERE IF SELF-STARTING (only for VATTs)	

	IF (myrank.ne.master) RETURN
!Allocate variables only needed by the master:
	allocate(Cx(bodynum),Cxor(bodynum),Cy(bodynum),Cyor(bodynum))
	allocate(Cz(bodynum),Czor(bodynum),pitch(bodynum))
	allocate(R(bodynum),l2norm(bodynum))	
	allocate(xaero(bodynum),yaero(bodynum),zaero(bodynum))
      allocate(cmax(bodynum),axis(bodynum),nscatter(bodynum))
	allocate(linfin(bodynum),zini(bodynum),zend(bodynum))        
      allocate(acc_ST(bodynum),SUMtorque_ST(bodynum)) 	!Self-starting 07_2017
	
	Cx=0.d0 	; Cxor=0.d0 ; Cy=0.d0 
	Cyor=0.d0 	; Cz=0.d0 	; Czor=0.d0 
	pitch=0.d0 	; R=0.d0 	; l2norm=0.d0 	
	xaero=0.d0 	; yaero=0.d0; zaero=0.d0
	cmax=1	; axis=1	; linfin=0.d0 ; zini=0.d0 ; zend=0.d0
	nscatter=0	; SUMtorque_ST =0.d0 ; acc_ST =0.d0

        DO M=1,bodynum
		read (1,*) dummyline 
		read (1,*) imb_shape(M)
		read (1,*) linfin(M),zini(M),zend(M)		
		read (1,*) Cx(M),Cy(M),Cz(M)
		! ghost cell method
		if(imb_shape(M).eq.101) then
			read (1,*) ncrs ! number of corners
			allocate(cornersx(bodynum,ncrs))
			allocate(cornersz(bodynum,ncrs))
			do nn = 1, ncrs
				read (1,*) cornersx(M,nn) ! x corner k coordinate
				read (1,*) cornersz(M,nn) ! z corner k coordinate
			enddo
		endif
		! end ghost cell method
		read (1,*) R(M)
		read (1,*) cmax(M)
		read (1,*) axis(M)
		read (1,*) filepoints(M)
		read (1,*) rotating(M)
		read (1,*) reddelta(M)			
		read (1,*) dummyline  		!--- Turbine parameters: 
		read (1,*) ibturbine(M)				
		read (1,*) turax(M)				
		read (1,*) xaero(M),yaero(M),zaero(M)		
		read (1,*) pitch(M)		
		read (1,*) imbnumber(M)
		read (1,*) radsin(M)		

	   if(ibturbine(M).EQ..FALSE.) then
	    xaero(M)=0.d0 ; yaero(M)=0.d0 ; zaero(M)=0.d0 	
	    pitch(M)=0.d0 ; turax(M)=1    ; imbnumber(M)=1
	    LSELFST(M)=.false.
	   endif
	   if(turax(M).eq.2 ) then !HATT
	    xaero(M)=0.d0 ; yaero(M)=0.d0 ; zaero(M)=0.d0 		
	    pitch(M)=0.d0 ; imbnumber(M)=1 ; LSELFST(M)=.false.	
	   endif
	   if (rotating(M).eq..FALSE.) radsin(M)=0.d0
	   if (LSELFST(M).eq..TRUE.) radsin(M)=0.d0

!Actuator line:
	   if(ibturbine(M).EQ..true. .and. turax(M).eq.3 .and. M.eq.1) then
	    allocate(r_act(5000),c_act(5000),Pit_act(5000))
	    r_act=0.d0 ; c_act=0.d0 ;Pit_act=0.d0 
	   endif
!Write possible combinations of movements/body types that doesn't work
      End do !M
      close (1)
	WRITE(6,*)' '
	WRITE(6,*)'===========  Immersed Boundary Details  =========='

!CALCULATE TO WHICH BLOCK IS THE CENTRE OF THE BODIES

	 maxn=1999000	!maximum number of Lagrangian allowed

       allocate (nodex(bodynum,maxn),nodexlocal(bodynum,maxn))
	 allocate (nodey(bodynum,maxn),nodeylocal(bodynum,maxn))
	 allocate (nodez(bodynum,maxn),nodezlocal(bodynum,maxn))

      nodex = 0.d0	; nodey = 0.d0 	  ; nodez = 0.d0  
      nodexlocal = 0.d0	; nodeylocal = 0.d0 ; nodezlocal = 0.d0 
	maxnodeIBS=0

	
      dxm=g_dx/rdivmax ; dym=g_dy/rdivmax ; dzm=g_dz/rdivmax	!Minimum grid sizes
	 
	write(6,*)'Largest rdivmax  :',rdivmax	
	write(6,'(a,3e12.4)')'Smallest gridsize: ',dxm,dym,dzm	 
		
	Do M=1,bodynum
        IF (imb_shape(M).eq.1) call imb_square(M)
        IF (imb_shape(M).eq.2) call imb_cylinder(M)
        IF (imb_shape(M).eq.3) call imb_cube(M)
	IF (imb_shape(M).eq.4) call imb_sphere(M)
        IF (imb_shape(M).eq.11)call imb_cone(M)
        IF (imb_shape(M).eq.12)call imb_dune(M)
        IF (imb_shape(M).eq.13)call imb_hemisphere(M)
 	IF (imb_shape(M).eq.5 .and. turax(M).le.2) call imb_file(M)		!07_2017
 	IF (imb_shape(M).eq.5 .and. turax(M).eq.3) call act_line_geom(M)
	 IF (imb_shape(M).eq.101) call imb_userDefinedGeo(M)
! 	  IF (imb_shape(M).eq.5 .and. turax(M).eq.4) call imb_actuator_surf(M)
   	maxnodeIBS=maxnodeIBS+nodes(M)
	IF (maxnodeIBS.gt.maxn)
     & write(6,*)'Too many ib points, change maxn in imb.for'
	IF (maxnodeIBS.gt.maxn) STOP
	Enddo
	

!The velocity and force vectors/matrix are allocated:
      allocate (U_Beta1(bodynum,maxnodeIBS),U_Beta2(bodynum,maxnodeIBS))
      allocate (U_Beta3(bodynum,maxnodeIBS),imb_block(maxnodeIBS))
      allocate (alpha0(bodynum,maxnodeIBS),R0(bodynum,maxnodeIBS))
!Initiate all these variables:
	U_Beta1=0.d0  ; U_Beta2=0.d0  ; U_Beta3=0.d0
	R0=0.d0       ; alpha0=0.d0	  ; imb_block=0

	if (myrank.eq.master) then
       allocate (FX1(bodynum,maxnodeIBS)) ; FX1=0.D0 
       allocate (FX2(bodynum,maxnodeIBS)) ; FX2=0.D0 
       allocate (FX3(bodynum,maxnodeIBS)) ; FX3=0.D0 
       allocate (FX1M(bodynum,maxnodeIBS)) ; FX1M=0.D0 
       allocate (FX2M(bodynum,maxnodeIBS)) ; FX2M=0.D0 
       allocate (FX3M(bodynum,maxnodeIBS)) ; FX3M=0.D0 
	endif
!Local angle and radius:
	 call imb_alpha0	

	if (ibm_out_forces.eq.1) then
!CREATE OUTPUT FILES FOR THE IMMERSED BOUNDARIES:
	L=0
	DO M=1,bodynum
	 DO i=1,imbnumber(M)
             L=L+1 ; forcefilej=399+L
	 IF (ibturbine(M).eq..true.) then !Rotating VATT
         write(char_block,'(i2)') L
         strlen=LEN(TRIM(ADJUSTL(char_block)))
         char_block=REPEAT('0',(2-strlen))//TRIM(ADJUSTL(char_block))
         gridfile='F_Blade_'//TRIM(ADJUSTL(char_block))//'.dat'
         open (unit=forcefilej, file=gridfile, status="unknown",
     &	action="write")
	if (turax(M).eq.1) then
         write (forcefilej,*)'Variables=Deg,Fx,Fy,T1,T2,N1,N2,M'
	else if (turax(M).eq.2) then
         write (forcefilej,*)'Variables=Deg,Fx,Fy,Fz,Ft'
	else if (turax(M).eq.3) then
         write (forcefilej,*)'Variables=Deg,Cx,Cp'
	   goto 363
	endif
	     IF(I.EQ.1) then
		lambda=radsin(M)*R(M)/ubulk
		sigma=imbnumber(M)*1.d0/(R(M)*2*PI)
		revoltime=2.d0*PI/radsin(M)
		anst=radsin(M)*dt*180.0/PI
		iteratime=(360.d0/anst)
	write(6,*)'     '	
	write(6,'(a,i2,a)')   ' ****** Turbine   ',M,'rotating details,'
	write(6,'(a,f12.4)')  '        TSR     : ',lambda
	write(6,'(a,f12.4,a)')'        Solidity: ',sigma*100,' %'
	write(6,'(a,f12.4,a)')'Time per revolut: ',revoltime,' sec'
	write(6,'(a,f12.4,a)')'Iter per revolut: ',iteratime,' it'
	write(6,'(a,f12.4,a)')'     Angle step : ',anst,'deg/iteration'
	    ENDIF
	  ENDIF
	 IF(LSELFST(M).eq..true.) then
	   forcefilej=5452+M
         write(char_block,'(i2)') M
         strlen=LEN(TRIM(ADJUSTL(char_block)))
         char_block=REPEAT('0',(2-strlen))//TRIM(ADJUSTL(char_block))
         gridfile='ST_VATT_'//TRIM(ADJUSTL(char_block))//'.dat'
         open (unit=forcefilej, file=gridfile, status="unknown",
     &	action="write")
         write (forcefilej,*)'Variables=CTIME,Accel,Vel,Rads,Torque'
	 ENDIF !TURBINE
363	CONTINUE	!09-2017

	 IF (ibturbine(M).eq..false. .and. rotating(L).eq..false. ) then !Rotating VATT
         write(char_block,'(i2)') L
         strlen=LEN(TRIM(ADJUSTL(char_block)))
         char_block=REPEAT('0',(2-strlen))//TRIM(ADJUSTL(char_block))
         if(imb_shape(M).eq.1) then
         gridfile='F_Squ_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif        
         if(imb_shape(M).eq.2) then
         gridfile='F_Cyl_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif
         if(imb_shape(M).eq.3) then
         gridfile='F_Cub_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif
         if(imb_shape(M).eq.4) then
         gridfile='F_Sph_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif     
         if(imb_shape(M).eq.5 .and. rotating(L).eq..false.) then
         gridfile='F_Bod_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif 	      
         if(imb_shape(M).ge.11) then
		 gridfile='F_Con_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif 

	    open (unit=forcefilej, file=gridfile)
           write (forcefilej,*)'Variables=CTIME,Fx,Fy,Fz'
	 ENDIF

	! ! File for keeping track of the forces at play in the ghost cell method
	! gridfile = 'F_gh_'//TRIM(ADJUSTL(char_block))//'.dat'
	! forcefilegh = 31
	! open (unit=forcefilegh, file=gridfile)
	! write (forcefilegh,*)'Variables=CTIME,Fx,Fy,Fz'


        if(imb_shape(M).eq.5 .and. ibturbine(M).eq..false.) then
	   if(rotating(L).eq..true.) then
           write(char_block,'(i2)') L
           strlen=LEN(TRIM(ADJUSTL(char_block)))
           char_block=REPEAT('0',(2-strlen))//TRIM(ADJUSTL(char_block))
           gridfile='F_Body_'//TRIM(ADJUSTL(char_block))//'.dat'
           open (unit=forcefilej, file=gridfile)
           write (forcefilej,*)'TITLE = Times series of ST analysis'
           write (forcefilej,*)'Variables=Deg,Fx,Fy,Fz,Ft'
	    endif
     	   endif       
    
	 Enddo !i

	ENDDO !M

	open (unit=757, file= 'l2norm.dat')
	write(757,*)'Variables=Ctime,l2-norm,l1norm-U,l1norm-V'
	WRITE(6,*)' '
	WRITE(6,*)'Total # of IB POINTS.........',maxnodeIBS
	WRITE(6,*)' '

	endif !If the IBM force output

      RETURN
      end
!#############################################################
      SUBROUTINE imb_alpha0	
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER  :: M,L,iii,K,strlen
      DOUBLE PRECISION :: PI
      CHARACTER*8  :: char_block2
      CHARACTER*31 :: gridfile

       PI = 4.D0*DATAN(1.D0)
      
	Do M=1,bodynum

	IF(imb_shape(M).eq.5) then

!!!! TURBINES  !!!!!!!!!!
        write(char_block2,'(I3)') M
         strlen=LEN(TRIM(ADJUSTL(char_block2)))
         char_block2=REPEAT('0',(3-strlen))//TRIM(ADJUSTL(char_block2))
         gridfile='g_angles_'//TRIM(ADJUSTL(char_block2))//'.dat'
         open (unit=2, file=gridfile)
	write(2,*)'variables=x,y,z,al0,R0'

	 if(ibturbine(M).eq..false.) then  !Not a turbine

           do L=1,nodes(M)    			!!!!!assumed z-axis...
            alpha0(M,L)=datan(nodexlocal(M,L)/nodeylocal(M,L))
            R0(M,L)=dsqrt(nodexlocal(M,L)**2+nodeylocal(M,L)**2)
         if(nodexlocal(M,L).gt.0.d0 .and. nodeylocal(M,L).gt.0.d0)then !1st quarter. Alpha>0
          alpha0(M,L)=alpha0(M,L)
         endif
         if(nodexlocal(M,L).le.0.d0 .and. nodeylocal(M,L).ge.0.d0)then !2nd quarter. Alpha<0
          alpha0(M,L)=2*PI+alpha0(M,L)
         endif 
         if(nodexlocal(M,L).lt.0.d0 .and. nodeylocal(M,L).lt.0.d0)then !3rd quarter. Alpha>0 
          alpha0(M,L)=PI+alpha0(M,L)
         endif 
         if(nodexlocal(M,L).gt.0.d0 .and. nodeylocal(M,L).lt.0.d0)then !4th quarter. Alpha>0
          alpha0(M,L)=PI+alpha0(M,L)
         endif
            enddo

	 else


	IF (turax(M).eq.1) then		! Vertical Axis Turbine
	   K=nodes(M)/imbnumber(M)
          do L=1,K 
          alpha0(M,L)=-datan(nodexlocal(M,L)/(nodeylocal(M,L)+R(M))) !!!!!!!! 30 Aug Pablo
          R0(M,L)=dsqrt((nodexlocal(M,L))**2+(nodeylocal(M,L)+R(M))**2)
          enddo
          Do iii=1,imbnumber(M)-1
           do L=1,K
             alpha0(M,L+K*iii)=(2.D0*PI/imbnumber(M))*iii+alpha0(M,L)
	 if(alpha0(M,L+K*iii).gt.2.d0*PI) 
     &	 alpha0(M,L+K*iii)=alpha0(M,L+K*iii)-2.d0*PI
             R0(M,L+K*iii)= R0(M,L)
           enddo
          Enddo
        ENDIF

	IF (turax(M).eq.2) then	! Horizontal Axis Turbine
          do L=1,nodes(M) 
          alpha0(M,L)=datan(nodeylocal(M,L)/(nodezlocal(M,L)))
          if(nodeylocal(M,L).ge.0.d0 .and. nodezlocal(M,L).ge.0.d0) then !1st quarter. Alpha>0
         	alpha0(M,L)=alpha0(M,L)
          endif           
          if(nodeylocal(M,L).lt.0.d0 .and. nodezlocal(M,L).gt.0.d0) then !2nd quarter. Alpha<0
          	alpha0(M,L)=2.D0*PI+alpha0(M,L)
          endif 
          if(nodeylocal(M,L).lt.0.d0 .and. nodezlocal(M,L).lt.0.d0) then !3rd quarter. Alpha>0
         	 alpha0(M,L)=PI+alpha0(M,L)
          endif
          if(nodeylocal(M,L).gt.0.d0 .and. nodezlocal(M,L).lt.0.d0) then !4th quarter. Alpha<0
          	alpha0(M,L)=PI+alpha0(M,L)
          endif
          R0(M,L)=dsqrt((nodeylocal(M,L))**2+(nodezlocal(M,L))**2)                               
          enddo
        ENDIF


	IF (turax(M).eq.3) then		! ACTUATOR LINE
	   K=nodes(M)/imbnumber(M)
          do L=1,K 
          alpha0(M,L)=0.d0
          R0(M,L)=r_act(L)
          enddo
          Do iii=1,imbnumber(M)-1
           do L=1,K
             alpha0(M,L+K*iii)=(2.D0*PI/imbnumber(M))*iii+alpha0(M,L)
	    if(alpha0(M,L+K*iii).gt.2.d0*PI) 
     &	 alpha0(M,L+K*iii)=alpha0(M,L+K*iii)-2.d0*PI
             R0(M,L+K*iii)= R0(M,L)
           enddo
          Enddo
        ENDIF
                 
	 endif

         do L=1,nodes(M)
	    write(2,'(5f12.6)')nodex(M,L),nodey(M,L),nodez(M,L)
     &		,alpha0(M,L)*180/3.1416,R0(M,L)
	   enddo
       close(2)

	endif

	Enddo ! M

   88 FORMAT (i5)
   89 FORMAT (5f12.5)
        RETURN
        END SUBROUTINE
!######################################################################
      SUBROUTINE PartLoc_Initial
!######################################################################
      use vars
      use imb
      use mpi
      use multidata
      implicit none
	INTEGER :: K,L,N,numIBslv

       call MPI_BCAST(maxnodeIBS,1,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!Total # IB points
       call MPI_BCAST(nodes,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# IB points of each body
       call MPI_BCAST(imb_shape,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!IB shape of each body
       call MPI_BCAST(imbnumber,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# IB bodies of each body
       call MPI_BCAST(turax,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# axis of rotation for turbines     
       call MPI_BCAST(reddelta,bodynum,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr) 	!Reduction factor
       call MPI_BCAST(radsin,bodynum,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr)		!Rotational velocity of each IB body
       call MPI_BCAST(rotating,bodynum,MPI_LOGICAL,
     &  master,MPI_COMM_WORLD,ierr)		!If the body rotates
       call MPI_BCAST(ibturbine,bodynum,MPI_LOGICAL,
     &  master,MPI_COMM_WORLD,ierr)		!If the body is a turbine
		call MPI_BARRIER(MPI_COMM_WORLD,ierr)

		! Ghost Cell
       call MPI_BCAST(tf1,3,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr) 	!Total Force
       call MPI_BCAST(p1,3,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr) 	!Total Pressure Force 
       call MPI_BCAST(sh1,3,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr) 	!Total Shear Stress Force


	nIBslv=maxnodeIBS

!Now each processor will store the # of markers assigned (nIBslv)		
      allocate (kmaxU(nIBslv),kmaxV(nIBslv),kmaxW(nIBslv))
      allocate (nodex_loc(nIBslv),U_Beta1_loc(nIBslv),FX1_loc(nIBslv))
      allocate (nodey_loc(nIBslv),U_Beta2_loc(nIBslv),FX2_loc(nIBslv))
      allocate (nodez_loc(nIBslv),U_Beta3_loc(nIBslv),FX3_loc(nIBslv))
      allocate (alpha0_loc(maxnodeIBS),R0_loc(maxnodeIBS))
	allocate (imb_block_loc(maxnodeIBS),lag_bod_loc(maxnodeIBS))
	allocate (imbinblock_loc(num_domains),rott_loc(maxnodeIBS))
      allocate (FX1NF(nIBslv),FX2NF(nIBslv),FX3NF(nIBslv))

	  kmaxU=0 		 ; kmaxV=0 			; kmaxW=0	         		  
	  nodex_loc=0.d0 	 ; nodey_loc=0.d0 	; nodez_loc=0.d0 
	  U_Beta1_loc=0.d0 ; U_Beta2_loc =0.d0 	; U_Beta3_loc =0.d0 
	  FX1_loc =0.d0    ; FX2_loc =0.d0    	; FX3_loc =0.d0 
	  imbinblock_loc=0 ; imb_block_loc=0  	; lag_bod_loc = 0
 	  alpha0_loc =0.d0 ; R0_loc =0.d0 		; rott_loc=2
	  FX1NF=0.D0	 ; FX2NF=0.D0		; FX3NF=0.D0
								
!nxl is the length of the kernel used for the delta functions. 
!nl is the number of neighbours considered
	if (yangcase.eq.2 .or. yangcase.eq.4.or. yangcase.eq.7) then
	 nxl=2.499999d0 	; nl=125
	 deps = 3
	endif
	if (yangcase.eq.3 .or. yangcase.eq.6) then
	 nxl=1.999999d0  	; nl=64 
	 deps = 2
	endif
	if (yangcase.eq.1 .or. yangcase.eq.5) then
	 nxl=1.499999d0  	; nl=27
	 deps = 2
	endif

       allocate (dh1_loc(nIBslv,nl),dh2_loc(nIBslv,nl))
       allocate (dh3_loc(nIBslv,nl))
	 allocate (I_nr_U(nIBslv,nl),J_nr_U(nIBslv,nl))
	 allocate (I_nr_V(nIBslv,nl),J_nr_V(nIBslv,nl))
	 allocate (I_nr_W(nIBslv,nl),J_nr_W(nIBslv,nl))
	 allocate (K_nr_U(nIBslv,nl),K_nr_V(nIBslv,nl))
	 allocate (K_nr_W(nIBslv,nl))

	  dh1_loc=0.d0	; dh2_loc=0.d0	; dh3_loc=0.d0
	  I_nr_U=0		; J_nr_u=0 		; K_nr_U=0
	  I_nr_V=0 		; J_nr_V=0 		; K_nr_V=0
	  I_nr_W=0 		; J_nr_W=0 		; K_nr_W=0
                                         
	RETURN
	END
!######################################################################
      SUBROUTINE  gh_initial_geomtry
!######################################################################
		! This subroutine broacast to the processors the charateristi feature of the 
		! geometry of the inmmersed body:
		! ibmStMkrs	: markers per stations:
		! ibmMkrsEL : markers in the exterior layer of each station
		! ibmSt  	: number of station in each inmmersed body
		! ibmSt_k	: total number of stations 
		!
      use vars
      use imb
      use mpi
      use multidata
      implicit none

       call MPI_BCAST(ibmSt_k,1,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!Total # Stations in the immersed bodies
       call MPI_BCAST(ibmSt,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# Stations of each body
     									 ! for each postion, it stores the number of stations defined in each body
      call MPI_BCAST(ibmStMkrs,ibmSt_k,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# IB points in each station of each body,
     									 ! for each postion jj, it stores the number of markers in station jj
      call MPI_BCAST(ibmMkrsEL,ibmSt_k,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# IB points in the exterior layer in each station of each body

	! debug
	 ! if(myrank.ne.master) then
	!	write(*,*) "iiiiiiiiiiiiiiiiiiiiiiiiiiiii",ibmSt_k
	!	write(*,*) "iiiiiiiiiiiiiiiiiiiiiiiiiiiii",ibmSt(bodynum)
	!	write(*,*) "iiiiiiiiiiiiiiiiiiiiiiiiiiiii",ibmStMkrs(ibmSt_k)
	!	write(*,*) "iiiiiiiiiiiiiiiiiiiiiiiiiiiii",ibmMkrsEL(ibmSt_k)
	! endif

 !######################################################################
      END
 !######################################################################



!######################################################################
      SUBROUTINE IB_previous
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      INTEGER :: K
	Do K=1,bodynum	! sweeping bodies

!Distribute properties of the actuator line turbines
	if(itime.eq.itime_start .AND. 
     &	    imb_shape(K).eq.5 .and. turax(K).eq.3) then
		 CALL ActuatorLine_Initial			!Turbine via Actuator Line model
		 write(*,*) "Turbine via Actuator Line model"
	endif

	 IF (imb_shape(K).eq.5 .and. rotating(K).eq..TRUE.) then
	   if(ibturbine(K).eq..true.) then
	      IF(LSELFST(K)) then
			call move_ST ! 					!Self-starting 07_2017
			write(*,*) "!Self-starting 07_2017"
		ELSE
			rads(K)=radsin(K)*CTIME			!Prescribed rotational speed
			write(*,*) "Prescribed rotational speed: ", rads(K)
		ENDIF
	   else
			rads(K)=-radsin(K)*3.1416D0/180.D0*DSIN(0.1983*CTIME)	!Pitching airfoil case
			write(*,*) "Pitching airfoil case: ", rads(K)
	   endif
		 call imb_moved(K) 		 		!In shapes.for
		 write(*,*) "imb_moved(K)"
	   if(ibturbine(K).eq..true. .and. turax(K).eq.1)
     &	 call imb_moved_shades(K)  			 !In shapes.for
	   write(*,*) "imb_moved_shades(K)"
	 ENDIF
	 !
	 !
	 motionFlag = 0
	 !
	 ! oscilating cylinder for testing the ghostcell method
	    if(rotating(K).eq..TRUE.) then
		  ! VERICALLY OSCILLATING CYLINDER
			write(*,*) "Inmersed body modtion"
			motionFlag = 1
	      	call vertical_oscillating_cylinder(K)	!In shapes.for
	      	!call horizontal_oscillating_cylinder(K)	!In shapes.for
		!  !
		!  !
        !  ! ghost cell method
        !  ! If the solid can move, we need to searZch for new cell at each time step
		!  write(*,*) "Searching for ghostCells"
		!  call searchGhostCells ! Searches for ghost cells, if it finds any, the flag mucx = 1,2,3 or 4Z
		!  	!After that, we nned to check for emerging cells, new solid cells, or update the info on the solid cells
		!  call checkEmergingCells ! it checks if mucx = mucxold ?
		!  write(*,*) "Fnished checking ghostCells"
		!  	! if False and mucx = 0, we have found an emerging cell
		!  	! if False and mucxold = 0, we have found a new fluid cell inside the inmersed body
		!  	! mucxold = mucx
		!  	! mucx = 0
		!elseif(rotating(k).eq..FALSE.) then
		!	if (itime.eq.itime_start)then
		!		! If the solid is fixed, we only need to search for the solid cells at the first time step, 
		!		! additionally we do not need to check for emerging cells
		!		call searchGhostCells
		!		call checkEmergingCells ! it checks if mucx = mucxold ?
		!	endif
	    endif
	 !
	 Enddo	! sweeping bodies
	 !
		Call PartLoc  					!Asign markers to domains and processors 
		! if (itime.eq.itime_start)   	call imb_vel_to_zero
	!
	!
	IF(itime.eq.itime_start) then				!Generate delta func for steady bodies
	 if(myrank.eq.master)write(6,*)'Delta functions initiating'
	   Call Deltah 
	 if(myrank.eq.master)write(6,*)'Delta functions generated'
	ENDIF
	!
      END SUBROUTINE
!
!######################################################################
      SUBROUTINE IBM
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      INTEGER :: NF,M,L,N
!call exchange subroutines to fill the ghost cells with Ustar values
	call exchange(11) ; call exchange(22) ; call exchange(33)

	 FX1NF=0.d0;FX2NF=0.d0;FX3NF=0.d0

	!DO NF =1,mdfsteps+1	!MDF loops. +1 as the default loop for IB is 0 MDF loops
	  !call imb_openmp
	!  rott_loc=2 !This is set to avoid to calculate dh again when NF>1
	 ! call ghostCell2(1)
	!ENDDO

	  ! Setting USTAR, VSTAR, WSTAR to 0 in the cells containing markers after 
	  ! applying the velocity correction due to the inmersed bounday effect at the end of imb_openmp
!	  call Zero_U_V_W_STAR(NF) 	

!		call imb_averaging !Calculate mean IB force values
!	if (mod(itime,2) .eq. 0 .and. ibm_out_forces.eq.1) then
!		call caldrag	!Output of IB forces
!		if(ibturbine(1).eq. .TRUE. .and. turax(1).eq.2) then
!		 call imb_FEM		!Structural loadings of all blades
!		 call imb_FEM_oneblade !Structural loadings for a single blade divided into sections
!	      endif
!	endif

!      if (mod(itime,n_out).eq.0) call imb_pressure		!returns coordinates and forces of markers every nout 
!update the velocities at the ghost cell values	
	call exchange(11) ; call exchange(22) ; call exchange(33)
      END SUBROUTINE

!######################################################################
	SUBROUTINE ghostCell(flag_LSM,flag1)
!######################################################################

        use imb
        use mpi
	    use multidata
        use vars
		
        implicit none

	  LOGICAL, INTENT(IN):: flag_LSM
	  INTEGER, INTENT(IN):: flag1
	  
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn,ll,M,qF
	  INTEGER :: iic, jjc, kkc, ii, jj, kk
	  ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! mm :
	  ! nn : index for nodes belonging to the M-th mody
	  !
	  ! Intefece with function interpolationF
	  INTEGER ::vec2(8)
	  DOUBLE PRECISION :: vec3(3)
	  DOUBLE PRECISION :: mirror_u,mirror_w,mirror_p, k
	  DOUBLE PRECISION :: mirror_phi
	  DOUBLE PRECISION ::mirror_v
	  !
	  INTEGER :: iis,iie,jjs,jje,kks,kke
	  INTEGER :: cu,cv,cw,cp,cfi
	  INTEGER :: St_k, mksPS, mksEL,nnFinish,nnStart
	  INTEGER :: threshold1, step
	  !
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  !
	  ! Inteface variables with the marked cells
	  INTEGER :: gcumi,gcwmi,gcpmi
	  INTEGER :: gcumj,gcwmj,gcpmj
	  INTEGER :: gcumk,gcwmk,gcpmk
	  DOUBLE PRECISION :: gcumx,gcux,gcwmx,gcwx,gcpmx,gcpx
	  DOUBLE PRECISION :: gcumy,gcuy,gcwmy,gcwy,gcpmy,gcpy
	  DOUBLE PRECISION :: gcumz,gcuz,gcwmz,gcwz,gcpmz,gcpz
	  !
	  ! Intefece with bilinear_cramer
	  DOUBLE PRECISION :: uvec(4),wvec(4),pvec(4),nx(2),nz(2)
	  DOUBLE PRECISION :: phivec(4)
	  DOUBLE PRECISION :: mrx,mry,mrz
	  DOUBLE PRECISION :: vvec(4)
	  ! Intefece with 2nd order Least Squares Method
	  DOUBLE PRECISION :: uvec2(16),wvec2(16),pvec2(16),nx2(4),nz2(4)
	  DOUBLE PRECISION :: vvec2(16),phivec2(16)
	  ! Interface with q4 HP FEM
	  DOUBLE PRECISION :: dudxvec(4),dudyvec(4)
	  DOUBLE PRECISION :: dvdxvec(4),dvdyvec(4)
	  DOUBLE PRECISION :: dwdxvec(4),dwdyvec(4)
	  DOUBLE PRECISION :: dpdxvec(4),dpdyvec(4)
	  DOUBLE PRECISION :: dphidxvec(4),dphidyvec(4)
	  INTEGER :: id,kd
	  !
	  DOUBLE PRECISION:: mirror_ua,mirror_ub,mirror_uc
	  DOUBLE PRECISION:: mirror_va,mirror_vb,mirror_vc
	  DOUBLE PRECISION:: mirror_wa,mirror_wb,mirror_wc
	  DOUBLE PRECISION:: mirror_pa,mirror_pb,mirror_pc
	  DOUBLE PRECISION:: mirror_phia,mirror_phib,mirror_phic
	  !
	  DOUBLE PRECISION:: mirror_ud,mirror_ue,mirror_uf
	  DOUBLE PRECISION:: mirror_vd,mirror_ve,mirror_vf
	  DOUBLE PRECISION:: mirror_wd,mirror_we,mirror_wf
	  DOUBLE PRECISION:: mirror_pd,mirror_pe,mirror_pf
	  DOUBLE PRECISION:: mirror_phid,mirror_phie,mirror_phif
	  !
	  DOUBLE PRECISION:: mirror_ua2
	  DOUBLE PRECISION:: mirror_va2
	  DOUBLE PRECISION:: mirror_wa2
	  DOUBLE PRECISION:: mirror_pa2
	  DOUBLE PRECISION:: mirror_phia2
	  !
	  DOUBLE PRECISION:: mirror_ue2,mirror_uf2
	  DOUBLE PRECISION:: mirror_ve2,mirror_vf2
	  DOUBLE PRECISION:: mirror_we2,mirror_wf2
	  DOUBLE PRECISION:: mirror_pe2,mirror_pf2
	  DOUBLE PRECISION:: mirror_phie2,mirror_phif2
	  !
	  DOUBLE PRECISION:: mtmp, maxval, minval
	  !
	  !
	  INTEGER:: dx,idx,jdx,kdx
	  !
	  ! Interface with multithread package OMP
	  INTEGER:: nt ! number of threads
	  !
	  !
	do ib = 1, nbp ! lets sweep only the subdomains with makers

	  !if (myrank.eq.0) then ! The control is passed down to the master processor

	if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the
												! markers are located
		!dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
		!dom(ib)%ttc_j
		!dom(ib)%ttc_k
		!
			if (flag1.eq.0) then
			do kk=1,dom(ib)%ttc_k
			do ii=1,dom(ib)%ttc_i
			do jj=1,dom(ib)%ttc_j
			   	dom(ib)%ucpy(ii,jj,kk)=dom(ib)%uoo(ii,jj,kk)
			   	dom(ib)%vcpy(ii,jj,kk)=dom(ib)%voo(ii,jj,kk)
			   	dom(ib)%wcpy(ii,jj,kk)=dom(ib)%woo(ii,jj,kk)
				dom(ib)%pcpy(ii,jj,kk)=dom(ib)%p(ii,jj,kk)
				if(L_LSM)then
				dom(ib)%phicpy(ii,jj,kk)=dom(ib)%phi(ii,jj,kk)
				endif
			enddo
			enddo
			enddo
			elseif (flag1.eq.1) then
			do kk=1,dom(ib)%ttc_k
			do ii=1,dom(ib)%ttc_i
			do jj=1,dom(ib)%ttc_j
			   	dom(ib)%ucpy(ii,jj,kk)=dom(ib)%ustar(ii,jj,kk)
			   	dom(ib)%vcpy(ii,jj,kk)=dom(ib)%vstar(ii,jj,kk)
			   	dom(ib)%wcpy(ii,jj,kk)=dom(ib)%wstar(ii,jj,kk)
			enddo
			enddo
			enddo
			elseif(flag1.eq.2) then
			do kk=1,dom(ib)%ttc_k
			do ii=1,dom(ib)%ttc_i
			do jj=1,dom(ib)%ttc_j
				dom(ib)%ucpy(ii,jj,kk)=dom(ib)%u(ii,jj,kk)
				dom(ib)%vcpy(ii,jj,kk)=dom(ib)%v(ii,jj,kk)
				dom(ib)%wcpy(ii,jj,kk)=dom(ib)%w(ii,jj,kk)
				dom(ib)%pcpy(ii,jj,kk)=dom(ib)%p(ii,jj,kk)
				if(L_LSM)then
				dom(ib)%phicpy(ii,jj,kk)=dom(ib)%phi(ii,jj,kk)
				endif
			enddo
			enddo
			enddo
	 		endif
		!
		!
		!
		cu = 0
		cv = 0
		cw = 0
		cp = 0
		cfi = 0
		!
		kks = 1
		kke = dom(ib)%ttc_k
		!
		jjs = 1
		jje = dom(ib)%ttc_j
		!
		iis = 1
		iie = dom(ib)%ttc_i
		!
		!
		if (maxnodeIBS.le.100) nt = 1
		if (maxnodeIBS.gt.100) nt = 4 ! OMP_threads
		!
		!write(*,*) 4, OMP_threads
		call OMP_SET_NUM_THREADS(nt)
		!
		!
		!aaa	!$OMP parallel DEFAULT(SHARED)PRIVATE(ii,jj,kk)
		!
		!aaa	!$OMP DO SCHEDULE(DYNAMIC,50)
		!aaa	!$OMP PARALLEL DO
		!
		do kk=kks,kke
		do ii=iis,iie
		do jj=jjs,jje
		    if(dom(ib)%mucx(ii,jj,kk).ne.0)then ! ghost cell treatment for the u velocity field
			    nn = dom(ib)%mucxnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
			    if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 !    
				  cu = cu + 1                             
				 !ib = dom(ib)%mucxib(ii,jj,kk)  ! ib    if for layer at which nn marker is located
				 ll = dom(ib)%mucxll(ii,jj,kk)  ! ll  
				 iii = dom(ib)%mucxi(ii,jj,kk)  ! iii   ox location of the u ghost cell 
				 jjc = dom(ib)%mucxj(ii,jj,kk)  ! jjc   oy location of the u ghost cell
				 kkk = dom(ib)%mucxk(ii,jj,kk)  ! kkk   oy location of the u ghost cell
				 qF = dom(ib)%mucx(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                 
				 gcux  = dom(ib)%mucxx(ii,jj,kk) ! ox location of the u ghost cell
				 gcuy  = dom(ib)%mucxy(ii,jj,kk) ! oy location of the u ghost cell
				 gcuz  = dom(ib)%mucxz(ii,jj,kk) ! oy location of the u ghost cell
				 !                                 
				 gcumx = dom(ib)%mucxmx(ii,jj,kk) ! ox location of the u mirror cell 
				 gcumy = dom(ib)%mucxmy(ii,jj,kk) ! oy location of the u mirror cell
				 gcumz = dom(ib)%mucxmz(ii,jj,kk) ! oy location of the u mirror cell
				 !                                 
				 gcumi = dom(ib)%mucxmi(ii,jj,kk) ! dom(ib)%x id of the u mirror cell 
				 gcumj = dom(ib)%mucxmj(ii,jj,kk) ! dom(ib)%y id of the u mirror cell
				 gcumk = dom(ib)%mucxmk(ii,jj,kk) ! dom(ib)%z id of the u mirror cell
				 !                                 
				 ! debug
				 !St_k = ibmSt(M) ! number of station of the inmmersed body
				 !mksPS = ibmStMkrs(M)	! Markers per station
				 !mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				 !nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				 !nnStart = 1 + (int(St_k/2.0d00))*mksPS
				 !!if(flag1.eq.0)then
				 !step = int(mksEL/20)
				 !do threshold1 = nnStart, nnFinish, step ! sampling points
				 !!write(*,*) nn,nnStart, threshold1, step
				 !!if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				 !if( nn.eq.threshold1 ) then
				 !write(6,*) nn, ll, qF, jj
				 !write(6,*) iii,jjc, kkk
				 !write(6,*) gcux,gcuy,gcuz
				 !write(6,*) gcumi,gcumj,gcumk
				 !write(6,*) gcumx,gcumy,gcumz
				 !!		write(*,*) "u field, flag1 = 0", nn, flag1
				 !!	 endif
				 !!elseif(flag1.eq.1) then
				 !!if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				 !!		write(*,*) "u field, flag1 = 1", nn, flag1
				 !!	 endif
				 !!elseif(flag1.eq.2) then
				 !!if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				 !!		write(*,*) "u field, flag1 = 2", nn, flag1
				 !!	 endif
				 !endif
				 !enddo
				 !
				 if(interpolationScheme.eq.1) then
			     !deltaFUnction
					vec2(1) = nn ! nn	! Node nds(1.5)
					vec2(2) = ib ! ib 
					vec2(3) = ll ! ll
					vec2(4) = gcumi ! id 
					vec2(5) = gcumj ! jjj
					vec2(6) = gcumk ! kd
					vec2(7) = flag1 ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
					vec2(8) = 1 ! 1 ! fieldFlag for selecting u velocity
					vec3(1) = gcumx !mrx
					vec3(2) = gcumy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
					vec3(3) = gcumz !mrz
					call interpolationF(vec2,vec3,mirror_u)
				 	!
				 elseif(interpolationScheme.eq.2) then
				   ! Least Squares interpolation
				   !
				   id = gcumi
				   kd = gcumk
				   !
				   mrx = gcumx
				   mry = gcumy
				   mrz = gcumz
				   !
				   uvec2(1) =  dom(ib)%ucpy(id-2,jjc,kd-2)
				   uvec2(2) =  dom(ib)%ucpy(id-1,jjc,kd-2)
				   uvec2(3) =  dom(ib)%ucpy(id+0,jjc,kd-2)
				   uvec2(4) =  dom(ib)%ucpy(id+1,jjc,kd-2)
				   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				   uvec2(5) =  dom(ib)%ucpy(id-2,jjc,kd-1)
				   uvec2(6) =  dom(ib)%ucpy(id-1,jjc,kd-1)
				   uvec2(7) =  dom(ib)%ucpy(id+0,jjc,kd-1)
				   uvec2(8) =  dom(ib)%ucpy(id+1,jjc,kd-1)
				   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				   uvec2(9) =  dom(ib)%ucpy(id-2,jjc,kd+0)
				   uvec2(10) = dom(ib)%ucpy(id-1,jjc,kd+0)
				   uvec2(11) = dom(ib)%ucpy(id+0,jjc,kd+0)
				   uvec2(12) = dom(ib)%ucpy(id+1,jjc,kd+0)
				   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				   uvec2(13) =  dom(ib)%ucpy(id-2,jjc,kd+1)
				   uvec2(14) =  dom(ib)%ucpy(id-1,jjc,kd+1)
				   uvec2(15) =  dom(ib)%ucpy(id+0,jjc,kd+1)
				   uvec2(16) =  dom(ib)%ucpy(id+1,jjc,kd+1)
				   !
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					! Checking if any cell centre on the interpolation stencil is a ghost cell 
		!if((nn.eq.-1))then
				   if(0)then
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mucx(idx,jdx,kdx).ne.0)then
			write(6,*) "Warning, using u ghost cell: ",dx,idx,jdx,kdx
			uvec2(dx) = 0.0d00!dom(ib)%ucpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					else !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					!
					!
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mucx(idx,jdx,kdx).ne.0)then
			uvec2(dx) = 0.0d00!dom(ib)%ucpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					!
					!
					endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				   !
				   !
				   nx2(1) = dom(ib)%x(id-2)
				   nx2(2) = dom(ib)%x(id-1)
				   nx2(3) = dom(ib)%x(id+0)
				   nx2(4) = dom(ib)%x(id+1)
				   !
				   nz2(1) = dom(ib)%zc(kd-2)
				   nz2(2) = dom(ib)%zc(kd-1)
				   nz2(3) = dom(ib)%zc(kd+0)
				   nz2(4) = dom(ib)%zc(kd+1)
				   !
				   !
				   uvec(1) = uvec2(6)!dom(ib)%ucpy(id-1,jjc,kd-1) ! q11
				   uvec(2) = uvec2(7)!dom(ib)%ucpy(id+0,jjc,kd-1)   ! q21
				   uvec(3) = uvec2(10)!dom(ib)%ucpy(id-1,jjc,kd+0)   ! q12
				   uvec(4) = uvec2(11)!dom(ib)%ucpy(id+0,jjc,kd+0)	   ! q22
				   nx(1) = dom(ib)%x(id-1)
				   nx(2) = dom(ib)%x(id)
				   nz(1) = dom(ib)%zc(kd-1)
				   nz(2) = dom(ib)%zc(kd)
					!
					! Alternative: cubic HP q4 FEM 
					vec2(1) = nn ! nn	! Node nds(1.5)
					vec2(2) = ib ! ib 
					vec2(3) = ll ! ll
					vec2(4) = gcumi ! id 
					vec2(5) = gcumj ! jjj
					vec2(6) = gcumk ! kd
					vec2(7) = flag1 ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
					vec2(8) = 1 ! 1 ! fieldFlag for selecting u velocity
					vec3(1) = gcumx !mrx
					vec3(2) = gcumy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
					vec3(3) = gcumz !mrz
					!
					!
	mirror_ua = bl_cramer(nn,nx,nz,uvec,mrx,mrz)
	if((nn.eq.-1))then
				   	write(6,*) "Mirror u (Bilinear Interpolation: cramer)",
     &	nn, mirror_ua
				   endif
					!
					!
	if((nn.eq.-1))then
					mirror_ua2 = bl_lu(vec2,nx,nz,uvec,mrx,mrz)
				   	write(6,*) "Mirror u (Bilinear Interpolation: LU)",
     &	nn, mirror_ua2
				   endif
					!
	if((nn.eq.-1))then
					call interpolationF(vec2,vec3,mirror_u)
					write(6,*) "Mirror u (DeltaF phi_x)",
     &	nn, mirror_u
					endif
					!
					!
					!if ( ( nn.eq.70 ).or.( nn.eq.45 ) ) then
		dudxvec(1)=(uvec2(7) -uvec2(5))/(nx2(3)-nx2(1))!(dom(ib)%u(id+0,jjc,kd-1)-dom(ib)%u(id-2,jjc,kd-1))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dudxvec(2)=(uvec2(8) -uvec2(6))/(nx2(4)-nx2(2))!(dom(ib)%u(id+1,jjc,kd-1)-dom(ib)%u(id-1,jjc,kd-1))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
		dudxvec(3)=(uvec2(11)-uvec2(9)) /(nx2(3)-nx2(1))!(dom(ib)%u(id+0,jjc,kd+0)-dom(ib)%u(id-2,jjc,kd+0))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dudxvec(4)=(uvec2(12)-uvec2(10))/(nx2(4)-nx2(2))!(dom(ib)%u(id+1,jjc,kd+0)-dom(ib)%u(id-1,jjc,kd+0))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
			   !
		dudyvec(1)=(uvec2(10)-uvec2(2))/(nz2(3)-nz2(1))!(dom(ib)%u(id-1,jjc,kd+0)-dom(ib)%u(id-1,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dudyvec(2)=(uvec2(11)-uvec2(3))/(nz2(3)-nz2(1))!(dom(ib)%u(id+0,jjc,kd+0)-dom(ib)%u(id+0,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dudyvec(3)=(uvec2(14)-uvec2(6))/(nz2(4)-nz2(2))!(dom(ib)%u(id-1,jjc,kd+1)-dom(ib)%u(id-1,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
		dudyvec(4)=(uvec2(15)-uvec2(7))/(nz2(4)-nz2(2))!(dom(ib)%u(id+0,jjc,kd+1)-dom(ib)%u(id+0,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
					!
        			mirror_ub = fCubicHP1(vec2,nx,nz,uvec,
     &	dudxvec,dudyvec,mrx,mrz)
	 if((nn.eq.-1))then
                    write(6,*) "Mirror u (cubic HP q4 FEM)",
     &	nn, mirror_ub
                    endif
                    !
					!
	if((nn.eq.-1))then
        mirror_uc = fQuadLagrange(vec2,qF,nx2,nz2,uvec2,mrx,mrz)
                    write(6,*) "Mirror u (Lagrange q4 FEM)",
     &	nn, mirror_uc
					endif
					!
					!
					!
					!
					!
					!
	if((nn.eq.-1))then
		mirror_ud = fBilinear(vec2,nx,nz,uvec,mrx,mrz)
                    write(6,*) "Mirror u (bilinear q4 FEM)",
     &	nn, mirror_ud
                    endif
                    !
					!
					!
					!
		if((nn.eq.-1))then
		mirror_ue2 = ls_2ndOrder_cramerV2 (vec2,nx2,nz2,uvec2,mrx,mrz)
					write(6,*) "Mirror u (ls_2ndOrder_q16_inverse_matrix)",
     &	nn, mirror_ue2
	 				endif
					!
					!
		if((nn.eq.-1))then
			mirror_uf = ls_tseng_LU(vec2,nx,nz,uvec,mrx,mrz)
					write(6,*) "Mirror u (tseng_LU)",
     &	nn, mirror_uf
	 				endif
					!
					!
		if((nn.eq.-1))then
		mirror_uf2 = ls_tseng_LU_scaled(vec2,nx,nz,uvec,mrx,mrz)
					write(6,*) "Mirror u (tseng_scaled_LU)",
     &	nn, mirror_uf2
	 				endif
					!
	                !
		if((nn.eq.-1))then
			mirror_ue = ls_2ndOrder_LU_lite(vec2,nx,nz,uvec,mrx,mrz)
					write(6,*) "Mirror u (ls_2ndOrder_LU)",
     &	nn, mirror_ue
	 				endif
					!
					!
					! choosing interpolation method
					mirror_u = mirror_ub
                    !
				! Checking for consitency among the mirror value and the local maxima and minima
		maxval = max_f(4,uvec)
		minval = min_f(4,uvec)
		if(mirror_u.gt.maxval)then 
		mtmp = mirror_u
		mirror_u = mirror_ua !bl_cramer(nn,nx,nz,uvec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! u solution ", mtmp
		write(6,*) " out of local upper bound ",maxval,mirror_u !max_f(4,uvec)
			endif
		elseif(mirror_u.lt.minval)then
		mtmp = mirror_u
		mirror_u = mirror_ua !bl_cramer(nn,nx,nz,uvec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! u solution ", mtmp
		write(6,*) "out of local lower bound ",minval,mirror_u !min_f(4,uvec)
			endif
		elseif(abs((mirror_u-mirror_ua)/mirror_ua).gt.0.3)then
			!mtmp = mirror_u
			!mirror_u = mirror_ua
		if((nn.eq.-1))then
		write(6,*) "WARNING! u solution ", mtmp
		write(6,*) "u above 30% of  ",mirror_ua,mirror_u !min_f(4,wvec)
			endif
		endif
					!
					!
		if((nn.eq.-1))then
					write(6,*) iii,jjc,kkk
					write(6,*) ii,jj,kk
					write(6,*) gcux,gcuy,gcuz
		write(6,*) dom(ib)%x(iii),dom(ib)%yc(jjc),dom(ib)%zc(kkk)
		write(6,*) nodex_loc(nn),nodey_loc(nn),nodez_loc(nn)
		write(6,*)	vec2
		write(6,*)	vec3
					write(6,*) uvec2
					write(6,*) nx2
					write(6,*) nz2
					write(6,*) mrx, mry,mrz
		write(6,*) abs((dom(ib)%x(iii)-mrx)/dom(ib)%dx)
		write(6,*) abs((dom(ib)%zc(kkk)-mrz)/dom(ib)%dz)
		write(6,*) abs((nx(1)-mrx)/dom(ib)%dx)
		write(6,*) abs((nz(1)-mrz)/dom(ib)%dz)
                        endif
					!
					!
				 endif
				 !
				 ! debug
				 !if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
	   			 !	write(*,*) "================================="
	   			 !	write(6,*) vec2
				 !	   write(6,*) vec3
	   			 !	write(6,*) gcumy,dom(ib)%mucxmy(ii,jj,kk)
	   			 !	write(6,*) myrank
	   			 !	endif
				 !
				 !if (rott_loc(nn).eq.1) then
				 if(ll.eq.1)then
					if (gcumi.eq.0) then
						write(*,*) "In ghostCells gcumi = 0", nn, iii, kkk
						write(*,*) gcux, gcuy, gcuz
					 endif
					 if (gcumj.eq.0) then
						write(*,*) "In ghostCells gcumj = 0", nn, iii, kkk
						write(*,*) gcux, gcuy, gcuz
					 endif
					 if (gcumk.eq.0) then
						write(*,*) "In ghostCells gcumk = 0", nn, iii, kkk
						write(*,*) gcux, gcuy, gcuz
					 endif
			     if(rotating(M).eq..FALSE.) then
			     	!k = -1.0d00	
					k = - mirror_u
			     !elseif (rott_loc(nn).eq.2) then
			     elseif(rotating(M).eq..TRUE.) then
					 k = 2*U_p - mirror_u  ! moving body
					 !k = -1.0d00
				 endif
				 elseif(ll.eq.2)then
					k = 0.0d00
				 endif
				 !
				 if(flag1.eq.0) dom(ib)%uoo(iii,jjc,kkk) = k
				 if(flag1.eq.1) dom(ib)%ustar(iii,jjc,kkk) = k
				 if(flag1.eq.2) dom(ib)%u(iii,jjc,kkk) = k
				 !
				 !debug
				  !if(flag1.eq.1) then
				  !if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				  !    !	write(6,*) nn, k ,rott_loc(nn)
				  !  	write(*,*) "USTAR___USTAR___USTAR___USTAR"
				  !		write(6,*) nn, iii,jjj,kkk
				  !		write(6,*) dom(ib)%mucx(iii,jjc,kkk),qF
				  !		write(6,*) dom(ib)%ustar(iii,jjc,kkk)
				  !	!write(6,*) qF, fieldF, fieldVal
				  !	!write(6,*) vec2(1),vec2(2),vec2(3)
				  !	!write(6,*) vec2(4),vec2(5),vec2(6)
				  !	!write(6,*) vec2(7),vec2(8)
				  !	!write(6,*) vec3(1),vec3(2),vec3(3)
				  !	!write(6,*) "======================="
			      ! endif
			      ! endif
			      ! if(flag1.eq.2) then
				  !if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				  !    !	write(6,*) nn, k ,rott_loc(nn)
				  !  	write(*,*) "U_____U_____U_____U_____U_____U"
				  !		write(6,*) nn, iii,jjj,kkk
				  !		write(6,*) dom(ib)%mucx(iii,jjc,kkk),qF
				  !		write(6,*) dom(ib)%u(iii,jjc,kkk)
				  !	!write(6,*) qF, fieldF, fieldVal
				  !	!write(6,*) vec2(1),vec2(2),vec2(3)
				  !	!write(6,*) vec2(4),vec2(5),vec2(6)
				  !	!write(6,*) vec2(7),vec2(8)
				  !	!write(6,*) vec3(1),vec3(2),vec3(3)
				  !	!write(6,*) "======================="
			      !endif
			      !endif
                endif   ! Ensuring processor ID matches subdomain ID???
				!
			endif ! ghost cell treatment for the u velocity field
			!
			!
			if(dom(ib)%mpc(ii,jj,kk).ne.0)then ! ghost cell treatment for the v velocity field
				nn = dom(ib)%mpcnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 	cv = cv + 1
					!
				 	!ib  = dom(ib)%mpcib(ii,jj,kk)  ! ib    if for layer at which nn marker is located
					ll  = dom(ib)%mpcll(ii,jj,kk)  ! ll  
					iic = dom(ib)%mpci(ii,jj,kk)  ! iii   ox location of the p ghost cell 
					jjc = dom(ib)%mpcj(ii,jj,kk)  ! jjc   oy location of the p ghost cell
					kkc = dom(ib)%mpck(ii,jj,kk)  ! kkk   oy location of the p ghost cell
					qF  = dom(ib)%mpc(ii,jj,kk)	  ! qf 
					M   = lag_bod_loc(nn)
					!                                  
					gcpx  = dom(ib)%mpcx(ii,jj,kk) ! ox location of the p ghost cell 
					gcpy  = dom(ib)%mpcy(ii,jj,kk) ! oy location of the p ghost cell
					gcpz  = dom(ib)%mpcz(ii,jj,kk) ! oy location of the p ghost cell
					!                                 
					gcpmx = dom(ib)%mpcmx(ii,jj,kk) ! ox location of the p mirror cell 
					gcpmy = dom(ib)%mpcmy(ii,jj,kk) ! oy location of the p mirror cell
					gcpmz = dom(ib)%mpcmz(ii,jj,kk) ! oy location of the p mirror cell
					!                                 
					gcpmi = dom(ib)%mpcmi(ii,jj,kk) ! dom(ib)%x id of the p mirror cell 
					gcpmj = dom(ib)%mpcmj(ii,jj,kk) ! dom(ib)%y id of the p mirror cell
					gcpmk = dom(ib)%mpcmk(ii,jj,kk) ! dom(ib)%z id of the p mirror cell
				    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					!!!!!!!!!!!!!!!!!!!!!!!!!!!
					! V velocity
					if(interpolationScheme.eq.1) then
						!deltaFUnction
						vec2(1) = nn ! nn	! Node nds(1.5)
						vec2(2) = ib ! ib 
						vec2(3) = ll ! ll
						vec2(4) = gcpmi ! id 
						vec2(5) = gcpmj ! jjj
						vec2(6) = gcpmk ! kd
						vec2(7) = flag1 ! flag1: 0 -> voo, 1 -> vstar, 2 -> v
						vec2(8) = 2 ! 1 ! fieldFlag for selecting v velocity
						vec3(1) = gcpmx !mrx
						vec3(2) = gcpmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
						vec3(3) = gcpmz !mrz
						call interpolationF(vec2,vec3,mirror_v)
						 !
						elseif(interpolationScheme.eq.2) then
				   		! Least Squares interpolation
						!
						id = gcpmi
						kd = gcpmk
						!
						mrx = gcpmx
						mrz = gcpmz
						!
						vvec2(1) =  dom(ib)%vcpy(id-2,jjc,kd-2)
						vvec2(2) =  dom(ib)%vcpy(id-1,jjc,kd-2)
						vvec2(3) =  dom(ib)%vcpy(id+0,jjc,kd-2)
						vvec2(4) =  dom(ib)%vcpy(id+1,jjc,kd-2)
						!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
						vvec2(5) =  dom(ib)%vcpy(id-2,jjc,kd-1)
						vvec2(6) =  dom(ib)%vcpy(id-1,jjc,kd-1)
						vvec2(7) =  dom(ib)%vcpy(id+0,jjc,kd-1)
						vvec2(8) =  dom(ib)%vcpy(id+1,jjc,kd-1)
						!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
						vvec2(9) =  dom(ib)%vcpy(id-2,jjc,kd+0)
						vvec2(10) = dom(ib)%vcpy(id-1,jjc,kd+0)
						vvec2(11) = dom(ib)%vcpy(id+0,jjc,kd+0)
						vvec2(12) = dom(ib)%vcpy(id+1,jjc,kd+0)
						!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
						vvec2(13) =  dom(ib)%vcpy(id-2,jjc,kd+1)
						vvec2(14) =  dom(ib)%vcpy(id-1,jjc,kd+1)
						vvec2(15) =  dom(ib)%vcpy(id+0,jjc,kd+1)
						vvec2(16) =  dom(ib)%vcpy(id+1,jjc,kd+1)
						!
						!
						!
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					! Checking if any cell centre on the interpolation stencil is a ghost cell 
		!if((nn.eq.-1))then
	         if(0)then
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mpc(idx,jdx,kdx).ne.0)then
			write(6,*) "Warning, using v ghost cell: ",dx,idx,jdx,kdx
			vvec2(dx) = 0.0d00!dom(ib)%vcpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					else !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					!
					!
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mpc(idx,jdx,kdx).ne.0)then
			vvec2(dx) = 0.0d00!dom(ib)%vcpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					!
					!
					endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
						!
						!
						nx2(1) = dom(ib)%xc(id-2)
						nx2(2) = dom(ib)%xc(id-1)
						nx2(3) = dom(ib)%xc(id+0)
						nx2(4) = dom(ib)%xc(id+1)
						!
						nz2(1) = dom(ib)%zc(kd-2)
						nz2(2) = dom(ib)%zc(kd-1)
						nz2(3) = dom(ib)%zc(kd+0)
						nz2(4) = dom(ib)%zc(kd+1)
						!
						vvec(1) = vvec2(6)!dom(ib)%vcpy(id-1,jjc,kd-1) ! q11
						vvec(2) = vvec2(7)!dom(ib)%vcpy(id,jjc,kd-1)   ! q21
						vvec(3) = vvec2(10)!dom(ib)%vcpy(id-1,jjc,kd)   ! q12
						vvec(4) = vvec2(11)!dom(ib)%vcpy(id,jjc,kd)	   ! q22
						nx(1) = dom(ib)%xc(id-1)
						nx(2) = dom(ib)%xc(id)
						nz(1) = dom(ib)%zc(kd-1)
						nz(2) = dom(ib)%zc(kd)
						!
						! Alternative: cvbic HP q4 FEM 
						vec2(1) = nn ! nn	! Node nds(1.5)
						vec2(2) = ib ! ib 
						vec2(3) = ll ! ll
						vec2(4) = gcpmi ! id 
						vec2(5) = gcpmj ! jjj
						vec2(6) = gcpmk ! kd
						vec2(7) = flag1 ! flag1: 0 -> voo, 1 -> vstar, 2 -> v
						vec2(8) = 2 ! 1 ! fieldFlag for selecting v velocity
						vec3(1) = gcpmx !mrx
						vec3(2) = gcpmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
						vec3(3) = gcpmz !mrz
						!
						!
		mirror_va = bl_cramer(nn,nx,nz,vvec,mrx,mrz)
	if((nn.eq.-1))then
		write(6,*) "Mirror v (Bilinear Interpolation: cramer)",
     &	nn, mirror_va
				    endif
						!
						!
	if((nn.eq.-1))then
						mirror_va2 = bl_lu(vec2,nx,nz,vvec,mrx,mrz)
				   		write(6,*) "Mirror v (Bilinear Interpolation: LU)",
     &	nn, mirror_va2
				    	endif
						!
						!
				    	!
	if((nn.eq.-1))then
							call interpolationF(vec2,vec3,mirror_v)
							write(6,*) "Mirror V (DeltaF phi_x)",
     &	nn, mirror_v
							endif
						!
						!
						!
		dvdxvec(1)=(vvec2(7) -vvec2(5))/(nx2(3)-nx2(1))!(dom(ib)%v(id+0,jjc,kd-1)-dom(ib)%v(id-2,jjc,kd-1))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dvdxvec(2)=(vvec2(8) -vvec2(6))/(nx2(4)-nx2(2))!(dom(ib)%v(id+1,jjc,kd-1)-dom(ib)%v(id-1,jjc,kd-1))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
		dvdxvec(3)=(vvec2(11)-vvec2(9)) /(nx2(3)-nx2(1))!(dom(ib)%v(id+0,jjc,kd+0)-dom(ib)%v(id-2,jjc,kd+0))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dvdxvec(4)=(vvec2(12)-vvec2(10))/(nx2(4)-nx2(2))!(dom(ib)%v(id+1,jjc,kd+0)-dom(ib)%v(id-1,jjc,kd+0))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
				!
		dvdyvec(1)=(vvec2(10)-vvec2(2))/(nz2(3)-nz2(1))!(dom(ib)%v(id-1,jjc,kd+0)-dom(ib)%v(id-1,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dvdyvec(2)=(vvec2(11)-vvec2(3))/(nz2(3)-nz2(1))!(dom(ib)%v(id+0,jjc,kd+0)-dom(ib)%v(id+0,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dvdyvec(3)=(vvec2(14)-vvec2(6))/(nz2(4)-nz2(2))!(dom(ib)%v(id-1,jjc,kd+1)-dom(ib)%v(id-1,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
		dvdyvec(4)=(vvec2(15)-vvec2(7))/(nz2(4)-nz2(2))!(dom(ib)%v(id+0,jjc,kd+1)-dom(ib)%v(id+0,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
						!
                    mirror_vb = fCubicHP1(vec2,nx,nz,vvec,
     &	dvdxvec,dvdyvec,mrx,mrz)
	 if((nn.eq.-1))then
                    write(6,*) "Mirror v (cubic HP q4 FEM)",
     &	nn, mirror_vb
                    endif
                    !
					!
	if((nn.eq.-1))then
		mirror_vc = fQuadLagrange(vec2,qF,nx2,nz2,vvec2,mrx,mrz)
                    write(6,*) "Mirror v (Lagrange q4 FEM)",
     &	nn, mirror_vc
	 				endif
					!
					!
                    !
					!
					!
      if((nn.eq.-1))then
		mirror_vd = fBilinear(vec2,nx,nz,vvec,mrx,mrz)
                    write(6,*) "Mirror v (bilinear q4 FEM)",
     &	nn, mirror_vd
	 				endif
					!
					!
					!
					!
		if((nn.eq.-1))then
		mirror_ve2 = ls_2ndOrder_cramerV2(vec2,nx2,nz2,vvec2,mrx,mrz)
					write(6,*) "Mirror v (ls_2ndOrder_q16_inverse_matrix)",
     &	nn, mirror_ve2
	 				endif
					!
					!
		if((nn.eq.-1))then
			mirror_vf = ls_tseng_LU(vec2,nx,nz,vvec,mrx,mrz)
					write(6,*) "Mirror v (tseng_LU)",
     &	nn, mirror_vf
	 				endif
					!
					!
		if((nn.eq.-1))then
		mirror_vf2 = ls_tseng_LU_scaled(vec2,nx,nz,vvec,mrx,mrz)
					write(6,*) "Mirror v (tseng_scaled_LU)",
     &	nn, mirror_vf2
	 				endif
					!
					!
		if((nn.eq.-1))then
			mirror_ve = ls_2ndOrder_LU_lite(vec2,nx,nz,vvec,mrx,mrz)
					write(6,*) "Mirror v (ls_2ndOrder_LU)",
     &	nn, mirror_ve
	 				endif

					!
					!
                    ! Choosing interpolation method
					mirror_v = mirror_vb
					!
					! Checking for consitency among the mirror value and the local maxima and minima
		maxval = max_f(4,vvec)
		minval = min_f(4,vvec)
		if(mirror_v.gt.maxval)then 
		mtmp = mirror_v
		mirror_v = mirror_va ! bl_cramer(nn,nx,nz,vvec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! v solution ",mtmp 
		write(6,*) "out of local upper bound ",maxval,mirror_v !max_f(4,vvec)
			endif
		elseif(mirror_v.lt.minval)then
		mtmp = mirror_v
		mirror_v = mirror_va ! bl_cramer(nn,nx,nz,vvec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! v solution ", mtmp 
		write(6,*) "out of local lower bound ",minval,mirror_v !min_f(4,vvec)
			endif
		elseif(abs((mirror_v-mirror_va)/mirror_va).gt.0.3)then
			!mtmp = mirror_v
			!mirror_v = mirror_va
		if((nn.eq.-1))then
		write(6,*) "WARNING! v solution ", mtmp
		write(6,*) "v above 30% of  ",mirror_va,mirror_v 
			endif
		endif
					!
					!
		if((nn.eq.-1))then
					write(6,*) iic,jjc,kkc
					write(6,*) ii,jj,kk
					write(6,*) gcpx,gcpy,gcpz
		write(6,*) dom(ib)%xc(iic),dom(ib)%y(jjc),dom(ib)%zc(kkc)
		write(6,*) nodex_loc(nn),nodey_loc(nn),nodez_loc(nn)
		write(6,*)	vec2
		write(6,*)	vec3
					write(6,*) vvec2
					write(6,*) nx2
					write(6,*) nz2
					write(6,*) mrx, mry,mrz
		write(6,*) abs((dom(ib)%xc(iic)-mrx)/dom(ib)%dx)
		write(6,*) abs((dom(ib)%zc(kkc)-mrz)/dom(ib)%dz)
		write(6,*) abs((nx(1)-mrx)/dom(ib)%dx)
		write(6,*) abs((nz(1)-mrz)/dom(ib)%dz)
                        endif
					!
					!
						!
						endif
						!
						if(rotating(M).eq..FALSE.) then
							!k = -1.0d00	
							k = - mirror_v
						!elseif (rott_loc(nn).eq.2) then
						elseif(rotating(M).eq..TRUE.) then
							k = 2*V_p - mirror_v  ! moving body
							!k = -1.0d00
						endif
						!
						if(flag1.eq.0) dom(ib)%voo(iic,jjc,kkc) = k
						if(flag1.eq.1) dom(ib)%vstar(iic,jjc,kkc) = k
						if(flag1.eq.2) dom(ib)%v(iic,jjc,kkc) = k
						!
					!!!!!!!!!!!!!!!!!!!!!!!!!!!
				endif   ! Ensuring processor ID matches subdomain ID???
				!debug
				!
			endif ! ghost cell treatment for the v velocity field
			!
			!
			if(dom(ib)%mwcz(ii,jj,kk).ne.0)then ! ghost cell treatment for the w velocity field
				nn = dom(ib)%mwcznn(ii,jj,kk)  ! nn    id for IB point or marker 
				!
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 cw = cw + 1
				 !
				 !ib = dom(ib)%mwczib(ii,jj,kk)  ! ib    if for layer at which nn marker is located
				 ll = dom(ib)%mwczll(ii,jj,kk)  ! ll  
				 iic = dom(ib)%mwczi(ii,jj,kk)  ! iii   ox location of the w ghost cell 
				 jjc = dom(ib)%mwczj(ii,jj,kk)  ! jjc   oy location of the w ghost cell
				 kkk = dom(ib)%mwczk(ii,jj,kk)  ! kkk   oy location of the w ghost cell
				 qF = dom(ib)%mwcz(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                  
				 gcwx  = dom(ib)%mwczx(ii,jj,kk) ! ox location of the w ghost cell 
				 gcwy  = dom(ib)%mwczy(ii,jj,kk) ! oy location of the w ghost cell
				 gcwz  = dom(ib)%mwczz(ii,jj,kk) ! oy location of the w ghost cell
				 !                                 
				 gcwmx = dom(ib)%mwczmx(ii,jj,kk) ! ox location of the w mirror cell 
				 gcwmy = dom(ib)%mwczmy(ii,jj,kk) ! oy location of the w mirror cell
				 gcwmz = dom(ib)%mwczmz(ii,jj,kk) ! oy location of the w mirror cell
				 !                                 
				 gcwmi = dom(ib)%mwczmi(ii,jj,kk) ! dom(ib)%x id of the w mirror cell 
				 gcwmj = dom(ib)%mwczmj(ii,jj,kk) ! dom(ib)%y id of the w mirror cell
				 gcwmk = dom(ib)%mwczmk(ii,jj,kk) ! dom(ib)%z id of the w mirror cell
				 !
				 if(interpolationScheme.eq.1) then
				 	!deltaFUnction
					vec2(1) = nn ! nn	! Node nds(1.5)
					vec2(2) = ib ! ib 
					vec2(3) = ll ! ll
					vec2(4) = gcwmi ! id 
					vec2(5) = gcwmj ! jjj
					vec2(6) = gcwmk ! kd
					vec2(7) = flag1 ! flag1
					vec2(8) = 3 ! 3 ! fieldFlag for selecting 3 velocity
					vec3(1) = gcwmx !mrx
					vec3(2) = gcwmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
					vec3(3) = gcwmz !mrz
					call interpolationF(vec2,vec3,mirror_w)
				 elseif(interpolationScheme.eq.2) then
				    ! Least Squares interpolation
				    !
				    id = gcwmi
				    kd = gcwmk
				    mrx = gcwmx
				    mrz = gcwmz
				    !
				    wvec2(1) =  dom(ib)%wcpy(id-2,jjc,kd-2)
				    wvec2(2) =  dom(ib)%wcpy(id-1,jjc,kd-2)
				    wvec2(3) =  dom(ib)%wcpy(id+0,jjc,kd-2)
				    wvec2(4) =  dom(ib)%wcpy(id+1,jjc,kd-2)
				    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				    wvec2(5) =  dom(ib)%wcpy(id-2,jjc,kd-1)
				    wvec2(6) =  dom(ib)%wcpy(id-1,jjc,kd-1)
				    wvec2(7) =  dom(ib)%wcpy(id+0,jjc,kd-1)
				    wvec2(8) =  dom(ib)%wcpy(id+1,jjc,kd-1)
				    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				    wvec2(9) =  dom(ib)%wcpy(id-2,jjc,kd+0)
				    wvec2(10) = dom(ib)%wcpy(id-1,jjc,kd+0)
				    wvec2(11) = dom(ib)%wcpy(id+0,jjc,kd+0)
				    wvec2(12) = dom(ib)%wcpy(id+1,jjc,kd+0)
				    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				    wvec2(13) =  dom(ib)%wcpy(id-2,jjc,kd+1)
				    wvec2(14) =  dom(ib)%wcpy(id-1,jjc,kd+1)
				    wvec2(15) =  dom(ib)%wcpy(id+0,jjc,kd+1)
				    wvec2(16) =  dom(ib)%wcpy(id+1,jjc,kd+1)
				    !
				    !
					!
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					! Checking if any cell centre on the interpolation stencil is a ghost cell 
		!if((nn.eq.-1))then
	         if(0)then
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mwcz(idx,jdx,kdx).ne.0)then
			write(6,*) "Warning, using w ghost cell: ",dx,idx,jdx,kdx
			wvec2(dx) = 0.0d00!dom(ib)%wcpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					else !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					!
					!
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mwcz(idx,jdx,kdx).ne.0)then
			wvec2(dx) = 0.0d00!dom(ib)%wcpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					!
					!
					endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					!
					!
				    nx2(1) = dom(ib)%xc(id-2)
				    nx2(2) = dom(ib)%xc(id-1)
				    nx2(3) = dom(ib)%xc(id+0)
				    nx2(4) = dom(ib)%xc(id+1)
				    !
				    nz2(1) = dom(ib)%z(kd-2)
				    nz2(2) = dom(ib)%z(kd-1)
				    nz2(3) = dom(ib)%z(kd+0)
				    nz2(4) = dom(ib)%z(kd+1)
				    !
					wvec(1) = wvec2(6) !dom(ib)%wcpy(id-1,jjc,kd-1) ! q11
					wvec(2) = wvec2(7) !dom(ib)%wcpy(id,jjc,kd-1)   ! q21
					wvec(3) = wvec2(10) !dom(ib)%wcpy(id-1,jjc,kd)   ! q12
					wvec(4) = wvec2(11) !dom(ib)%wcpy(id,jjc,kd)	   ! q22
					!
					nx(1) = dom(ib)%xc(id-1)
					nx(2) = dom(ib)%xc(id)
					nz(1) = dom(ib)%z(kd-1)
					nz(2) = dom(ib)%z(kd)
					!
				    !
					!
					! Alternative: cwbic HP q4 FEM 
					vec2(1) = nn ! nn	! Node nds(1.5)
					vec2(2) = ib ! ib 
					vec2(3) = ll ! ll
					vec2(4) = gcwmi ! id 
					vec2(5) = gcwmj ! jjj
					vec2(6) = gcwmk ! kd
					vec2(7) = flag1 ! flag1
					vec2(8) = 3 ! 3 ! fieldFlag for selecting 3 velocity
					vec3(1) = gcwmx !mrx
					vec3(2) = gcwmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
					vec3(3) = gcwmz !mrz
					!
					!
		mirror_wa = bl_cramer(nn,nx,nz,wvec,mrx,mrz)
	if((nn.eq.-1))then
		write(6,*) "Mirror w (Bilinear Interpolation: cramer)",
     &	nn, mirror_wa
				endif
				!
					!
					!
	if((nn.eq.-1))then
					mirror_wa2 = bl_lu(vec2,nx,nz,wvec,mrx,mrz)
				   	write(6,*) "Mirror w (Bilinear Interpolation: LU)",
     &	nn, mirror_wa2
				   endif
				   !
				   !
				   !
	if((nn.eq.-1))then
					call interpolationF(vec2,vec3,mirror_w)
					write(6,*) "Mirror w (DeltaF phi_x)",
     &	nn, mirror_w
					endif
					!
					!
					!
		dwdxvec(1)=(wvec2(7) -wvec2(5))/(nx2(3)-nx2(1))!(dom(ib)%w(id+0,jjc,kd-1)-dom(ib)%w(id-2,jjc,kd-1))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dwdxvec(2)=(wvec2(8) -wvec2(6))/(nx2(4)-nx2(2))!(dom(ib)%w(id+1,jjc,kd-1)-dom(ib)%w(id-1,jjc,kd-1))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
		dwdxvec(3)=(wvec2(11)-wvec2(9)) /(nx2(3)-nx2(1))!(dom(ib)%w(id+0,jjc,kd+0)-dom(ib)%w(id-2,jjc,kd+0))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dwdxvec(4)=(wvec2(12)-wvec2(10))/(nx2(4)-nx2(2))!(dom(ib)%w(id+1,jjc,kd+0)-dom(ib)%w(id-1,jjc,kd+0))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
			   !
		dwdyvec(1)=(wvec2(10)-wvec2(2))/(nz2(3)-nz2(1))!(dom(ib)%w(id-1,jjc,kd+0)-dom(ib)%w(id-1,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dwdyvec(2)=(wvec2(11)-wvec2(3))/(nz2(3)-nz2(1))!(dom(ib)%w(id+0,jjc,kd+0)-dom(ib)%w(id+0,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dwdyvec(3)=(wvec2(14)-wvec2(6))/(nz2(4)-nz2(2))!(dom(ib)%w(id-1,jjc,kd+1)-dom(ib)%w(id-1,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
		dwdyvec(4)=(wvec2(15)-wvec2(7))/(nz2(4)-nz2(2))!(dom(ib)%w(id+0,jjc,kd+1)-dom(ib)%w(id+0,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
					!
                mirror_wb = fCubicHP1(vec2,nx,nz,wvec,
     &	dwdxvec,dwdyvec,mrx,mrz)
	 if((nn.eq.-1))then
                        write(6,*) "Mirror w (cubic HP q4 FEM)",
     &	nn, mirror_wb
                endif
				!
				!
		if((nn.eq.-1))then
        	mirror_wc = fQuadLagrange(vec2,qF,nx2,nz2,wvec2,mrx,mrz)
                    write(6,*) "Mirror w (Lagrange q4 FEM)",
     &	nn, mirror_wc
				endif
				!
                !
				!
				!
				!
				!
      if((nn.eq.-1))then
		mirror_wd = fBilinear(vec2,nx,nz,wvec,mrx,mrz)
                        write(6,*) "Mirror w (bilinear q4 FEM)",
     &	nn, mirror_wd
	 			endif
				!
				!
					!
					!
		if((nn.eq.-1))then
		mirror_we2 = ls_2ndOrder_cramerV2(vec2,nx2,nz2,wvec2,mrx,mrz)
					write(6,*) "Mirror w (ls_2ndOrder_q16_inverse_matrix)",
     &	nn, mirror_we2
	 				endif
					!
					!
		if((nn.eq.-1))then
			mirror_wf = ls_tseng_LU(vec2,nx,nz,wvec,mrx,mrz)
					write(6,*) "Mirror w (tseng_LU)",
     &	nn, mirror_wf
	 				endif
					!
					!
		if((nn.eq.-1))then
		mirror_wf2 = ls_tseng_LU_scaled(vec2,nx,nz,wvec,mrx,mrz)
					write(6,*) "Mirror w (tseng_scaled_LU)",
     &	nn, mirror_wf2
	 				endif
				!
				!
		!mirror_we = ls_2ndOrder_lu(nn,nx,nz,wvec,mrx,mrz)
		mirror_we = ls_2ndOrder_LU_lite(vec2,nx,nz,wvec,mrx,mrz)
		if((nn.eq.-1))then
					write(6,*) "Mirror w (ls_2ndOrder_LU)",
     &	nn, mirror_we
	 				endif
				!
				!
				! choosing interpolation method
				mirror_w = mirror_wb
				!
				! Checking for consitency among the mirror value and the local maxima and minima
		maxval = max_f(4,wvec)
		minval = min_f(4,wvec)
		if(mirror_w.gt.maxval)then
		mtmp = mirror_w
		mirror_w = mirror_wa ! bl_cramer(nn,nx,nz,wvec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! w solution ", mtmp 
		write(6,*) "out of local upper bound ",maxval,mirror_w !max_f(4,wvec)
			endif
		elseif(mirror_w.lt.minval)then
		mtmp = mirror_w
		mirror_w = mirror_wa ! bl_cramer(nn,nx,nz,wvec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! w solution ", mtmp
		write(6,*) "out of local lower bound ",minval,mirror_w !min_f(4,wvec)
			endif
		elseif(abs((mirror_w-mirror_wa)/mirror_wa).gt.0.3)then
			!mtmp = mirror_w
			!mirror_w = mirror_wa
		if((nn.eq.-1))then
		write(6,*) "WARNING! w solution ", mtmp
		write(6,*) "w above 30% of  ",mirror_wa,mirror_w !min_f(4,wvec)
			endif
		endif
				!
				!
		if((nn.eq.-1))then
					write(6,*) iic,jjc,kkk
					write(6,*) ii,jj,kk
					write(6,*) gcwx,gcwy,gcwz
		write(6,*) dom(ib)%xc(iic),dom(ib)%yc(jjc),dom(ib)%z(kkk)
		write(6,*) nodex_loc(nn),nodey_loc(nn),nodez_loc(nn)
		write(6,*)	vec2
		write(6,*)	vec3
					write(6,*) wvec2
					write(6,*) nx2
					write(6,*) nz2
					write(6,*) mrx, mry,mrz
		write(6,*) abs((dom(ib)%xc(iic)-mrx)/dom(ib)%dx)
		write(6,*) abs((dom(ib)%z(kkk)-mrz)/dom(ib)%dz)
		write(6,*) abs((nx(1)-mrx)/dom(ib)%dx)
		write(6,*) abs((nz(1)-mrz)/dom(ib)%dz)
                        endif
				!
				!
				 endif
				 !
				 !if (rott_loc(nn).eq.1) then
				 if(ll.eq.1)then
					if (gcwmi.eq.0) then
						write(*,*) "In ghostCells gcwmi = 0", nn, iic, kkk
						write(*,*) gcwx, gcwy, gcwz
					 endif
					 if (gcwmj.eq.0) then
						write(*,*) "In ghostCells gcwmj = 0", nn, iic, kkk
						write(*,*) gcwx, gcwy, gcwz
					 endif
					 if (gcwmk.eq.0) then
						write(*,*) "In ghostCells gcwmk = 0", nn, iic, kkk
						write(*,*) gcwx, gcwy, gcwz
					 endif
				 if(rotating(M).eq..FALSE.) then
					!k = -1.0d00	
				 	k = - mirror_w
				 !elseif (rott_loc(nn).eq.2) then
				 elseif(rotating(M).eq..TRUE.) then
					 k = 2*W_p - mirror_w  ! moving bodys
					! k = -1.0d00
				 endif
				 elseif(ll.eq.2)then
					k = 0.0d00
				 endif
				 !
				 if(flag1.eq.0) dom(ib)%woo(iic,jjc,kkk) = k
				 if(flag1.eq.1) dom(ib)%wstar(iic,jjc,kkk) = k
				 if(flag1.eq.2) dom(ib)%w(iic,jjc,kkk) = k
				 !
				 !St_k = ibmSt(M) ! number of station of the inmmersed body
				 !mksPS = ibmStMkrs(M)	! Markers per station
				 !mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				 !nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				 !nnStart = 1 + (int(St_k/2.0d00))*mksPS
				    !if(flag1.eq.1) then
					!if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
					!   !	write(6,*) nn, k ,rott_loc(nn)
					!	 write(*,*) "WSTAR___WSTAR___WSTAR___WSTAR"
					!	   write(6,*) nn, iic,jjc,kkk
					!	   write(6,*) dom(ib)%mwcz(iic,jjc,kkk),qF
					!	   write(6,*) dom(ib)%wstar(iic,jjc,kkk)
					!   !write(6,*) qF, fieldF, fieldVal
					!   !write(6,*) vec2(1),vec2(2),vec2(3)
					!   !write(6,*) vec2(4),vec2(5),vec2(6)
					!   !write(6,*) vec2(7),vec2(8)
					!   !write(6,*) vec3(1),vec3(2),vec3(3)
					!   !write(6,*) "======================="
					!endif
					!endif
					!if(flag1.eq.2) then
					!if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
					!   !	write(6,*) nn, k ,rott_loc(nn)
					!	 write(*,*) "W_____W_____W_____W_____W_____W"
					!	   write(6,*) nn, iic,jjc,kkk
					!	   write(6,*) dom(ib)%mwcz(iic,jjc,kkk),qF
					!	   write(6,*) dom(ib)%w(iic,jjc,kkk)
					!   !write(6,*) qF, fieldF, fieldVal
					!   !write(6,*) vec2(1),vec2(2),vec2(3)
					!   !write(6,*) vec2(4),vec2(5),vec2(6)
					!   !write(6,*) vec2(7),vec2(8)
					!   !write(6,*) vec3(1),vec3(2),vec3(3)
					!   !write(6,*) "======================="
				   !endif
				   !endif
				endif   ! Ensuring processor ID matches subdomain ID???
				!debug
				!
			endif ! ghost cell treatment for the w velocity field
			!
			if( ( flag1.eq.0 ).or. ( flag1.eq.2) ) then
			if(dom(ib)%mpc(ii,jj,kk).ne.0)then ! ghost cell treatment for the pressure field
				nn = dom(ib)%mpcnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				  	!
				 	cp = cp + 1
					!
				 	!ib  = dom(ib)%mpcib(ii,jj,kk)  ! ib    if for layer at which nn marker is located
					ll  = dom(ib)%mpcll(ii,jj,kk)  ! ll  
					iic = dom(ib)%mpci(ii,jj,kk)  ! iii   ox location of the p ghost cell 
					jjc = dom(ib)%mpcj(ii,jj,kk)  ! jjc   oy location of the p ghost cell
					kkc = dom(ib)%mpck(ii,jj,kk)  ! kkk   oy location of the p ghost cell
					qF  = dom(ib)%mpc(ii,jj,kk)	  ! qf 
					M   = lag_bod_loc(nn)
					!                                  
					gcpx  = dom(ib)%mpcx(ii,jj,kk) ! ox location of the p ghost cell 
					gcpy  = dom(ib)%mpcy(ii,jj,kk) ! oy location of the p ghost cell
					gcpz  = dom(ib)%mpcz(ii,jj,kk) ! oy location of the p ghost cell
					!                                 
					gcpmx = dom(ib)%mpcmx(ii,jj,kk) ! ox location of the p mirror cell 
					gcpmy = dom(ib)%mpcmy(ii,jj,kk) ! oy location of the p mirror cell
					gcpmz = dom(ib)%mpcmz(ii,jj,kk) ! oy location of the p mirror cell
					!                                 
					gcpmi = dom(ib)%mpcmi(ii,jj,kk) ! dom(ib)%x id of the p mirror cell 
					gcpmj = dom(ib)%mpcmj(ii,jj,kk) ! dom(ib)%y id of the p mirror cell
					gcpmk = dom(ib)%mpcmk(ii,jj,kk) ! dom(ib)%z id of the p mirror cell
				    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				    ! Least Squares interpolation
					!
				    id = gcpmi
				    kd = gcpmk
					!
				    mrx = gcpmx
				    mrz = gcpmz
					!
					pvec2(1) =  dom(ib)%pcpy(id-2,jjc,kd-2)
					pvec2(2) =  dom(ib)%pcpy(id-1,jjc,kd-2)
					pvec2(3) =  dom(ib)%pcpy(id+0,jjc,kd-2)
					pvec2(4) =  dom(ib)%pcpy(id+1,jjc,kd-2)
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					pvec2(5) =  dom(ib)%pcpy(id-2,jjc,kd-1)
					pvec2(6) =  dom(ib)%pcpy(id-1,jjc,kd-1)
					pvec2(7) =  dom(ib)%pcpy(id+0,jjc,kd-1)
					pvec2(8) =  dom(ib)%pcpy(id+1,jjc,kd-1)
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					pvec2(9) =  dom(ib)%pcpy(id-2,jjc,kd+0)
					pvec2(10) = dom(ib)%pcpy(id-1,jjc,kd+0)
					pvec2(11) = dom(ib)%pcpy(id+0,jjc,kd+0)
					pvec2(12) = dom(ib)%pcpy(id+1,jjc,kd+0)
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					pvec2(13) =  dom(ib)%pcpy(id-2,jjc,kd+1)
					pvec2(14) =  dom(ib)%pcpy(id-1,jjc,kd+1)
					pvec2(15) =  dom(ib)%pcpy(id+0,jjc,kd+1)
					pvec2(16) =  dom(ib)%pcpy(id+1,jjc,kd+1)
					!
					!
					!
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					! Checking if any cell centre on the interpoltion stencil is a ghost cell 
		!if((nn.eq.-1))then
	         if(0)then
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mpc(idx,jdx,kdx).ne.0)then
			write(6,*) "Warning, using p ghost cell: ",dx,idx,jdx,kdx
			!pvec2(dx) = 0.0d00!dom(ib)%pcpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					else !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					!
					!
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mpc(idx,jdx,kdx).ne.0)then
			!pvec2(dx) = 0.0d00!dom(ib)%pcpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					!
					!
					endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					!
					!
					nx2(1) = dom(ib)%xc(id-2)
					nx2(2) = dom(ib)%xc(id-1)
					nx2(3) = dom(ib)%xc(id+0)
					nx2(4) = dom(ib)%xc(id+1)
					!
					nz2(1) = dom(ib)%zc(kd-2)
					nz2(2) = dom(ib)%zc(kd-1)
					nz2(3) = dom(ib)%zc(kd+0)
					nz2(4) = dom(ib)%zc(kd+1)
					!
			        pvec(1) = pvec2(6) ! dom(ib)%pcpy(id-1,jjc,kd-1) ! q11
			        pvec(2) = pvec2(7) ! dom(ib)%pcpy(id,jjc,kd-1)   ! q21
			        pvec(3) = pvec2(10) ! dom(ib)%pcpy(id-1,jjc,kd)   ! q12
			        pvec(4) = pvec2(11) ! dom(ib)%pcpy(id,jjc,kd)	   ! q22
					!
					!
			        nx(1) = dom(ib)%xc(id-1)	! Check %xc(id-1)
			        nx(2) = dom(ib)%xc(id)
			        nz(1) = dom(ib)%zc(kd-1)
			        nz(2) = dom(ib)%zc(kd)
			        !	mirror_p = bilinear1(nn,nx,nz,pvec,mrx,mrz)
			        !	if(nn.eq.126) then
			        !		write(6,*) "Mirror p (Bilinear Interpolation: explicit)",mirror_p
			        !	endif
			        !!! LINEAR INTERPOLATION
			        !mirror_p = l1(nn,nx,nz,pvec,mrx,mrz)
			        !if(nn.eq.70) then
			        !	write(6,*) "Mirror p (linear interpolation)", nn, mirror_p
			        !endif
	if((nn.eq.-1))then
		mirror_pa = bl_cramer(nn,nx,nz,pvec,mrx,mrz)
				   	write(6,*) "Mirror p (Bilinear Interpolation: cramer)",
     &	nn, mirror_pa
				   endif
					!
				    !
				    !deltaFUnction
					! Alternative: cvbic HP q4 FEM 
				    vec2(1) = nn ! nn	! Node nds(1.5)
				    vec2(2) = ib ! ib 
				    vec2(3) = ll ! ll
				    vec2(4) = gcpmi ! id 
				    vec2(5) = gcpmj ! jjj
				    vec2(6) = gcpmk ! kd
				    vec2(7) = flag1 ! flag1
				    vec2(8) = 4 ! 1 ! fieldFlag for selecting p pressure
				    vec3(1) = gcpmx !mrx
				    vec3(2) = gcpmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
				    vec3(3) = gcpmz !mrz
					!
	if((nn.eq.-1))then
					mirror_pa2 = bl_lu(vec2,nx,nz,pvec,mrx,mrz)
				   	write(6,*) "Mirror p (Bilinear Interpolation: LU)",
     &	nn, mirror_pa2
				   endif
					!
				    !
				    !
	if((nn.eq.-1))then
					call interpolationF(vec2,vec3,mirror_p)
					write(6,*) "Mirror p (DeltaF phi_x)",
     &	nn, mirror_p
					endif
					!
				    !
					!
					!
		dpdxvec(1)=(pvec2(7) -pvec2(5))/(nx2(3)-nx2(1))!(dom(ib)%v(id+0,jjc,kd-1)-dom(ib)%v(id-2,jjc,kd-1))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dpdxvec(2)=(pvec2(8) -pvec2(6))/(nx2(4)-nx2(2))!(dom(ib)%v(id+1,jjc,kd-1)-dom(ib)%v(id-1,jjc,kd-1))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
		dpdxvec(3)=(pvec2(11)-pvec2(9)) /(nx2(3)-nx2(1))!(dom(ib)%v(id+0,jjc,kd+0)-dom(ib)%v(id-2,jjc,kd+0))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dpdxvec(4)=(pvec2(12)-pvec2(10))/(nx2(4)-nx2(2))!(dom(ib)%v(id+1,jjc,kd+0)-dom(ib)%v(id-1,jjc,kd+0))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
			   !
		dpdyvec(1)=(pvec2(10)-pvec2(2))/(nz2(3)-nz2(1))!(dom(ib)%v(id-1,jjc,kd+0)-dom(ib)%v(id-1,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dpdyvec(2)=(pvec2(11)-pvec2(3))/(nz2(3)-nz2(1))!(dom(ib)%v(id+0,jjc,kd+0)-dom(ib)%v(id+0,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dpdyvec(3)=(pvec2(14)-pvec2(6))/(nz2(4)-nz2(2))!(dom(ib)%v(id-1,jjc,kd+1)-dom(ib)%v(id-1,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
		dpdyvec(4)=(pvec2(15)-pvec2(7))/(nz2(4)-nz2(2))!(dom(ib)%v(id+0,jjc,kd+1)-dom(ib)%v(id+0,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
					!
                mirror_pb = fCubicHP1(vec2,nx,nz,pvec,
     &	dpdxvec,dpdyvec,mrx,mrz)
	 if((nn.eq.-1))then
                        write(6,*) "Mirror p (cubic HP q4 FEM)",
     &	nn, mirror_pb
                endif
				!
				!
				!
				!
	if((nn.eq.-1))then
		mirror_pc = fQuadLagrange(vec2,qF,nx2,nz2,pvec2,mrx,mrz)
                    write(6,*) "Mirror p (Lagrange q4 FEM)",
     &	nn, mirror_pc
				endif
				!
				!
                !
				!
				!
				!
      if((nn.eq.-1))then
		mirror_pd = fBilinear(vec2,nx,nz,pvec,mrx,mrz)
                    write(6,*) "Mirror p (bilinear q4 FEM)",
     &	nn, mirror_pd
	 			endif
				!
				!
				!
					!
					!
		if((nn.eq.-1))then
		mirror_pe2 = ls_2ndOrder_cramerV2(vec2,nx2,nz2,pvec2,mrx,mrz)
					write(6,*) "Mirror p (ls_2ndOrder_q16_inverse_matrix)",
     &	nn, mirror_pe2
	 				endif
					!
					!
		if((nn.eq.-1))then
			mirror_pf = ls_tseng_LU(vec2,nx,nz,pvec,mrx,mrz)
					write(6,*) "Mirror p (tseng_LU)",
     &	nn, mirror_pf
	 				endif
					!
					!
		if((nn.eq.-1))then
		mirror_pf2 = ls_tseng_LU_scaled(vec2,nx,nz,pvec,mrx,mrz)
					write(6,*) "Mirror p (tseng_scaled_LU)",
     &	nn, mirror_pf2
	 				endif
				!
				!
		if((nn.eq.-1))then
       mirror_pe = ls_2ndOrder_LU_lite(vec2,nx,nz,pvec,mrx,mrz)
					write(6,*) "Mirror p (ls_2ndOrder_LU)",
     &	nn, mirror_pe
	 				endif
				!
				!
				! Choosing interpolation method
				mirror_p = mirror_pb
				!
				! Checking for consitency among the mirror value and the local maxima and minima
		maxval = max_f(4,pvec)
		minval = min_f(4,pvec)
		if(mirror_p.gt.maxval)then 
		mtmp = mirror_p
		mirror_p = bl_cramer(nn,nx,nz,pvec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! p solution ",mtmp
		write(6,*) "out of upper bounds ",maxval,mirror_p !max_f(4,pvec)
			endif
		elseif(mirror_p.lt.minval)then
		mtmp = mirror_p
		mirror_p = bl_cramer(nn,nx,nz,pvec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! p solution ", mtmp
		write(6,*) " out of lower bounds ",minval,mirror_p !min_f(4,pvec)
			endif
		elseif(abs((mirror_p-mirror_pa)/mirror_pa).gt.0.3)then
			!mtmp = mirror_p
			!mirror_p = mirror_pa
		if((nn.eq.-1))then
		write(6,*) "WARNING! p solution ", mtmp
		write(6,*) "p above 30% of  ",mirror_pa,mirror_p !min_f(4,wvec)
			endif
		endif
					!
					!
		if((nn.eq.-1))then
					write(6,*) iic,jjc,kkc
					write(6,*) ii,jj,kk
					write(6,*) gcpx,gcpy,gcpz
		write(6,*) dom(ib)%xc(iic),dom(ib)%yc(jjc),dom(ib)%zc(kkc)
		write(6,*) nodex_loc(nn),nodey_loc(nn),nodez_loc(nn)
		write(6,*)	vec2
		write(6,*)	vec3
					write(6,*) pvec2
					write(6,*) nx2
					write(6,*) nz2
					write(6,*) mrx, mry,mrz
		write(6,*) abs((dom(ib)%xc(iic)-mrx)/dom(ib)%dx)
		write(6,*) abs((dom(ib)%zc(kkc)-mrz)/dom(ib)%dz)
		write(6,*) abs((nx(1)-mrx)/dom(ib)%dx)
		write(6,*) abs((nz(1)-mrz)/dom(ib)%dz)
                        endif
					!
					!
				    !call interpolationF(vec2,vec3,mirror_p)
					!
					if(ll.eq.1) then
						if (gcpmi.eq.0) then
							write(*,*) "In ghostCells gcpmi = 0", nn, iic, kkk
							write(*,*) gcpx, gcpy, gcpz
						 endif
						 if (gcpmj.eq.0) then
							write(*,*) "In ghostCells gcpmj = 0", nn, iic, kkk
							write(*,*) gcpx, gcpy, gcpz
						 endif
						 if (gcpmk.eq.0) then
							write(*,*) "In ghostCells gcpmk = 0", nn, iic, kkk
							write(*,*) gcpx, gcpy, gcpz
						 endif
					!k = 0.002d00
					k = mirror_p		! layer S3  ke4
					!elseif(ll.eq.2)then
					!	k = 0.002d00
					endif
				    !
				    dom(ib)%p(iic,jjc,kkc) = k
					!
					! debug
					!St_k = ibmSt(M) ! number of station of the inmmersed body
					!mksPS = ibmStMkrs(M)	! Markers per station
					!mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
					!nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
					!nnStart = 1 + (int(St_k/2.0d00))*mksPS
					!if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
					!	!	write(6,*) nn, k ,rott_loc(nn)
					!	  write(*,*) "p_____p_____p_____p_____p_____p"
					!		write(6,*) nn,qF 
					!		write(6,*) iic,jjc,kkc
					!		write(6,*) id,kd
					!		write(6,*) nx,nz
					!		write(6,*) mrx,mrz
					!		write(6,*) pvec
					!		write(6,*) k!dom(ib)%p(iic,jjc,kkc)
					!endif
					!
					!!!!!!!!!!!!!!!!!!!!!!!!!!!
				endif   ! Ensuring processor ID matches subdomain ID???
				!
			endif ! ghost cell treatment for the pressure field
			endif ! flag1
			!
			if(flag_LSM .eq. .TRUE. ) then ! flag_LSM
			if( ( flag1.eq.0 ).or. ( flag1.eq.2) ) then
			if(dom(ib)%mpc(ii,jj,kk).ne.0)then ! ghost cell treatment for the phi field
				nn = dom(ib)%mpcnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				  	!
				 	cfi = cfi + 1
					!
				 	!ib  = dom(ib)%mpcib(ii,jj,kk)  ! ib    if for layer at which nn marker is located
					ll  = dom(ib)%mpcll(ii,jj,kk)  ! ll  
					iic = dom(ib)%mpci(ii,jj,kk)  ! iii   ox location of the p ghost cell 
					jjc = dom(ib)%mpcj(ii,jj,kk)  ! jjc   oy location of the p ghost cell
					kkc = dom(ib)%mpck(ii,jj,kk)  ! kkk   oy location of the p ghost cell
					qF  = dom(ib)%mpc(ii,jj,kk)	  ! qf 
					M   = lag_bod_loc(nn)
					!                                  
					gcpx  = dom(ib)%mpcx(ii,jj,kk) ! ox location of the p ghost cell 
					gcpy  = dom(ib)%mpcy(ii,jj,kk) ! oy location of the p ghost cell
					gcpz  = dom(ib)%mpcz(ii,jj,kk) ! oy location of the p ghost cell
					!                                 
					gcpmx = dom(ib)%mpcmx(ii,jj,kk) ! ox location of the p mirror cell 
					gcpmy = dom(ib)%mpcmy(ii,jj,kk) ! oy location of the p mirror cell
					gcpmz = dom(ib)%mpcmz(ii,jj,kk) ! oy location of the p mirror cell
					!                                 
					gcpmi = dom(ib)%mpcmi(ii,jj,kk) ! dom(ib)%x id of the p mirror cell 
					gcpmj = dom(ib)%mpcmj(ii,jj,kk) ! dom(ib)%y id of the p mirror cell
					gcpmk = dom(ib)%mpcmk(ii,jj,kk) ! dom(ib)%z id of the p mirror cell
				    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				    ! Least Squares interpolation
					!
				    id = gcpmi
				    kd = gcpmk
					!
				    mrx = gcpmx
				    mrz = gcpmz
					!
					phivec2(1) =  dom(ib)%phicpy(id-2,jjc,kd-2)
					phivec2(2) =  dom(ib)%phicpy(id-1,jjc,kd-2)
					phivec2(3) =  dom(ib)%phicpy(id+0,jjc,kd-2)
					phivec2(4) =  dom(ib)%phicpy(id+1,jjc,kd-2)
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					phivec2(5) =  dom(ib)%phicpy(id-2,jjc,kd-1)
					phivec2(6) =  dom(ib)%phicpy(id-1,jjc,kd-1)
					phivec2(7) =  dom(ib)%phicpy(id+0,jjc,kd-1)
					phivec2(8) =  dom(ib)%phicpy(id+1,jjc,kd-1)
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					phivec2(9) =  dom(ib)%phicpy(id-2,jjc,kd+0)
					phivec2(10) = dom(ib)%phicpy(id-1,jjc,kd+0)
					phivec2(11) = dom(ib)%phicpy(id+0,jjc,kd+0)
					phivec2(12) = dom(ib)%phicpy(id+1,jjc,kd+0)
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					phivec2(13) =  dom(ib)%phicpy(id-2,jjc,kd+1)
					phivec2(14) =  dom(ib)%phicpy(id-1,jjc,kd+1)
					phivec2(15) =  dom(ib)%phicpy(id+0,jjc,kd+1)
					phivec2(16) =  dom(ib)%phicpy(id+1,jjc,kd+1)
					!
					!
					!
					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					! Checking if any cell centre on the interpoltion stencil is a ghost cell 
		!if((nn.eq.-1))then
	         if(0)then
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mpc(idx,jdx,kdx).ne.0)then
			write(6,*) "Warning, using p ghost cell: ",dx,idx,jdx,kdx
			!phivec2(dx) = 0.0d00!dom(ib)%phicpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					else !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					!
					!
					dx = 0
					!do jdx = jjc-1, jjc
					jdx = jjc
					do kdx = kd-2, kd+1
					do idx = id-2,id+1
						dx = dx + 1
						if(dom(ib)%mpc(idx,jdx,kdx).ne.0)then
			!phivec2(dx) = 0.0d00!dom(ib)%phicpy(idx,jdx,kdx)    
						endif
					enddo
					enddo
					!enddo
					!
					!
					endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					!
					!
					nx2(1) = dom(ib)%xc(id-2)
					nx2(2) = dom(ib)%xc(id-1)
					nx2(3) = dom(ib)%xc(id+0)
					nx2(4) = dom(ib)%xc(id+1)
					!
					nz2(1) = dom(ib)%zc(kd-2)
					nz2(2) = dom(ib)%zc(kd-1)
					nz2(3) = dom(ib)%zc(kd+0)
					nz2(4) = dom(ib)%zc(kd+1)
					!
			        phivec(1) = phivec2(6) ! dom(ib)%phicpy(id-1,jjc,kd-1) ! q11
			        phivec(2) = phivec2(7) ! dom(ib)%phicpy(id,jjc,kd-1)   ! q21
			        phivec(3) = phivec2(10) ! dom(ib)%phicpy(id-1,jjc,kd)   ! q12
			        phivec(4) = phivec2(11) ! dom(ib)%phicpy(id,jjc,kd)	   ! q22
					!
					!
			        nx(1) = dom(ib)%xc(id-1)	! Check %xc(id-1)
			        nx(2) = dom(ib)%xc(id)
			        nz(1) = dom(ib)%zc(kd-1)
			        nz(2) = dom(ib)%zc(kd)
			        !	mirror_phi = bilinear1(nn,nx,nz,phivec,mrx,mrz)
			        !	if(nn.eq.126) then
			        !		write(6,*) "Mirror p (Bilinear Interpolation: explicit)",mirror_phi
			        !	endif
			        !!! LINEAR INTERPOLATION
			        !mirror_phi = l1(nn,nx,nz,phivec,mrx,mrz)
			        !if(nn.eq.70) then
			        !	write(6,*) "Mirror p (linear interpolation)", nn, mirror_phi
			        !endif
					mirror_phia = bl_cramer(nn,nx,nz,phivec,mrx,mrz)
	if((nn.eq.-1))then
				   	write(6,*) "Mirror p (Bilinear Interpolation: cramer)",
     &	nn, mirror_phia
				   endif
					!
				    !
				    !deltaFUnction
					! Alternative: cvbic HP q4 FEM 
				    vec2(1) = nn ! nn	! Node nds(1.5)
				    vec2(2) = ib ! ib 
				    vec2(3) = ll ! ll
				    vec2(4) = gcpmi ! id 
				    vec2(5) = gcpmj ! jjj
				    vec2(6) = gcpmk ! kd
				    vec2(7) = flag1 ! flag1
				    vec2(8) = 4 ! 1 ! fieldFlag for selecting phi
				    vec3(1) = gcpmx !mrx
				    vec3(2) = gcpmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
				    vec3(3) = gcpmz !mrz
					!
	if((nn.eq.-1))then
					mirror_phia2 = bl_lu(vec2,nx,nz,phivec,mrx,mrz)
				   	write(6,*) "Mirror p (Bilinear Interpolation: LU)",
     &	nn, mirror_phia2
				   endif
					!
				    !
				    !
	if((nn.eq.-1))then
					call interpolationF(vec2,vec3,mirror_phi)
					write(6,*) "Mirror p (DeltaF phi_x)",
     &	nn, mirror_phi
					endif
					!
				    !
					!
					!
		dphidxvec(1)=(phivec2(7) -phivec2(5))/(nx2(3)-nx2(1))!(dom(ib)%v(id+0,jjc,kd-1)-dom(ib)%v(id-2,jjc,kd-1))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dphidxvec(2)=(phivec2(8) -phivec2(6))/(nx2(4)-nx2(2))!(dom(ib)%v(id+1,jjc,kd-1)-dom(ib)%v(id-1,jjc,kd-1))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
		dphidxvec(3)=(phivec2(11)-phivec2(9)) /(nx2(3)-nx2(1))!(dom(ib)%v(id+0,jjc,kd+0)-dom(ib)%v(id-2,jjc,kd+0))/(dom(ib)%x(id+0)-dom(ib)%x(id-2))
		dphidxvec(4)=(phivec2(12)-phivec2(10))/(nx2(4)-nx2(2))!(dom(ib)%v(id+1,jjc,kd+0)-dom(ib)%v(id-1,jjc,kd+0))/(dom(ib)%x(id+1)-dom(ib)%x(id-1))
			   !
		dphidyvec(1)=(phivec2(10)-phivec2(2))/(nz2(3)-nz2(1))!(dom(ib)%v(id-1,jjc,kd+0)-dom(ib)%v(id-1,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dphidyvec(2)=(phivec2(11)-phivec2(3))/(nz2(3)-nz2(1))!(dom(ib)%v(id+0,jjc,kd+0)-dom(ib)%v(id+0,jjc,kd-2))/(dom(ib)%z(id+0)-dom(ib)%z(id-2))
		dphidyvec(3)=(phivec2(14)-phivec2(6))/(nz2(4)-nz2(2))!(dom(ib)%v(id-1,jjc,kd+1)-dom(ib)%v(id-1,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
		dphidyvec(4)=(phivec2(15)-phivec2(7))/(nz2(4)-nz2(2))!(dom(ib)%v(id+0,jjc,kd+1)-dom(ib)%v(id+0,jjc,kd-1))/(dom(ib)%z(id+1)-dom(ib)%z(id-1))
					!
                mirror_phib = fCubicHP1(vec2,nx,nz,phivec,
     &	dphidxvec,dphidyvec,mrx,mrz)
	 if((nn.eq.-1))then
                        write(6,*) "Mirror p (cubic HP q4 FEM)",
     &	nn, mirror_phib
                endif
				!
				!
				!
				!
	if((nn.eq.-1))then
		mirror_phic = fQuadLagrange(vec2,qF,nx2,nz2,phivec2,mrx,mrz)
                    write(6,*) "Mirror p (Lagrange q4 FEM)",
     &	nn, mirror_phic
				endif
				!
				!
                !
				!
				!
				!
      if((nn.eq.-1))then
		mirror_phid = fBilinear(vec2,nx,nz,phivec,mrx,mrz)
                    write(6,*) "Mirror p (bilinear q4 FEM)",
     &	nn, mirror_phid
	 			endif
				!
				!
				!
					!
					!
		if((nn.eq.-1))then
		mirror_phie2 = ls_2ndOrder_cramerV2(vec2,nx2,nz2,phivec2,mrx,mrz)
					write(6,*) "Mirror p (ls_2ndOrder_q16_inverse_matrix)",
     &	nn, mirror_phie2
	 				endif
					!
					!
		if((nn.eq.-1))then
			mirror_phif = ls_tseng_LU(vec2,nx,nz,phivec,mrx,mrz)
					write(6,*) "Mirror p (tseng_LU)",
     &	nn, mirror_phif
	 				endif
					!
					!
		if((nn.eq.-1))then
		mirror_phif2 = ls_tseng_LU_scaled(vec2,nx,nz,phivec,mrx,mrz)
					write(6,*) "Mirror p (tseng_scaled_LU)",
     &	nn, mirror_phif2
	 				endif
				!
				!
		if((nn.eq.-1))then
       mirror_phie = ls_2ndOrder_LU_lite(vec2,nx,nz,phivec,mrx,mrz)
					write(6,*) "Mirror p (ls_2ndOrder_LU)",
     &	nn, mirror_phie
	 				endif
				!
				!
				! Choosing interpolation method
				mirror_phi = mirror_phib
				!
				! Checking for consitency among the mirror value and the local maxima and minima
		maxval = max_f(4,phivec)
		minval = min_f(4,phivec)
		if(mirror_phi.gt.maxval)then 
		mtmp = mirror_phi
		mirror_phi = bl_cramer(nn,nx,nz,phivec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! p solution ",mtmp
		write(6,*) "out of upper bounds ",maxval,mirror_phi !max_f(4,phivec)
			endif
		elseif(mirror_phi.lt.minval)then
		mtmp = mirror_phi
		mirror_phi = bl_cramer(nn,nx,nz,phivec,mrx,mrz)
		if((nn.eq.-1))then
		write(6,*) "WARNING! p solution ", mtmp
		write(6,*) " out of lower bounds ",minval,mirror_phi !min_f(4,phivec)
			endif
		elseif(abs((mirror_phi-mirror_phia)/mirror_phia).gt.0.3)then
			!mtmp = mirror_phi
			!mirror_phi = mirror_phia
		if((nn.eq.-1))then
		write(6,*) "WARNING! p solution ", mtmp
		write(6,*) "p above 30% of  ",mirror_phia,mirror_phi !min_f(4,wvec)
			endif
		endif
					!
					!
		if((nn.eq.-1))then
					write(6,*) iic,jjc,kkc
					write(6,*) ii,jj,kk
					write(6,*) gcpx,gcpy,gcpz
		write(6,*) dom(ib)%xc(iic),dom(ib)%yc(jjc),dom(ib)%zc(kkc)
		write(6,*) nodex_loc(nn),nodey_loc(nn),nodez_loc(nn)
		write(6,*)	vec2
		write(6,*)	vec3
					write(6,*) phivec2
					write(6,*) nx2
					write(6,*) nz2
					write(6,*) mrx, mry,mrz
		write(6,*) abs((dom(ib)%xc(iic)-mrx)/dom(ib)%dx)
		write(6,*) abs((dom(ib)%zc(kkc)-mrz)/dom(ib)%dz)
		write(6,*) abs((nx(1)-mrx)/dom(ib)%dx)
		write(6,*) abs((nz(1)-mrz)/dom(ib)%dz)
                        endif
					!
					!
				    !call interpolationF(vec2,vec3,mirror_phi)
					!
					if(ll.eq.1) then
						if (gcpmi.eq.0) then
							write(*,*) "In ghostCells gcpmi = 0", nn, iic, kkk
							write(*,*) gcpx, gcpy, gcpz
						 endif
						 if (gcpmj.eq.0) then
							write(*,*) "In ghostCells gcpmj = 0", nn, iic, kkk
							write(*,*) gcpx, gcpy, gcpz
						 endif
						 if (gcpmk.eq.0) then
							write(*,*) "In ghostCells gcpmk = 0", nn, iic, kkk
							write(*,*) gcpx, gcpy, gcpz
						 endif
					!k = 0.002d00
					k = mirror_phi		! layer S3  ke4
					!elseif(ll.eq.2)then
					!	k = 0.002d00
					endif
				    !
				    dom(ib)%phi(iic,jjc,kkc) = k
					!
					! debug
					!St_k = ibmSt(M) ! number of station of the inmmersed body
					!mksPS = ibmStMkrs(M)	! Markers per station
					!mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
					!nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
					!nnStart = 1 + (int(St_k/2.0d00))*mksPS
					!if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
					!	!	write(6,*) nn, k ,rott_loc(nn)
					!	  write(*,*) "p_____p_____p_____p_____p_____p"
					!		write(6,*) nn,qF 
					!		write(6,*) iic,jjc,kkc
					!		write(6,*) id,kd
					!		write(6,*) nx,nz
					!		write(6,*) mrx,mrz
					!		write(6,*) phivec
					!		write(6,*) k!dom(ib)%phi(iic,jjc,kkc)
					!endif
					!
					!!!!!!!!!!!!!!!!!!!!!!!!!!!
				endif   ! Ensuring processor ID matches subdomain ID???
				!
			endif ! ghost cell treatment for the phi field
			endif ! flag1
			endif ! ! flag_LSM
			!
		enddo
		enddo
		enddo
		!
		!aaa	!$OMP END PARALLEL DO
		!
		!aaa	!$OMP end DO
		!aaa	!$OMP END PARALLEL	
		!
		!
		if(cu.gt.0) write(*,*) "u ghost cells employed: ", cu
		if(cv.gt.0) write(*,*) "v ghost cells employed: ", cv
		if(cw.gt.0) write(*,*) "w ghost cells employed: ", cw
		if(cp.gt.0) write(*,*) "p ghost cells employed: ", cp
		if(cfi.gt.0) write(*,*) "phi ghost cells employed: ", cfi
		!
	endif ! Filtering out procesors
	!
	enddo ! End of the  loop sweeping the domains
			CONTAINS


			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)	!sol = [ phi, dphi/dx, dphi/dz, d2phi/dxdz ]
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_lu(infoVec,nx,
     &	nz,pvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::infoVec(8)
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
            !
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
            INTEGER:: D, CODE, p2(4)
			INTEGER:: nn,ib,ll,ii,jj,kk,flag1,fieldFlag
			!
			!
			nn = infoVec(1) ! nn	! Node nds(1.5)
			ib = infoVec(2) ! ib 
			ll = infoVec(3) ! ll
			ii = infoVec(4) ! id 
			jj = infoVec(5) ! jjj
			kk = infoVec(6) ! kd
			flag1 = infoVec(7) ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
			fieldFlag = infoVec(8) ! 1 ! fieldFlag for selecting u velocity
			!gcumx = vec3(1) !mrx
			!gcumy = vec3(2) !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			!gcumz = vec3(3) !mrz
			!
			!
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			!
            !
            if(itime.le.itime_start+1) then ! initialization check 
            !
			dx1 = nx(1) - mrx	!dom(ib)%x(id-1 ) - mrx
			dx2 = nx(2) - mrx	!dom(ib)%x(id+0 ) - mrx
			dz1 = nz(1) - mrz	!dom(ib)%zc(kd-1) - mrz
			dz2 = nz(2) - mrz	!dom(ib)%zc(kd+0) - mrz
			!
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			!
            call LUDCMP(am3,4,p2,D,CODE)
            !
			if(fieldFlag.eq.1)then ! field flag check ! saving matrices in memory
			!
			dom(ib)%a3blsu(ii,jj,kk,1:4,1:4) = am3
			dom(ib)%a2blsu(ii,jj,kk,1:4,1:4) = am2
			dom(ib)%p2blsu(ii,jj,kk,1:4) = p2
			!
			!
			elseif(fieldFlag.eq.2)then
			!
			dom(ib)%a3blsv(ii,jj,kk,1:4,1:4) = am3
			dom(ib)%a2blsv(ii,jj,kk,1:4,1:4) = am2
			dom(ib)%p2blsv(ii,jj,kk,1:4) = p2
			!
			!
			elseif(fieldFlag.eq.3)then
			!
			dom(ib)%a3blsw(ii,jj,kk,1:4,1:4) = am3
			dom(ib)%a2blsw(ii,jj,kk,1:4,1:4) = am2
			dom(ib)%p2blsw(ii,jj,kk,1:4) = p2
			!
			!
			elseif(fieldFlag.eq.4)then
			!
			dom(ib)%a3blsp(ii,jj,kk,1:4,1:4) = am3
			dom(ib)%a2blsp(ii,jj,kk,1:4,1:4) = am2
			dom(ib)%p2blsp(ii,jj,kk,1:4) = p2
			!
			!
			endif		! field flag check
			!
			else
			!
			if(fieldFlag.eq.1)then ! field flag check ! retrieving matrices from memory
			!
			am3 = dom(ib)%a3blsu(ii,jj,kk,1:4,1:4)
			am2 = dom(ib)%a2blsu(ii,jj,kk,1:4,1:4)
			p2 = dom(ib)%p2blsu(ii,jj,kk,1:4)
			!
			!
			elseif(fieldFlag.eq.2)then
			!
			am3 = dom(ib)%a3blsv(ii,jj,kk,1:4,1:4)
			am2 = dom(ib)%a2blsv(ii,jj,kk,1:4,1:4)
			p2 = dom(ib)%p2blsv(ii,jj,kk,1:4)
			!
			!
			elseif(fieldFlag.eq.3)then
			!
			am3 = dom(ib)%a3blsw(ii,jj,kk,1:4,1:4)
			am2 = dom(ib)%a2blsw(ii,jj,kk,1:4,1:4)
			p2 = dom(ib)%p2blsw(ii,jj,kk,1:4)
			!
			!
			elseif(fieldFlag.eq.4)then
			!
			am3 = dom(ib)%a3blsp(ii,jj,kk,1:4,1:4)
			am2 = dom(ib)%a2blsp(ii,jj,kk,1:4,1:4)
			p2 = dom(ib)%p2blsp(ii,jj,kk,1:4)
			!
			!
			endif		! field flag check
			!
			! lets update the rhs vector
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			!
			endif 		! initialization check 
			!
    		call LUBKSB(am3,4,p2,bm2)
    		sol = bm2
    		!write(6,*) sol
			!
			! debug
			!if(nn.eq.70)then
			!print*,"===================== b2"
			!print*,b2
			!print*,"===================== a1"
			!print*,a1
			!print*,"===================== a3"
			!print*,a3
			!print*,"===================== sol"
			!print*,sol
			!endif
			!
			bl_lu = sol(1)	!sol = [ phi, dphi/dx, dphi/dz, d2phi/dxdz ]
			!
			!######################################################################
			END FUNCTION bl_lu
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  

			!if(nn.eq.1130) then
			! debug
			!write(*,*) nn
			!write(*,*) nx
			!write(*,*) nz
			!write(*,*) pvec
			!write(*,*) mrx,mrz
			!endif
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)	!sol = [ phi, dphi/dx, dphi/dz ]
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramerv2(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
				
			! Least Squares Model using Cramer's solver
			implicit none
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(4), nz(4),uvec(16)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			!DOUBLE PRECISION, INTENT(OUT):: sol(4)
			DOUBLE PRECISION:: sol(4)
			
			DOUBLE PRECISION:: x1, x2, x3, x4, z1, z2,z3, z4
			DOUBLE PRECISION:: q11, q21, q31, q41
			DOUBLE PRECISION:: q12, q22, q32, q42
			DOUBLE PRECISION:: q13, q23, q33, q43
			DOUBLE PRECISION:: q14, q24, q34, q44
			DOUBLE PRECISION:: dx1, dx2, dx3, dx4 
			DOUBLE PRECISION:: dz1, dz2, dz3, dz4
			DOUBLE PRECISION:: a1(4,16), a2(16,4), a3(4,4)
			DOUBLE PRECISION:: b1(16), b2(4)
			!
			!
			q11 = uvec(1)  !dom(ib)%u(id-2,jjc,kd-2)
			q21 = uvec(2)  !dom(ib)%u(id-1,jjc,kd-2)
			q31 = uvec(3)  !dom(ib)%u(id  ,jjc,kd-2)
			q41 = uvec(4)  !dom(ib)%u(id+1,jjc,kd-2)
			!
			q12 = uvec(5)  !dom(ib)%u(id-2,jjc,kd-1)
			q22 = uvec(6)  !dom(ib)%u(id-1,jjc,kd-1)
			q32 = uvec(7)  !dom(ib)%u(id  ,jjc,kd-1)
			q42 = uvec(8)  !dom(ib)%u(id+1,jjc,kd-1)
			!
			q13 = uvec(9)  !dom(ib)%u(id-2,jjc,kd)
			q23 = uvec(10) !dom(ib)%u(id-1,jjc,kd)
			q33 = uvec(11) !dom(ib)%u(id  ,jjc,kd)
			q43 = uvec(12) !dom(ib)%u(id+1,jjc,kd)
			!
			q14 = uvec(13) !dom(ib)%u(id-2,jjc,kd+1)
			q24 = uvec(14) !dom(ib)%u(id-1,jjc,kd+1)
			q34 = uvec(15) !dom(ib)%u(id  ,jjc,kd+1)
			q44 = uvec(16) !dom(ib)%u(id+1,jjc,kd+1)
			!
			x1 = nx(1)	!dom(ib)%x(id-2)
			x2 = nx(2)	!dom(ib)%x(id-1)
			x3 = nx(3)	!dom(ib)%x(id)
			x4 = nx(4)	!dom(ib)%x(id+1)
			!
			z1 = nz(1)	!dom(ib)%z(id-2)
			z2 = nz(2)	!dom(ib)%z(id-1)
			z3 = nz(3)	!dom(ib)%z(id)
			z4 = nz(4)	!dom(ib)%z(id+1)
			!
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dx3 = x3 - mrx
			dx4 = x4 - mrx
			!
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			dz3 = z3 - mrz
			dz4 = z4 - mrz
			!
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dz1
			!
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dz1
			!
			a1(1,3) = 1; a1(2,3) = dx3; a1(3,3) = dz1
			a1(4,3) = dx3*dz1
			!
			a1(1,4) = 1; a1(2,4) = dx4; a1(3,4) = dz1
			a1(4,4) = dx4*dz1
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a1(1,5) = 1; a1(2,5) = dx1; a1(3,5) = dz2
			a1(4,5) = dx1*dz2
			!
			a1(1,6) = 1; a1(2,6) = dx2; a1(3,6) = dz2
			a1(4,6) = dx2*dz2
			!
			a1(1,7) = 1; a1(2,7) = dx3; a1(3,7) = dz2
			a1(4,7) = dx3*dz2
			!
			a1(1,8) = 1; a1(2,8) = dx4; a1(3,8) = dz2
			a1(4,8) = dx4*dz2
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a1(1,9) = 1; a1(2,9) = dx1; a1(3,9) = dz3
			a1(4,9) = dx1*dz3
			!
			a1(1,10) = 1; a1(2,10) = dx2; a1(3,10) = dz3
			a1(4,10) = dx2*dz3
			!
			a1(1,11) = 1; a1(2,11) = dx3; a1(3,11) = dz3
			a1(4,11) = dx3*dz3
			!
			a1(1,12) = 1; a1(2,12) = dx4; a1(3,12) = dz3
			a1(4,12) = dx4*dz3
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a1(1,13) = 1; a1(2,13) = dx1; a1(3,13) = dz4
			a1(4,13) = dx1*dz4
			!
			a1(1,14) = 1; a1(2,14) = dx2; a1(3,14) = dz4
			a1(4,14) = dx2*dz4
			!
			a1(1,15) = 1; a1(2,15) = dx3; a1(3,15) = dz4
			a1(4,15) = dx3*dz4
			!
			a1(1,16) = 1; a1(2,16) = dx4; a1(3,16) = dz4
			a1(4,16) = dx4*dz4
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a2 = TRANSPOSE(a1)
			b1(1) =q11; b1(2) =q21; b1(3) =q31; b1(4) =q41
			b1(5) =q12; b1(6) =q22; b1(7) =q32; b1(8) =q42
			b1(9) =q13; b1(10)=q23; b1(11)=q33; b1(12)=q43
			b1(13)=q14; b1(14)=q24; b1(15)=q34; b1(16)=q44
			!
			b2 = 0
			a3 = 0
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			!print*,"===================== b2"
			!print*,b2
			!print*,"===================== a1"
			!print*,a1
			!print*,"===================== a3"
			!print*,a3
			
			call cramer_solver(sol,a3,b2,4)
			bl_cramerv2 = sol(1)
			!######################################################################
			END FUNCTION  bl_cramerv2
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_LU(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			!
			! Second order Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: q11, q21, q31, q41
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			INTEGER:: D, CODE, p2(6)
			!
			!
			q11 = uvec(1)  !dom(ib)%u(id-2,jjc,kd-1)
			q21 = uvec(2)  !dom(ib)%u(id-1,jjc,kd-1)
			q31 = uvec(3)  !dom(ib)%u(id  ,jjc,kd+0)
			q41 = uvec(4)  !dom(ib)%u(id+1,jjc,kd+0)
			!
			dx1 = nx(1) - mrx   !nx(1) - mrx
			dx2 = nx(2) - mrx   !nx(2) - mrx   !!!!!!!!!!!!!
			dz1 = nz(1) - mrz   !nz(1) - mrz
			dz2 = nz(2) - mrz   !nz(2) - mrz
			!
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = 0.5*dx1*dx1; a1(5,1) = 0.5*dz1*dz1
			a1(6,1) = dx1*dz1
			!
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = 0.5*dx2*dx2; a1(5,2) = 0.5*dz1*dz1 
			a1(6,2) = dx2*dz1
			!
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = 0.5*dx1*dx1; a1(5,3) = 0.5*dz2*dz2
			a1(6,3) = dx1*dz2
			!
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = 0.5*dx2*dx2; a1(5,4) = 0.5*dz2*dz2
			a1(6,4) = dx2*dz2
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a2 = TRANSPOSE(a1)
			b1(1) =q11; b1(2) =q21
			b1(3) =q31; b1(4) =q41
			!
			b2 = 0
			a3 = 0
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			!
			!call cramer_solver(sol,a3,b2,6)
    		call LUDCMP(a3,6,p2,D,CODE)
    		call LUBKSB(a3,6,p2,b2)
    		sol = b2
    		!write(6,*) sol
			!			
			ls_2ndOrder_LU = sol(1)
			!
			! debug
			!if(nn.eq.70)then
			!print*,"===================== b2"
			!print*,b2
			!print*,"===================== a1"
			!print*,a1
			!print*,"===================== a3"
			!print*,a3
			!print*,"===================== sol"
			!print*,sol
			!endif
			!
			!######################################################################
			END FUNCTION ls_2ndOrder_LU
			!######################################################################



			!######################################################################
		DOUBLE PRECISION FUNCTION ls_2ndOrder_LU_lite(infoVec,nx,
     &	nz,uvec,mrx,mrz)
			!######################################################################
			
			! Second order Least Squares Model using Cramer's b2ver
			
			
			implicit none
			
			INTEGER, INTENT(IN):: infoVec(8)
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: mrxb,mrzb
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: q11, q21, q31, q41
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), pv
			INTEGER:: D, CODE, p2(6)
			INTEGER:: nn,ib,ll,ii,jj,kk,flag1,fieldFlag
			!
			!
			nn = infoVec(1) ! nn	! Node nds(1.5)
			ib = infoVec(2) ! ib 
			ll = infoVec(3) ! ll
			ii = infoVec(4) ! id 
			jj = infoVec(5) ! jjj
			kk = infoVec(6) ! kd
			flag1 = infoVec(7) ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
			fieldFlag = infoVec(8) ! 1 ! fieldFlag for selecting u velocity
			!gcumx = vec3(1) !mrx
			!gcumy = vec3(2) !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			!gcumz = vec3(3) !mrz
			!
			!
			q11 = uvec(1)  !dom(ib)%u(id-2,jjc,kd-1)
			q21 = uvec(2)  !dom(ib)%u(id-1,jjc,kd-1)
			q31 = uvec(3)  !dom(ib)%u(id  ,jjc,kd+0)
			q41 = uvec(4)  !dom(ib)%u(id+1,jjc,kd+0)
			!
			!
			!
			!
            !dx1 = -1 + (1-(-1))*(nx(1) - mrx)/(nx(2) - nx(1)) !dom(ib)%dx   !nx(1) - mrx
            !dx2 = -1 + (1-(-1))*(nx(2) - mrx)/(nx(2) - nx(1)) !dom(ib)%dx   !nx(2) - mrx   !!!!!!!!!!!!!
            !dz1 = -1 + (1-(-1))*(nz(1) - mrz)/(nz(2) - nz(1)) !dom(ib)%dz   !nz(1) - mrz
            !dz2 = -1 + (1-(-1))*(nz(2) - mrz)/(nz(2) - nz(1)) !dom(ib)%dz   !nz(2) - mrz
			!
            dx1 = (nx(1) - mrx)!/dom(ib)%dx   !nx(1) - mrx
            dx2 = (nx(2) - mrx)!/dom(ib)%dx   !nx(2) - mrx   !!!!!!!!!!!!!
            dz1 = (nz(1) - mrz)!/dom(ib)%dz   !nz(1) - mrz
            dz2 = (nz(2) - mrz)!/dom(ib)%dz   !nz(2) - mrz
			!
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = 0.5*dx1*dx1; a1(5,1) = 0.5*dz1*dz1
			a1(6,1) = dx1*dz1
			!
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = 0.5*dx2*dx2; a1(5,2) = 0.5*dz1*dz1 
			a1(6,2) = dx2*dz1
			!
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = 0.5*dx1*dx1; a1(5,3) = 0.5*dz2*dz2
			a1(6,3) = dx1*dz2
			!
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = 0.5*dx2*dx2; a1(5,4) = 0.5*dz2*dz2
			a1(6,4) = dx2*dz2
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a2 = TRANSPOSE(a1)
			!
			a3 = 0.0d00
			a3 = matmul(a1,a2)
			!
			!call cramer_b2ver(b2,a3,b2,6)
    		call LUDCMP(a3,6,p2,D,CODE)
			if(nn.eq.70)then
			print*,"===================== p2"
			print*,p2
			!print*,"===================== a1"
			!print*,a1
			print*,"===================== a3"
			print*,a3
			!print*,"===================== b2"
			!print*,b2
			endif
			!
			if(itime.le.itime_start+1) then ! initialization check 
			!
			!
			!
			!
			if(fieldFlag.eq.1)then ! field flag check ! saving matrices in memory
			!
			!dom(ib)%aqlsu(ii,jj,kk,1:6,1:6) = a3
			dom(ib)%a2qlsu(ii,jj,kk,1:4,1:6) = a2
			!dom(ib)%pqlsu(ii,jj,kk,1:6) = p2
			!
			!
			elseif(fieldFlag.eq.2)then
			!
			!dom(ib)%aqlsv(ii,jj,kk,1:6,1:6) = a3
			dom(ib)%a2qlsv(ii,jj,kk,1:4,1:6) = a2
			!dom(ib)%pqlsv(ii,jj,kk,1:6) = p2
			!
			!
			elseif(fieldFlag.eq.3)then
			!
			!dom(ib)%aqlsw(ii,jj,kk,1:6,1:6) = a3
			dom(ib)%a2qlsw(ii,jj,kk,1:4,1:6) = a2
			!dom(ib)%pqlsw(ii,jj,kk,1:6) = p2
			!
			!
			elseif(fieldFlag.eq.4)then
			!
			!dom(ib)%aqlsp(ii,jj,kk,1:6,1:6) = a3
			dom(ib)%a2qlsp(ii,jj,kk,1:4,1:6) = a2
			!dom(ib)%pqlsp(ii,jj,kk,1:6) = p2
			!
			!
			endif		! field flag check
			!
			else
			!
			if(fieldFlag.eq.1)then ! field flag check ! retrieving matrices from memory
			!
			!a3 = dom(ib)%aqlsu(ii,jj,kk,1:6,1:6)
			a2 = dom(ib)%a2qlsu(ii,jj,kk,1:4,1:6)
			!p2 = dom(ib)%pqlsu(ii,jj,kk,1:6)
			!
			!
			elseif(fieldFlag.eq.2)then
			!
			!a3 = dom(ib)%aqlsv(ii,jj,kk,1:6,1:6)
			a2 = dom(ib)%a2qlsv(ii,jj,kk,1:4,1:6)
			!p2 = dom(ib)%pqlsv(ii,jj,kk,1:6)
			!
			!
			elseif(fieldFlag.eq.3)then
			!
			!a3 = dom(ib)%aqlsw(ii,jj,kk,1:6,1:6)
			a2 = dom(ib)%a2qlsw(ii,jj,kk,1:4,1:6)
			!p2 = dom(ib)%pqlsw(ii,jj,kk,1:6)
			!
			!
			elseif(fieldFlag.eq.4)then
			!
			!a3 = dom(ib)%aqlsp(ii,jj,kk,1:6,1:6)
			a2 = dom(ib)%a2qlsp(ii,jj,kk,1:4,1:6)
			!p2 = dom(ib)%pqlsp(ii,jj,kk,1:6)
			!
			!
			endif		! field flag check
			!
			!
			endif 		! initialization check 
			!
			!
			b1(1) =q11; b1(2) =q21
			b1(3) =q31; b1(4) =q41
			b2 = 0.0d00
			b2 = matmul(b1,a2)
			!
			!
    		call LUBKSB(a3,6,p2,b2)
			!
            pv = b2(1)
			ls_2ndOrder_LU_lite = pv
			!
			! debug
			!if(nn.eq.70)then
			!print*,"===================== b2"
			!print*,b2
			!print*,"===================== a1"
			!print*,a1
			!print*,"===================== a3"
			!print*,a3
			!print*,"===================== b2"
			!print*,b2
			!endif
			!
			!######################################################################
			END FUNCTION ls_2ndOrder_LU_lite
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION ls_tseng_LU(infoVec,nx,
     &	nz,uvec,mrx,mrz)
			!######################################################################
			
			! Second order Least Squares Model using Cramer's b2ver
			
			
			implicit none
			
			INTEGER, INTENT(IN):: infoVec(8)
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: mrxb,mrzb
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: q11, q21, q31, q41
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), pv
			INTEGER:: D, CODE, p2(6)
			INTEGER:: nn,ib,ll,ii,jj,kk,flag1,fieldFlag
			!
			!
			nn = infoVec(1) ! nn	! Node nds(1.5)
			ib = infoVec(2) ! ib 
			ll = infoVec(3) ! ll
			ii = infoVec(4) ! id 
			jj = infoVec(5) ! jjj
			kk = infoVec(6) ! kd
			flag1 = infoVec(7) ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
			fieldFlag = infoVec(8) ! 1 ! fieldFlag for selecting u velocity
			!gcumx = vec3(1) !mrx
			!gcumy = vec3(2) !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			!gcumz = vec3(3) !mrz
			!
			!
			q11 = uvec(1)  !dom(ib)%u(id-2,jjc,kd-1)
			q21 = uvec(2)  !dom(ib)%u(id-1,jjc,kd-1)
			q31 = uvec(3)  !dom(ib)%u(id  ,jjc,kd+0)
			q41 = uvec(4)  !dom(ib)%u(id+1,jjc,kd+0)
			!
			!
			if(itime.le.itime_start+1) then ! initialization check 
			!
			!
            !dx1 = (nx(1) - mrx)/dom(ib)%dx   !nx(1) - mrx
            !dx2 = (nx(2) - mrx)/dom(ib)%dx   !nx(2) - mrx   !!!!!!!!!!!!!
            !dz1 = (nz(1) - mrz)/dom(ib)%dz   !nz(1) - mrz
            !dz2 = (nz(2) - mrz)/dom(ib)%dz   !nz(2) - mrz
			dx1 = nx(1)
			dx2 = nx(2)   !!!!!!!!!!!!!
			dz1 = nz(1)
			dz2 = nz(2)
			!
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = 0.5*dx1*dx1; a1(5,1) = 0.5*dz1*dz1
			a1(6,1) = dx1*dz1
			!
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = 0.5*dx2*dx2; a1(5,2) = 0.5*dz1*dz1 
			a1(6,2) = dx2*dz1
			!
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = 0.5*dx1*dx1; a1(5,3) = 0.5*dz2*dz2
			a1(6,3) = dx1*dz2
			!
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = 0.5*dx2*dx2; a1(5,4) = 0.5*dz2*dz2
			a1(6,4) = dx2*dz2
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a2 = TRANSPOSE(a1)
			a3 = 0
			a3 = matmul(a1,a2)
			!
			!call cramer_b2ver(b2,a3,b2,6)
    		call LUDCMP(a3,6,p2,D,CODE)
			!
			if(fieldFlag.eq.1)then ! field flag check ! saving matrices in memory
			!
			dom(ib)%a3tsengu(ii,jj,kk,1:6,1:6) = a3
			dom(ib)%a2tsengu(ii,jj,kk,1:4,1:6) = a2
			dom(ib)%p2tsengu(ii,jj,kk,1:6) = p2
			!
			!
			elseif(fieldFlag.eq.2)then
			!
			dom(ib)%a3tsengv(ii,jj,kk,1:6,1:6) = a3
			dom(ib)%a2tsengv(ii,jj,kk,1:4,1:6) = a2
			dom(ib)%p2tsengv(ii,jj,kk,1:6) = p2
			!
			!
			elseif(fieldFlag.eq.3)then
			!
			dom(ib)%a3tsengw(ii,jj,kk,1:6,1:6) = a3
			dom(ib)%a2tsengw(ii,jj,kk,1:4,1:6) = a2
			dom(ib)%p2tsengw(ii,jj,kk,1:6) = p2
			!
			!
			elseif(fieldFlag.eq.4)then
			!
			dom(ib)%a3tsengp(ii,jj,kk,1:6,1:6) = a3
			dom(ib)%a2tsengp(ii,jj,kk,1:4,1:6) = a2
			dom(ib)%p2tsengp(ii,jj,kk,1:6) = p2
			!
			!
			endif		! field flag check
			!
			else
			!
			if(fieldFlag.eq.1)then ! field flag check ! retrieving matrices from memory
			!
			a3 = dom(ib)%a3tsengu(ii,jj,kk,1:6,1:6)
			a2 = dom(ib)%a2tsengu(ii,jj,kk,1:4,1:6)
			p2 = dom(ib)%p2tsengu(ii,jj,kk,1:6)
			!
			!
			elseif(fieldFlag.eq.2)then
			!
			a3 = dom(ib)%a3tsengv(ii,jj,kk,1:6,1:6)
			a2 = dom(ib)%a2tsengv(ii,jj,kk,1:4,1:6)
			p2 = dom(ib)%p2tsengv(ii,jj,kk,1:6)
			!
			!
			elseif(fieldFlag.eq.3)then
			!
			a3 = dom(ib)%a3tsengw(ii,jj,kk,1:6,1:6)
			a2 = dom(ib)%a2tsengw(ii,jj,kk,1:4,1:6)
			p2 = dom(ib)%p2tsengw(ii,jj,kk,1:6)
			!
			!
			elseif(fieldFlag.eq.4)then
			!
			a3 = dom(ib)%a3tsengp(ii,jj,kk,1:6,1:6)
			a2 = dom(ib)%a2tsengp(ii,jj,kk,1:4,1:6)
			p2 = dom(ib)%p2tsengp(ii,jj,kk,1:6)
			!
			!
			endif		! field flag check
			!
			!
			endif 		! initialization check 
			!
			!
			b1(1) =q11; b1(2) =q21
			b1(3) =q31; b1(4) =q41
			!
			b2 = 0
			b2 = matmul(b1,a2)
			!
			!
    		call LUBKSB(a3,6,p2,b2)
			!
            pv = 0.0d00
            pv = pv + b2(1)
            pv = pv + b2(2)*mrx
            pv = pv + b2(3)*mrz
            pv = pv + 0.5*b2(4)*mrx**2
            pv = pv + 0.5*b2(5)*mrz**2
            pv = pv + b2(6)*mrx*mrz			
			ls_tseng_LU = pv
			!
			! debug
			!if(nn.eq.70)then
			!print*,"===================== b2"
			!print*,b2
			!print*,"===================== a1"
			!print*,a1
			!print*,"===================== a3"
			!print*,a3
			!print*,"===================== b2"
			!print*,b2
			!endif
			!
			!######################################################################
			END FUNCTION ls_tseng_LU
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION ls_tseng_LU_scaled(infoVec,nx,
     &	nz,uvec,mrx,mrz)
			!######################################################################
			
			! Second order Least Squares Model using Cramer's b2ver
			
			
			implicit none
			
			INTEGER, INTENT(IN):: infoVec(8)
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: mrxb,mrzb
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: q11, q21, q31, q41
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), pv
			INTEGER:: D, CODE, p2(6)
			INTEGER:: nn,ib,ll,ii,jj,kk,flag1,fieldFlag
			DOUBLE PRECISION:: etax,etaz
			!
			!
			nn = infoVec(1) ! nn	! Node nds(1.5)
			ib = infoVec(2) ! ib 
			ll = infoVec(3) ! ll
			ii = infoVec(4) ! id 
			jj = infoVec(5) ! jjj
			kk = infoVec(6) ! kd
			flag1 = infoVec(7) ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
			fieldFlag = infoVec(8) ! 1 ! fieldFlag for selecting u velocity
			!gcumx = vec3(1) !mrx
			!gcumy = vec3(2) !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			!gcumz = vec3(3) !mrz
			!
			!
			q11 = uvec(1)  !dom(ib)%u(id-2,jjc,kd-1)
			q21 = uvec(2)  !dom(ib)%u(id-1,jjc,kd-1)
			q31 = uvec(3)  !dom(ib)%u(id  ,jjc,kd+0)
			q41 = uvec(4)  !dom(ib)%u(id+1,jjc,kd+0)
			!
			!
            !dx1 = (nx(1) - mrx)/dom(ib)%dx   !nx(1) - mrx
            !dx2 = (nx(2) - mrx)/dom(ib)%dx   !nx(2) - mrx   !!!!!!!!!!!!!
            !dz1 = (nz(1) - mrz)/dom(ib)%dz   !nz(1) - mrz
            !dz2 = (nz(2) - mrz)/dom(ib)%dz   !nz(2) - mrz
			!
			!dx1 = (nx(1) - dom(ib)%xc(ii-4))/dom(ib)%dx
			!dx2 = (nx(2) - dom(ib)%xc(ii-4))/dom(ib)%dx
			!dz1 = (nz(1) - dom(ib)%zc(kk-4))/dom(ib)%dz
			!dz2 = (nz(2) - dom(ib)%zc(kk-4))/dom(ib)%dz
			!
			dx1 = (nx(1) - 18.0D00)/dom(ib)%dx
			dx2 = (nx(2) - 18.0D00)/dom(ib)%dx
			dz1 = (nz(1) - 9.60D00)/dom(ib)%dz
			dz2 = (nz(2) - 9.60D00)/dom(ib)%dz
			!
			!
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = 0.5*dx1*dx1; a1(5,1) = 0.5*dz1*dz1
			a1(6,1) = dx1*dz1
			!
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = 0.5*dx2*dx2; a1(5,2) = 0.5*dz1*dz1 
			a1(6,2) = dx2*dz1
			!
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = 0.5*dx1*dx1; a1(5,3) = 0.5*dz2*dz2
			a1(6,3) = dx1*dz2
			!
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = 0.5*dx2*dx2; a1(5,4) = 0.5*dz2*dz2
			a1(6,4) = dx2*dz2
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a2 = TRANSPOSE(a1)
			b1(1) =q11; b1(2) =q21
			b1(3) =q31; b1(4) =q41
			!
			b2 = 0
			a3 = 0
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			!
			!call cramer_b2ver(b2,a3,b2,6)
    		call LUDCMP(a3,6,p2,D,CODE)
			!
    		call LUBKSB(a3,6,p2,b2)
			!
			!etax = (mrx - dom(ib)%xc(ii-4))/dom(ib)%dx
			!etaz = (mrz - dom(ib)%zc(kk-4))/dom(ib)%dz
			etax = (mrx - 18.00d00)/dom(ib)%dx
			etaz = (mrz - 9.60d00)/dom(ib)%dz
			!aaaaa
            pv = 0.0d00
            pv = pv + b2(1)
            pv = pv + b2(2)*etax
            pv = pv + b2(3)*etaz
            pv = pv + 0.5*b2(4)*etax**2
            pv = pv + 0.5*b2(5)*etaz**2
            pv = pv + b2(6)*etax*etaz			
			ls_tseng_LU_scaled = pv
			!
			! debug
			!if(nn.eq.70)then
			!print*,"===================== b2"
			!print*,b2
			!print*,"===================== a1"
			!print*,a1
			!print*,"===================== a3"
			!print*,a3
			!print*,"===================== b2"
			!print*,b2
			!endif
			!
			!######################################################################
			END FUNCTION ls_tseng_LU_scaled
			!######################################################################

			!######################################################################
!		DOUBLE PRECISION SUBROUTINE ls_2ndOrder_cramerV2(infoVec,nx,nz,pvec,mrx,mrz)
	DOUBLE PRECISION FUNCTION ls_2ndOrder_cramerV2(infoVec,nx,
     & 		nz,pvec,mrx,mrz)
			!######################################################################
			! Least Squares Model using Cramer's solver
			implicit none
			INTEGER, INTENT(IN)::infoVec(8)
			DOUBLE PRECISION, INTENT(IN):: nx(4), nz(4),pvec(16)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: x1, x2, x3, x4, z1, z2,z3, z4
			DOUBLE PRECISION:: q11, q21, q31, q41
			DOUBLE PRECISION:: q12, q22, q32, q42
			DOUBLE PRECISION:: q13, q23, q33, q43
			DOUBLE PRECISION:: q14, q24, q34, q44
			DOUBLE PRECISION:: dx1, dx2, dx3, dx4 
			DOUBLE PRECISION:: dz1, dz2, dz3, dz4
			DOUBLE PRECISION:: a1(6,16), a2(16,6), a3(6,6)
			DOUBLE PRECISION:: b1(16), b2(6), sol(6)
			!
			DOUBLE PRECISION::da,da3,auxm(5,5),ainv(6,6),asp(16,6)
			INTEGER:: nn,ib,ll,ii,jj,kk,flag1,fieldFlag
			!
			!
			nn = infoVec(1) ! nn	! Node nds(1.5)
			ib = infoVec(2) ! ib 
			ll = infoVec(3) ! ll
			ii = infoVec(4) ! id 
			jj = infoVec(5) ! jjj
			kk = infoVec(6) ! kd
			flag1 = infoVec(7) ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
			fieldFlag = vec2(8) ! 1 ! fieldFlag for selecting u velocity
			!gcumx = vec3(1) !mrx
			!gcumy = vec3(2) !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			!gcumz = vec3(3) !mrz
			!
			!
			q11 = pvec(1)  !dom(ib)%u(id-2,jjc,kd-2)
			q21 = pvec(2)  !dom(ib)%u(id-1,jjc,kd-2)
			q31 = pvec(3)  !dom(ib)%u(id  ,jjc,kd-2)
			q41 = pvec(4)  !dom(ib)%u(id+1,jjc,kd-2)
			!
			q12 = pvec(5)  !dom(ib)%u(id-2,jjc,kd-1)
			q22 = pvec(6)  !dom(ib)%u(id-1,jjc,kd-1)
			q32 = pvec(7)  !dom(ib)%u(id  ,jjc,kd-1)
			q42 = pvec(8)  !dom(ib)%u(id+1,jjc,kd-1)
			!
			q13 = pvec(9)  !dom(ib)%u(id-2,jjc,kd)
			q23 = pvec(10) !dom(ib)%u(id-1,jjc,kd)
			q33 = pvec(11) !dom(ib)%u(id  ,jjc,kd)
			q43 = pvec(12) !dom(ib)%u(id+1,jjc,kd)
			!
			q14 = pvec(13) !dom(ib)%u(id-2,jjc,kd+1)
			q24 = pvec(14) !dom(ib)%u(id-1,jjc,kd+1)
			q34 = pvec(15) !dom(ib)%u(id  ,jjc,kd+1)
			q44 = pvec(16) !dom(ib)%u(id+1,jjc,kd+1)
			!
			!
			b1(1) =q11; b1(2) =q21; b1(3) =q31; b1(4) =q41
			b1(5) =q12; b1(6) =q22; b1(7) =q32; b1(8) =q42
			b1(9) =q13; b1(10)=q23; b1(11)=q33; b1(12)=q43
			b1(13)=q14; b1(14)=q24; b1(15)=q34; b1(16)=q44
			!
			!
			if(itime.le.itime_start+1) then ! initialization check 
			x1 = nx(1)	!dom(ib)%x(id-2)
			x2 = nx(2)	!dom(ib)%x(id-1)
			x3 = nx(3)	!dom(ib)%x(id)
			x4 = nx(4)	!dom(ib)%x(id+1)
			!
			z1 = nz(1)	!dom(ib)%z(id-2)
			z2 = nz(2)	!dom(ib)%z(id-1)
			z3 = nz(3)	!dom(ib)%z(id)
			z4 = nz(4)	!dom(ib)%z(id+1)
			!
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dx3 = x3 - mrx
			dx4 = x4 - mrx
			!
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			dz3 = z3 - mrz
			dz4 = z4 - mrz
			!
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = 0.5*dx1*dx1; a1(5,1) = 0.5*dz1*dz1; a1(6,1) = dx1*dz1
			!
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = 0.5*dx2*dx2; a1(5,2) = 0.5*dz1*dz1; a1(6,2) = dx2*dz1
			!
			a1(1,3) = 1; a1(2,3) = dx3; a1(3,3) = dz1
			a1(4,3) = 0.5*dx3*dx3; a1(5,3) = 0.5*dz1*dz1; a1(6,3) = dx3*dz1
			!
			a1(1,4) = 1; a1(2,4) = dx4; a1(3,4) = dz1
			a1(4,4) = 0.5*dx4*dx4; a1(5,4) = 0.5*dz1*dz1; a1(6,4) = dx4*dz1
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a1(1,5) = 1; a1(2,5) = dx1; a1(3,5) = dz2
			a1(4,5) = 0.5*dx1*dx1; a1(5,5) = 0.5*dz2*dz2; a1(6,5) = dx1*dz2
			!
			a1(1,6) = 1; a1(2,6) = dx2; a1(3,6) = dz2
			a1(4,6) = 0.5*dx2*dx2; a1(5,6) = 0.5*dz2*dz2; a1(6,6) = dx2*dz2
			!
			a1(1,7) = 1; a1(2,7) = dx3; a1(3,7) = dz2
			a1(4,7) = 0.5*dx3*dx3; a1(5,7) = 0.5*dz2*dz2; a1(6,7) = dx3*dz2
			!
			a1(1,8) = 1; a1(2,8) = dx4; a1(3,8) = dz2
			a1(4,8) = 0.5*dx4*dx4; a1(5,8) = 0.5*dz2*dz2; a1(6,8) = dx4*dz2
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a1(1,9) = 1; a1(2,9) = dx1; a1(3,9) = dz3
			a1(4,9) = 0.5*dx1*dx1; a1(5,9) = 0.5*dz3*dz3; a1(6,9) = dx1*dz3
			!
			a1(1,10) = 1; a1(2,10) = dx2; a1(3,10) = dz3
			a1(4,10) = 0.5*dx2*dx2; a1(5,10) = 0.5*dz3*dz3; a1(6,10) = dx2*dz3
			!
			a1(1,11) = 1; a1(2,11) = dx3; a1(3,11) = dz3
			a1(4,11) = 0.5*dx3*dx3; a1(5,11) = 0.5*dz3*dz3; a1(6,11) = dx3*dz3
			!
			a1(1,12) = 1; a1(2,12) = dx4; a1(3,12) = dz3
			a1(4,12) = 0.5*dx4*dx4; a1(5,12) = 0.5*dz3*dz3; a1(6,12) = dx4*dz3
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a1(1,13) = 1; a1(2,13) = dx1; a1(3,13) = dz4
			a1(4,13) = 0.5*dx1*dx1; a1(5,13) = 0.5*dz4*dz4; a1(6,13) = dx1*dz4
			!
			a1(1,14) = 1; a1(2,14) = dx2; a1(3,14) = dz4
			a1(4,14) = 0.5*dx2*dx2; a1(5,14) = 0.5*dz4*dz4; a1(6,14) = dx2*dz4
			!
			a1(1,15) = 1; a1(2,15) = dx3; a1(3,15) = dz4
			a1(4,15) = 0.5*dx3*dx3; a1(5,15) = 0.5*dz4*dz4; a1(6,15) = dx3*dz4
			!
			a1(1,16) = 1; a1(2,16) = dx4; a1(3,16) = dz4
			a1(4,16) = 0.5*dx4*dx4; a1(5,16) = 0.5*dz4*dz4; a1(6,16) = dx4*dz4
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!
			!
			asp = TRANSPOSE(a1)
			!
			a3 = matmul(a1,asp)
			!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! lets find the inverse matrix
			da3 = detmf(a3,6)
			a3 = TRANSPOSE(a3)
			!
			! 1st row
			auxm = a3(2:6,2:6)
			ainv(1,1) = + detmf(auxm,5)
			!
			auxm(1,1:5)   = a3(1,2:6)
			auxm(2:5,1:5) = a3(3:6,2:6)
			ainv(2,1) = - detmf(auxm,5)
			!
			auxm(1:2,1:5)   = a3(1:2,2:6)
			auxm(3:5,1:5) = a3(4:6,2:6)
			ainv(3,1) = + detmf(auxm,5)
			!
			auxm(1:3,1:5)   = a3(1:3,2:6)
			auxm(4:5,1:5) = a3(5:6,2:6)
			ainv(4,1) = - detmf(auxm,5)
			!
			auxm(1:4,1:5)   = a3(1:4,2:6)
			auxm(5,1:5) = a3(6,2:6)
			ainv(5,1) = + detmf(auxm,5)
			!
			auxm(1:5,1:5)   = a3(1:5,2:6)
			ainv(6,1) = - detmf(auxm,5)
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! 2nd row
			auxm(1:5,1)   = a3(2:6,1)
			auxm(1:5,2:5) = a3(2:6,3:6)
			ainv(1,2) = - detmf(auxm,5)
			!
			auxm(1  ,1)     = a3(1,1)
			auxm(2:5,1)     = a3(3:6,1)
			auxm(1  ,2:5)   = a3(1,3:6)
			auxm(2:5,2:5)   = a3(3:6,3:6)
			ainv(2,2) = + detmf(auxm,5)
			!
			auxm(1:2,1)     = a3(1:2,1)
			auxm(3:5,1)     = a3(4:6,1)
			auxm(1:2,2:5)   = a3(1:2,3:6)
			auxm(3:5,2:5)   = a3(4:6,3:6)
			ainv(3,2) = - detmf(auxm,5)
			!
			auxm(1:3,1)     = a3(1:3,1)
			auxm(4:5,1)     = a3(5:6,1)
			auxm(1:3,2:5)   = a3(1:3,3:6)
			auxm(4:5,2:5)   = a3(5:6,3:6)
			ainv(4,2) = + detmf(auxm,5)
			!
			auxm(1:4,1)     = a3(1:4,1)
			auxm(  5,1)     = a3(  6,1)
			auxm(1:4,2:5)   = a3(1:4,3:6)
			auxm(  5,2:5)   = a3(  6,3:6)
			ainv(5,2) = - detmf(auxm,5)
			!
			auxm(1:5,1)     = a3(1:5,1)
			auxm(1:5,2:5)   = a3(1:5,3:6)
			ainv(6,2) = + detmf(auxm,5)
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! lets find the inverse matrix
			! 3rd row
			auxm(1:5,1:2)   = a3(2:6,1:2)
			auxm(1:5,3:5) = a3(2:6,4:6)
			ainv(1,3) = + detmf(auxm,5)
			!
			auxm(1  ,1:2)     = a3(1,1:2)
			auxm(2:5,1:2)     = a3(3:6,1:2)
			auxm(1  ,3:5)   = a3(1,4:6)
			auxm(2:5,3:5)   = a3(3:6,4:6)
			ainv(2,3) = - detmf(auxm,5)
			!
			auxm(1:2,1:2)     = a3(1:2,1:2)
			auxm(3:5,1:2)     = a3(4:6,1:2)
			auxm(1:2,3:5)   = a3(1:2,4:6)
			auxm(3:5,3:5)   = a3(4:6,4:6)
			ainv(3,3) = + detmf(auxm,5)
			!
			auxm(1:3,1:2)     = a3(1:3,1:2)
			auxm(4:5,1:2)     = a3(5:6,1:2)
			auxm(1:3,3:5)   = a3(1:3,4:6)
			auxm(4:5,3:5)   = a3(5:6,4:6)
			ainv(4,3) = - detmf(auxm,5)
			!
			auxm(1:4,1:2)     = a3(1:4,1:2)
			auxm(  5,1:2)     = a3(  6,1:2)
			auxm(1:4,3:5)   = a3(1:4,4:6)
			auxm(  5,3:5)   = a3(  6,4:6)
			ainv(5,3) = + detmf(auxm,5)
			!
			auxm(1:5,1:2)     = a3(1:5,1:2)
			auxm(1:5,3:5)   = a3(1:5,4:6)
			ainv(6,3) = - detmf(auxm,5)
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! lets find the inverse matrix
			! 4th row
			auxm(1:5,1:3)   = a3(2:6,1:3)
			auxm(1:5,4:5) = a3(2:6,5:6)
			ainv(1,4) = - detmf(auxm,5)
			!
			auxm(1  ,1:3)   = a3(1,1:3)
			auxm(2:5,1:3)   = a3(3:6,1:3)
			auxm(1  ,4:5)   = a3(1,5:6)
			auxm(2:5,4:5)   = a3(3:6,5:6)
			ainv(2,4) = + detmf(auxm,5)
			!
			auxm(1:2,1:3)   = a3(1:2,1:3)
			auxm(3:5,1:3)   = a3(4:6,1:3)
			auxm(1:2,4:5)   = a3(1:2,5:6)
			auxm(3:5,4:5)   = a3(4:6,5:6)
			ainv(3,4) = - detmf(auxm,5)
			!
			auxm(1:3,1:3)   = a3(1:3,1:3)
			auxm(4:5,1:3)   = a3(5:6,1:3)
			auxm(1:3,4:5)   = a3(1:3,5:6)
			auxm(4:5,4:5)   = a3(5:6,5:6)
			ainv(4,4) = + detmf(auxm,5)
			!
			auxm(1:4,1:3)   = a3(1:4,1:3)
			auxm(  5,1:3)   = a3(  6,1:3)
			auxm(1:4,4:5)   = a3(1:4,5:6)
			auxm(  5,4:5)   = a3(  6,5:6)
			ainv(5,4) = - detmf(auxm,5)
			!
			auxm(1:5,1:3)   = a3(1:5,1:3)
			auxm(1:5,4:5)   = a3(1:5,5:6)
			ainv(6,4) = + detmf(auxm,5)
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
			! 5th row
			auxm(1:5,1:4)   = a3(2:6,1:4)
			auxm(1:5,  5)   = a3(2:6,  6)
			ainv(1,5) = + detmf(auxm,5)
			!
			auxm(1  ,1:4)     = a3(1,1:4)
			auxm(2:5,1:4)     = a3(3:6,1:4)
			auxm(1  ,  5)     = a3(1,   6)
			auxm(2:5,  5)     = a3(3:6,   6)
			ainv(2,5) = - detmf(auxm,5)
			!
			auxm(1:2,1:4)     = a3(1:2,1:4)
			auxm(3:5,1:4)     = a3(4:6,1:4)
			auxm(1:2,  5)   = a3(1:2,   6)
			auxm(3:5,  5)   = a3(4:6,   6)
			ainv(3,5) = + detmf(auxm,5)
			!
			auxm(1:3,1:4)     = a3(1:3,1:4)
			auxm(4:5,1:4)     = a3(5:6,1:4)
			auxm(1:3,  5)   = a3(1:3,   6)
			auxm(4:5,  5)   = a3(5:6,   6)
			ainv(4,5) = - detmf(auxm,5)
			!
			auxm(1:4,1:4)     = a3(1:4,1:4)
			auxm(  5,1:4)     = a3(  6,1:4)
			auxm(1:4,  5)   = a3(1:4,   6)
			auxm(  5,  5)   = a3(  6,   6)
			ainv(5,5) = + detmf(auxm,5)
			!
			auxm(1:5,1:4)     = a3(1:5,1:4)
			auxm(1:5,  5)   = a3(1:5,   6)
			ainv(6,5) = - detmf(auxm,5)
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
			! 6th row
			auxm = a3(2:6,1:5)
			ainv(1,6) = - detmf(auxm,5)
			!
			auxm(1,1:5)   = a3(1,1:5)
			auxm(2:5,1:5) = a3(3:6,1:5)
			ainv(2,6) = + detmf(auxm,5)
			!
			auxm(1:2,1:5)   = a3(1:2,1:5)
			auxm(3:5,1:5) = a3(4:6,1:5)
			ainv(3,6) = - detmf(auxm,5)
			!
			auxm(1:3,1:5)   = a3(1:3,1:5)
			auxm(4:5,1:5) = a3(5:6,1:5)
			ainv(4,6) = + detmf(auxm,5)
			!
			auxm(1:4,1:5)   = a3(1:4,1:5)
			auxm(5,1:5) = a3(6,1:5)
			ainv(5,6) = - detmf(auxm,5)
			!
			auxm(1:5,1:5)   = a3(1:5,1:5)
			ainv(6,6) = + detmf(auxm,5)
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!
            !
			if(fieldFlag.eq.1)then ! field flag check
            !
			dom(ib)%da3u(ii,jj,kk) = da3
            dom(ib)%aspu(ii,jj,kk,1:16,1:6) = asp
            dom(ib)%ainvu(ii,jj,kk,1:6,1:6) = ainv
			if(nn.eq.70)then
			write(6,*) "asp matrix u qlsm initianlized"
			write(6,*) "Inverse matrix u qlsm initianlized"
			endif
            !
            !
			elseif(fieldFlag.eq.2)then
            !
			dom(ib)%da3v(ii,jj,kk) = da3
            dom(ib)%aspv(ii,jj,kk,1:16,1:6) = asp
            dom(ib)%ainvv(ii,jj,kk,1:6,1:6) = ainv
			if(nn.eq.70)then
			write(6,*) "asp matrix v qlsm initianlized"
			write(6,*) "Inverse matrix v qlsm initianlized"
			endif
            !
            !
			elseif(fieldFlag.eq.3)then
            !
			dom(ib)%da3w(ii,jj,kk) = da3
            dom(ib)%aspw(ii,jj,kk,1:16,1:6) = asp
            dom(ib)%ainvw(ii,jj,kk,1:6,1:6) = ainv
			if(nn.eq.70)then
			write(6,*) "asp matrix w qlsm initianlized"
			write(6,*) "Inverse matrix w qlsm initianlized"
			endif
            !
            !
			elseif(fieldFlag.eq.4)then
            !
			dom(ib)%da3p(ii,jj,kk) = da3
            dom(ib)%aspp(ii,jj,kk,1:16,1:6) = asp
            dom(ib)%ainvp(ii,jj,kk,1:6,1:6) = ainv
			if(nn.eq.70)then
			write(6,*) "asp matrix p qlsm initianlized"
			write(6,*) "Inverse matrix p qlsm initianlized"
			endif
            !
            !
            endif ! field flag check
			endif ! initialization check
			!
			b2 = 0
			if(fieldFlag.eq.1)then
			!
			da = dom(ib)%da3u(ii,jj,kk)
			b2 = matmul(b1,dom(ib)%aspu(ii,jj,kk,1:16,1:6))
			sol = matmul(b2,dom(ib)%ainvu(ii,jj,kk,1:6,1:6))/da
			!call cramer_solver(sol,a3,b2,6)	!sol = [ phi, dphi/dx, dphi/dz, d2phi/dx2, d2phi/dz2, d2phi/dxdz ]
			!
			!
			elseif(fieldFlag.eq.2)then
			!
			da = dom(ib)%da3v(ii,jj,kk)
			b2 = matmul(b1,dom(ib)%aspv(ii,jj,kk,1:16,1:6))
			sol = matmul(b2,dom(ib)%ainvv(ii,jj,kk,1:6,1:6))/da
			!call cramer_solver(sol,a3,b2,6)	!sol = [ phi, dphi/dx, dphi/dz, d2phi/dx2, d2phi/dz2, d2phi/dxdz ]
			!
			!
			elseif(fieldFlag.eq.3)then
			!
			da = dom(ib)%da3w(ii,jj,kk)
			b2 = matmul(b1,dom(ib)%aspw(ii,jj,kk,1:16,1:6))
			sol = matmul(b2,dom(ib)%ainvw(ii,jj,kk,1:6,1:6))/da
			!call cramer_solver(sol,a3,b2,6)	!sol = [ phi, dphi/dx, dphi/dz, d2phi/dx2, d2phi/dz2, d2phi/dxdz ]
			!
			!
			elseif(fieldFlag.eq.4)then
			!
			da = dom(ib)%da3p(ii,jj,kk)
			b2 = matmul(b1,dom(ib)%aspp(ii,jj,kk,1:16,1:6))
			sol = matmul(b2,dom(ib)%ainvp(ii,jj,kk,1:6,1:6))/da
			!call cramer_solver(sol,a3,b2,6)	!sol = [ phi, dphi/dx, dphi/dz, d2phi/dx2, d2phi/dz2, d2phi/dxdz ]
			!
			!
			endif ! field flag check
			!
			ls_2ndOrder_cramerV2 = sol(1)
			!
			!######################################################################
			END FUNCTION ls_2ndOrder_cramerV2
			!######################################################################

   !######################################################################
    	recursive DOUBLE PRECISION function detmf(
     &	matrix,n) result(det)
    !######################################################################
            ! function for calculating matrix determinants
            implicit none
            integer, intent(in):: n
            DOUBLE PRECISION, intent(in), dimension(n,n):: matrix
            DOUBLE PRECISION, dimension(n-1,n-1):: sl !  submatrix
            integer:: ii
            det = 0
            if (n == 1) then
                det = matrix(1,1)
                return
    
            else if(n == 2) then
                det = matrix(1,1)*matrix(2,2) - matrix(1,2)*matrix(2,1)
                return
               else
               ! lets sweep the columns of the matrix
               do ii = 1,n
                   call slice_f(sl, matrix,n,1,ii)
        det = det + ( (-1.0)**(1+ii) )*matrix(1,ii)*detmf(sl,n-1)
               end do
               return
               end if
    
                
               end function detmf

			!######################################################################
			DOUBLE PRECISION FUNCTION fCubicHP1(infoVec,nx,ny,uvec,
     &	dudxvec,dudyvec,mrx,mrz)
			!######################################################################
			!   
			! Least Squares Model using Cramer's solver
			implicit none
			INTEGER, INTENT(IN)::infoVec(8)
			DOUBLE PRECISION, INTENT(IN):: nx(2), ny(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: dudxvec(4),dudyvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz ! baricentric coordinates i the global element
			!
			DOUBLE PRECISION:: q1(12) ! nodal values and their derivatives
			!,dom(ib)%np1(iii,jjj,kkk,12) these are global variables now
			! Shape funcions for the cubic quadrilateral element
			DOUBLE PRECISION:: hx(12),hy(12),nQp(12,12), pV
			! baricentric coordinates on the master element
            DOUBLE PRECISION:: eta1,eta2
			!
			INTEGER:: nn,ib,ll,iii,jjj,kkk,flag1,fieldFlag
            !
			! Iteration variables
			INTEGER:: ii
			!
			!           *   ------------------------------------- *
			!               Vertex 4, n4(-1,1) = 1                   Vertex 3, n3(1,1) = 1
			!           |         dn1/dx = 0                      |     dn1/dx = 0
			!           |         dn2/dx = 0                      |     dn2/dx = 0
			!           |         dn3/dx = 0                      |     dn3/dx = 0
			!           |         dn4/dx = 0                      |     dn4/dx = 0
			!           |                                         |
			!           |                                         |
			!           |                                         |
			!           |                                         |
			!           |                                         |
			!           |                                         |
			!           |                                         |
			!           |                                         |
			!
			!           *   ------------------------------------- *
			!               Vertex 1, n1(-1,-1) = 1                  Vertex 2, n2(1,-1) = 1
			!                     dn1/dx = 0                            dn1/dx = 0
			!                     dn2/dx = 0                            dn2/dx = 0
			!                     dn3/dx = 0                            dn3/dx = 0
			!                     dn4/dx = 0                            dn4/dx = 0
			!
			!
			!
			!
			!
			!    =============================== Shape function nb
			!
			!                       2       2                2           2       3       3          3        3
			!a + bx + cy + dx  + ey  + gxy + hx y + ixy  + jx  + jy  +  lyx + mxy
			!1      2       3   4       5       6           7       8           9     10        11      12
			!
			!nb = a1 + b1*x + c1*y + d1*x**2 + e1*y**2 + g1*x*y + h1*y*x**2 + i1*x*y**2 + j1*x**3 + k1*y**3 + l1*y*x**3 + m1*x*y**3
			!     1      2     3     4           5        6          7           8           9       10          11          12   
			!
			! utest : interpolated value, that should be close to the true value 'u'
			! ni : shape functions with i = 1,2,3,...,12
			! eta1, eta2 : baricentric coordinates on the master element
			!
			! utest = q1*n1(eta1,eta2) + q2*n2(eta1,eta2) + q3*n4(eta1,eta2) + q4*n4(eta1,eta2) + q5*n5(eta1,eta2) + q6*n6(eta1,eta2) + 
			!     &   q7*n7(eta1,eta2) + q8*n8(eta1,eta2) + q9*n9(eta1,eta2) +q10*n10(eta1,eta2)+q11*n11(eta1,eta2)+q12*n12(eta1,eta2)
			!
			!
			nn = infoVec(1) ! nn	! Node nds(1.5)
			ib = infoVec(2) ! ib 
			ll = infoVec(3) ! ll
			iii = infoVec(4) ! id 
			jjj = infoVec(5) ! jjj
			kkk = infoVec(6) ! kd
			flag1 = infoVec(7) ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
			fieldFlag = infoVec(8) ! 1 ! fieldFlag for selecting u velocity
			!gcumx = vec3(1) !mrx
			!gcumy = vec3(2) !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			!gcumz = vec3(3) !mrz
			! Lets define the coeficientsl fo the shape functions
			!
			if(itime.le.itime_start+1)then ! start time check for initializing shape functions
            !
			eta1 = -1 + (1 - (-1))*(mrx - nx(1))/(nx(2) - nx(1) )
            eta2 = -1 + (1 - (-1))*(mrz - ny(1))/(ny(2) - ny(1) )
            !
			if(fieldFlag.eq.1)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing u Shape functions"
			endif
            dom(ib)%npu(iii,jjj,kkk,:) = 0.0d00
			elseif(fieldFlag.eq.2)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing v Shape functions"
			endif
			dom(ib)%npv(iii,jjj,kkk,:) = 0.0d00
			elseif(fieldFlag.eq.3)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing w Shape functions"
			endif
			dom(ib)%npw(iii,jjj,kkk,:) = 0.0d00
			elseif(fieldFlag.eq.4)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing p Shape functions"
			endif
			dom(ib)%npp(iii,jjj,kkk,:) = 0.0d00
			endif
            nQp = 0.0d00
            hx  = 1.0d00
            hy  = 1.0d00
            !
            ! Coefficients for Shape function n1, q1
            ![ 0.25  -0.375 -0.375  0.     0.     0.5    0.     0.     0.125  0.125 -0.125 -0.125]
            nQp(1,1 ) = +0.250d00
            nQp(1,2 ) = -0.375d00
            nQp(1,3 ) = -0.375d00
            nQp(1,4 ) = +0.000d00
            nQp(1,5 ) = +0.000d00
            nQp(1,6 ) = +0.500d00
            nQp(1,7 ) = +0.000d00
            nQp(1,8 ) = +0.000d00
            nQp(1,9 ) = +0.125d00
            nQp(1,10) = +0.125d00
            nQp(1,11) = -0.125d00
            nQp(1,12) = -0.125d00
            !
            ! Coefficients for function n5, dq1/dx
            ![ 0.125 -0.125 -0.125 -0.125  0.     0.125  0.125  0.     0.125  0. -0.125  0.   ]
            hx(2) = nx(2) - nx(1)
            nQp(2,1 ) = +0.125d00
            nQp(2,2 ) = -0.125d00
            nQp(2,3 ) = -0.125d00
            nQp(2,4 ) = -0.125d00
            nQp(2,5 ) = +0.000d00
            nQp(2,6 ) = +0.125d00
            nQp(2,7 ) = +0.125d00
            nQp(2,8 ) = +0.000d00
            nQp(2,9 ) = +0.125d00
            nQp(2,10) = +0.000d00
            nQp(2,11) = -0.125d00
            nQp(2,12) = +0.000d00
            !
            ! Coefficients for function n9, dq1/dy
            ! [ 0.125 -0.125 -0.125  0.    -0.125  0.125  0.     0.125  0.     0.125  0.    -0.125]
            hy(3) = ny(2) - ny(1)
            nQp(3,1 ) = +0.125d00
            nQp(3,2 ) = -0.125d00
            nQp(3,3 ) = -0.125d00
            nQp(3,4 ) = +0.000d00
            nQp(3,5 ) = -0.125d00
            nQp(3,6 ) = +0.125d00
            nQp(3,7 ) = +0.000d00
            nQp(3,8 ) = +0.125d00
            nQp(3,9 ) = +0.000d00
            nQp(3,10) = +0.125d00
            nQp(3,11) = +0.000d00
            nQp(3,12) = -0.125d00
            !
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !
            ! Coefficients for function n2, q2
            ![ 0.25   0.375 -0.375  0.     0.    -0.5    0.     0.    -0.125  0.125  0.125  0.125]
            nQp(4,1 ) = +0.250d00
            nQp(4,2 ) = +0.375d00
            nQp(4,3 ) = -0.375d00
            nQp(4,4 ) = +0.000d00
            nQp(4,5 ) = +0.000d00
            nQp(4,6 ) = -0.500d00
            nQp(4,7 ) = +0.000d00
            nQp(4,8 ) = +0.000d00
            nQp(4,9 ) = -0.125d00
            nQp(4,10) = +0.125d00
            nQp(4,11) = +0.125d00
            nQp(4,12) = +0.125d00
            !
            ! Coefficients for function n6, dq2/dx
            ! [-0.125 -0.125  0.125  0.125  0.     0.125 -0.125  0.     0.125  0. -0.125  0.   ]
            hx(5) = nx(2) - nx(1)
            nQp(5,1 ) = -0.125d00
            nQp(5,2 ) = -0.125d00
            nQp(5,3 ) = +0.125d00
            nQp(5,4 ) = +0.125d00
            nQp(5,5 ) = +0.000d00
            nQp(5,6 ) = +0.125d00
            nQp(5,7 ) = -0.125d00
            nQp(5,8 ) = +0.000d00
            nQp(5,9 ) = +0.125d00
            nQp(5,10) = +0.000d00
            nQp(5,11) = -0.125d00
            nQp(5,12) = +0.000d00
            !
            ! Coefficients for function n10, dq2/dy
            ! [ 0.125  0.125 -0.125  0.    -0.125 -0.125  0.    -0.125  0.     0.125  0.     0.125]
            hy(6) = ny(2) - ny(1)
            nQp(6,1 ) = +0.125d00
            nQp(6,2 ) = +0.125d00
            nQp(6,3 ) = -0.125d00
            nQp(6,4 ) = +0.000d00
            nQp(6,5 ) = -0.125d00
            nQp(6,6 ) = -0.125d00
            nQp(6,7 ) = +0.000d00
            nQp(6,8 ) = -0.125d00
            nQp(6,9 ) = +0.000d00
            nQp(6,10) = +0.125d00
            nQp(6,11) = +0.000d00
            nQp(6,12) = +0.125d00
            !
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !
            ! Coefficients for function n3, q3
            ![ 0.25   0.375  0.375  0.     0.     0.5    0.     0.    -0.125 -0.125 -0.125 -0.125]
            nQp(7,1 ) = +0.250d00
            nQp(7,2 ) = +0.375d00
            nQp(7,3 ) = +0.375d00
            nQp(7,4 ) = +0.000d00
            nQp(7,5 ) = +0.000d00
            nQp(7,6 ) = +0.500d00
            nQp(7,7 ) = +0.000d00
            nQp(7,8 ) = +0.000d00
            nQp(7,9 ) = -0.125d00
            nQp(7,10) = -0.125d00
            nQp(7,11) = -0.125d00
            nQp(7,12) = -0.125d00
            !
            ! Coefficients for function n7, dq3/dx
            ![-0.125 -0.125 -0.125  0.125  0.    -0.125  0.125  0.     0.125  0.  0.125  0.   ]
            hx(8) = nx(2) - nx(1)
            nQp(8,1 ) = -0.125d00 
            nQp(8,2 ) = -0.125d00 
            nQp(8,3 ) = -0.125d00 
            nQp(8,4 ) = +0.125d00 
            nQp(8,5 ) = +0.000d00 
            nQp(8,6 ) = -0.125d00 
            nQp(8,7 ) = +0.125d00 
            nQp(8,8 ) = +0.000d00 
            nQp(8,9 ) = +0.125d00 
            nQp(8,10) = +0.000d00 
            nQp(8,11) = +0.125d00 
            nQp(8,12) = +0.000d00 
            !
            ! Coefficients for function n11, dq3/dy
            ![-0.125 -0.125 -0.125  0.     0.125 -0.125  0.     0.125  0.     0.125  0.     0.125]
            hy(9) = ny(2) - ny(1)
            nQp(9,1 ) = -0.125d00
            nQp(9,2 ) = -0.125d00
            nQp(9,3 ) = -0.125d00
            nQp(9,4 ) = +0.000d00
            nQp(9,5 ) = +0.125d00
            nQp(9,6 ) = -0.125d00
            nQp(9,7 ) = +0.000d00
            nQp(9,8 ) = +0.125d00
            nQp(9,9 ) = +0.000d00
            nQp(9,10) = +0.125d00
            nQp(9,11) = +0.000d00
            nQp(9,12) = +0.125d00
            !
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !
            ! Coefficients for function n4, q4
            ![ 0.25  -0.375  0.375  0.     0.    -0.5    0.     0.     0.125 -0.125  0.125  0.125]
            nQp(10,1 ) = +0.250d00
            nQp(10,2 ) = -0.375d00
            nQp(10,3 ) = +0.375d00
            nQp(10,4 ) = +0.000d00
            nQp(10,5 ) = +0.000d00
            nQp(10,6 ) = -0.500d00
            nQp(10,7 ) = +0.000d00
            nQp(10,8 ) = +0.000d00
            nQp(10,9 ) = +0.125d00
            nQp(10,10) = -0.125d00
            nQp(10,11) = +0.125d00
            nQp(10,12) = +0.125d00
            !
            ! Coefficients for function n8, dq4/dx
            ! [ 0.125 -0.125  0.125 -0.125  0.    -0.125 -0.125  0.     0.125  0.  0.125  0.   ]
            hx(11) = nx(2) - nx(1)
            nQp(11,1 ) = +0.125d00
            nQp(11,2 ) = -0.125d00
            nQp(11,3 ) = +0.125d00
            nQp(11,4 ) = -0.125d00
            nQp(11,5 ) = +0.000d00
            nQp(11,6 ) = -0.125d00
            nQp(11,7 ) = -0.125d00
            nQp(11,8 ) = +0.000d00
            nQp(11,9 ) = +0.125d00
            nQp(11,10) = +0.000d00
            nQp(11,11) = +0.125d00
            nQp(11,12) = +0.000d00
            !
            ! Coefficients for function n12, dq4/dy
            ! [-0.125  0.125 -0.125  0.     0.125  0.125  0.    -0.125  0.     0.125  0.    -0.125]
            hy(12) = ny(2) - ny(1)
            nQp(12,1 ) = -0.125d00
            nQp(12,2 ) = +0.125d00
            nQp(12,3 ) = -0.125d00
            nQp(12,4 ) = +0.000d00
            nQp(12,5 ) = +0.125d00
            nQp(12,6 ) = +0.125d00
            nQp(12,7 ) = +0.000d00
            nQp(12,8 ) = -0.125d00
            nQp(12,9 ) = +0.000d00
            nQp(12,10) = +0.125d00
            nQp(12,11) = +0.000d00
            nQp(12,12) = -0.125d00
            !
            !debug
            !print*, 
            !print*, 
            !print*, "test cubic HP q4 FEM"
            !!!print*, q1(2)
            !!print*, q1
            !!print*, nx
            !!print*, q1
            !print*, mrx, mrz
            !print*, eta1, eta2

            ! lets evaluate the sgape functions
            !
            !                       2       2                2           2       3       3          3        3
            !a + bx + cy + dx  + ey  + gxy + hx y + ixy  + jx  + jy  +  lyx + mxy
            !1      2       3   4       5       6           7       8           9     10        11      12
            !
            !nb = a1 + b1*x + c1*y + d1*x**2 + e1*y**2 + g1*x*y + h1*y*x**2 + i1*x*y**2 + j1*x**3 + k1*y**3 + l1*y*x**3 + m1*x*y**3
            !     1      2     3     4           5        6          7           8           9       10          11          12        
            !
            ! sweeping p1 shape functions
            do ii = 1,12
            !print*, "=================================== coefs n",ii
            pV = nQp(ii,1)
            pV = pV +nQp(ii,2)*eta1
            pV = pV +nQp(ii,3)*eta2
            pV = pV +nQp(ii,4)*eta1*eta1
            pV = pV +nQp(ii,5)*eta2*eta2
            pV = pV +nQp(ii,6)*eta1*eta2
            pV = pV +nQp(ii,7)*eta2*eta1**2
            pV = pV +nQp(ii,8)*eta1*eta2**2 
            pV = pV +nQp(ii,9)*eta1**3
            pV = pV +nQp(ii,10)* eta2**3
            pV = pV +nQp(ii,11)*eta1**3 * eta2
            pV = pV +nQp(ii,12)*eta1 * eta2**3
            pV = pV *hx(ii)*hy(ii)
			if(fieldFlag.eq.1)then
            dom(ib)%npu(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			elseif(fieldFlag.eq.2)then
            dom(ib)%npv(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			elseif(fieldFlag.eq.3)then
            dom(ib)%npw(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			elseif(fieldFlag.eq.4)then
            dom(ib)%npp(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			endif
			!
            enddo
            !
            endif ! start time check for initializing shape functions
            !
			!
			q1(1) = uvec(1)  !dom(ib)%u(id-1,jjc,kd-1)
			q1(2) = dudxvec(1)  !dom(ib)%u(id-1,jjc,kd-1)
			q1(3) = dudyvec(1)  !dom(ib)%u(id-1,jjc,kd-1)
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			q1(4) = uvec(2)  !dom(ib)%u(id+0,jjc,kd-1)
			q1(5) = dudxvec(2)  !dom(ib)%u(id-1,jjc,kd-1)
			q1(6) = dudyvec(2)  !dom(ib)%u(id-1,jjc,kd-1)
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			q1(7) = uvec(4)  !dom(ib)%u(id+0,jjc,kd+0)
			q1(8) = dudxvec(4)  !dom(ib)%u(id-1,jjc,kd-1)
			q1(9) = dudyvec(4)  !dom(ib)%u(id-1,jjc,kd-1)
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			q1(10) = uvec(3)  !dom(ib)%u(id-1,jjc,kd+0)
			q1(11) = dudxvec(3)  !dom(ib)%u(id-1,jjc,kd-1)
			q1(12) = dudyvec(3)  !dom(ib)%u(id-1,jjc,kd-1)
            !
			! lets compute the value of utest using a finite element approximation
			fCubicHP1 = 0.0d00
			do ii = 1, 12
			if(fieldFlag.eq.1)then
				fCubicHP1 = fCubicHP1 + q1(ii)*dom(ib)%npu(iii,jjj,kkk,ii)
			elseif(fieldFlag.eq.2)then
				fCubicHP1 = fCubicHP1 + q1(ii)*dom(ib)%npv(iii,jjj,kkk,ii)
			elseif(fieldFlag.eq.3)then
				fCubicHP1 = fCubicHP1 + q1(ii)*dom(ib)%npw(iii,jjj,kkk,ii)
				! debug
				!if(nn.eq.70)then
				!print*,"q1(ii),n1(ii),uVal"
				!print*,q1(ii),dom(ib)%npw(iii,jjj,kkk,ii),fCubicHP1
				!endif
			elseif(fieldFlag.eq.4)then
				fCubicHP1 = fCubicHP1 + q1(ii)*dom(ib)%npp(iii,jjj,kkk,ii)
			endif
			enddo
			
			!######################################################################
			END FUNCTION fCubicHP1
			!######################################################################


		!######################################################################
			DOUBLE PRECISION FUNCTION fQuadLagrange(infoVec,qf,
     &	nx,ny,uvec,mrx,mrz)
		!######################################################################
			!   
			! Least Squares Model using Cramer's solver
			implicit none
			INTEGER, INTENT(IN)::infoVec(8),qf
			DOUBLE PRECISION, INTENT(IN):: nx(4), ny(4),uvec(16)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz ! baricentric coordinates i the global element
			!
			DOUBLE PRECISION:: q1(9) ! nodal values and their derivatives
			!,dom(ib)%np1(iii,jjj,kkk,12) these are global variables now
			! Shape funcions for the cubic quadrilateral element
			DOUBLE PRECISION:: nQp(9,9), pV
			! baricentric coordinates on the master element
            DOUBLE PRECISION:: eta1,eta2
			!
			INTEGER:: nn,ib,ll,iii,jjj,kkk,flag1,fieldFlag
            !
			! Iteration variables
			INTEGER:: ii
			!
            !
            !                          uvec(9)                                   uvec(11)
            !                      Vertex 4, n4(-1,1) = 1                   Vertex 3, n3(1,1) = 1
            !                            *   ---------------*--------------------- *
            !                            |           Vertex 8, n8(0,+1) = 1        |
            !                            |              uvec(10)                   |     
            !                            |                                         |     
            !                            |                                         |
            !                            |                                         |
            !                            |                                         |
            !  Vertex 5, n5(-1,0) = 1    *                  *                      *  Vertex 7, n7(+1,0) = 1
            !         uvec(5)            |           Vertex 9, n9(0,0) = 1         |        uvec(7)
            !                            |                uvec(6)                  |
            !                            |                                         |
            !                            |                                         |
            !                            |         Vertex 6, n6(0,-1) = 1          |         
            !                            |               uvec(2)                   |        
            !                            *   ---------------*--------------------- *
            !                     Vertex 1, n1(-1,-1) = 1                  Vertex 2, n2(1,-1) = 1
            !                       uvec(1)                                     uvec(3)
            !
            !
            !    =============================== Shape function nb
            !
            !                       2       2                2           2       2  2
            !a + bx + cy + dx  + ey  + gxy + hx y + ixy  + jx y 
            !1      2       3   4       5       6           7       8       9        
            !
            ! utest : interpolated value, that should be close to the true value 'u'
            ! ni : shape functions with i = 1,2,3,...,9
            ! eta1, eta2 : baricentric coordinates on the master element
            !
            ! utest = q1*n1(eta1,eta2) + q2*n2(eta1,eta2) + q3*n4(eta1,eta2) + q4*n4(eta1,eta2) + q5*n5(eta1,eta2) + q6*n6(eta1,eta2) + 
            !   &   q7*n7(eta1,eta2) + q8*n8(eta1,eta2) +  q9*n9(eta1,eta2)
            !
            ! Lets define the coeficientsl fo the shape functions
			!
			!
			nn = infoVec(1) ! nn	! Node nds(1.5)
			ib = infoVec(2) ! ib 
			ll = infoVec(3) ! ll
			iii = infoVec(4) ! id 
			jjj = infoVec(5) ! jjj
			kkk = infoVec(6) ! kd
			flag1 = infoVec(7) ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
			fieldFlag = infoVec(8) ! 1 ! fieldFlag for selecting u velocity
			!gcumx = vec3(1) !mrx
			!gcumy = vec3(2) !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			!gcumz = vec3(3) !mrz
			! Lets define the coeficientsl fo the shape functions
			!
			if(itime.le.itime_start+1)then ! start time check for initializing shape functions
            !
			if(fieldFlag.eq.1)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing u Shape functions"
			endif
            dom(ib)%nlgu(iii,jjj,kkk,:) = 0.0d00
			elseif(fieldFlag.eq.2)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing v Shape functions"
			endif
			dom(ib)%nlgv(iii,jjj,kkk,:) = 0.0d00
			elseif(fieldFlag.eq.3)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing w Shape functions"
			endif
			dom(ib)%nlgw(iii,jjj,kkk,:) = 0.0d00
			elseif(fieldFlag.eq.4)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing p Shape functions"
			endif
			dom(ib)%nlgp(iii,jjj,kkk,:) = 0.0d00
			endif
            nQp = 0.0d00
            !
            nQp(1,1)  = +0.00d00    
            nQp(1,2)  = +0.00d00   
            nQp(1,3)  = +0.00d00   
            nQp(1,4)  = +0.00d00   
            nQp(1,5)  = +0.00d00  
            nQp(1,6)  = +0.25d00  
            nQp(1,7)  = -0.25d00  
            nQp(1,8)  = -0.25d00 
            nQp(1,9)  = +0.25d00  
            !
            nQp(2,1)  = +0.00d00
            nQp(2,2)  = +0.00d00
            nQp(2,3)  = +0.00d00
            nQp(2,4)  = +0.00d00
            nQp(2,5)  = +0.00d00
            nQp(2,6)  = -0.25d00
            nQp(2,7)  = -0.25d00
            nQp(2,8)  = +0.25d00
            nQp(2,9)  = +0.25d00
                !!!!!!!!!!!!
            nQp(3,1)  = +0.00d00
            nQp(3,2)  = +0.00d00
            nQp(3,3)  = +0.00d00
            nQp(3,4)  = +0.00d00
            nQp(3,5)  = +0.00d00
            nQp(3,6)  = +0.25d00
            nQp(3,7)  = +0.25d00
            nQp(3,8)  = +0.25d00
            nQp(3,9)  = +0.25d00
                !!!!!!!!!!!!
            nQp(4,1)  = +0.00d00
            nQp(4,2)  = +0.00d00
            nQp(4,3)  = +0.00d00
            nQp(4,4)  = +0.00d00
            nQp(4,5)  = +0.00d00
            nQp(4,6)  = -0.25d00
            nQp(4,7)  = +0.25d00
            nQp(4,8)  = -0.25d00
            nQp(4,9)  = +0.25d00
                !!!!!!!!!!!!
            nQp(5,1)  = +0.00d00
            nQp(5,2)  = -0.50d0
            nQp(5,3)  = +0.00d00
            nQp(5,4)  = +0.50d00
            nQp(5,5)  = +0.00d00
            nQp(5,6)  = +0.00d00
            nQp(5,7)  = +0.00d00
            nQp(5,8)  = +0.50d00
            nQp(5,9)  = -0.50d00
                !!!!!!!!!!!!
            nQp(6,1)  = +0.00d00
            nQp(6,2)  = +0.00d00
            nQp(6,3)  = -0.50d00
            nQp(6,4)  = +0.00d00
            nQp(6,5)  = +0.50d00
            nQp(6,6)  = +0.00d00
            nQp(6,7)  = +0.50d00
            nQp(6,8)  = +0.00d00
            nQp(6,9)  = -0.50d00
                !!!!!!!!!!!!
            nQp(7,1)  = +0.00d00
            nQp(7,2)  = +0.50d00
            nQp(7,3)  = +0.00d00
            nQp(7,4)  = +0.50d00
            nQp(7,5)  = +0.00d00
            nQp(7,6)  = +0.00d00
            nQp(7,7)  = +0.00d00
            nQp(7,8)  = -0.50d00
            nQp(7,9)  = -0.50d00
            !!!!!!!!!!!!!!!!!!!!!! [ 0.   0.   0.5  0.   0.5  0.  -0.5  0.  -0.5]
            nQp(8,1)  = +0.00d00
            nQp(8,2)  = +0.00d00
            nQp(8,3)  = +0.50d00
            nQp(8,4)  = +0.00d00
            nQp(8,5)  = +0.50d00
            nQp(8,6)  = +0.00d00
            nQp(8,7)  = -0.50d00
            nQp(8,8)  = +0.00d00
            nQp(8,9)  = -0.50d00
                !!!!!!!!!!!!
            nQp(9,1)  = +1.00d00
            nQp(9,2)  = +0.00d00
            nQp(9,3)  = +0.00d00
            nQp(9,4)  = -1.00d00
            nQp(9,5)  = -1.00d00
            nQp(9,6)  = +0.00d00
            nQp(9,7)  = +0.00d00
            nQp(9,8)  = +0.00d00
            nQp(9,9)  = +1.00d00
            !
            if(qf.eq.1)then
            eta1 = -1 + (1 - (-1))*(mrx - nx(2))/(nx(4) - nx(2) )
            eta2 = -1 + (1 - (-1))*(mrz - ny(1))/(ny(3) - ny(1) )
            !
            elseif(qf.eq.2)then
            eta1 = -1 + (1 - (-1))*(mrx - nx(2))/(nx(4) - nx(2) )
            eta2 = -1 + (1 - (-1))*(mrz - ny(2))/(ny(4) - ny(2) )
            !
            elseif(qf.eq.3)then
            eta1 = -1 + (1 - (-1))*(mrx - nx(1))/(nx(3) - nx(1) )
            eta2 = -1 + (1 - (-1))*(mrz - ny(2))/(ny(4) - ny(2) )
            !
            elseif(qf.eq.4)then
            eta1 = -1 + (1 - (-1))*(mrx - nx(1))/(nx(3) - nx(1) )
			eta2 = -1 + (1 - (-1))*(mrz - ny(1))/(ny(3) - ny(1) )
            !
            endif
            !debug
            !print*, 
            !print*, 
            !print*, "test cubic HP q4 FEM"
            !!!print*, q1(2)
            !!print*, q1
            !!print*, nx
            !!print*, q1
            !print*, mrx, mrz
            !print*, eta1, eta2

            ! lets evaluate the sgape functions
            !
            !                         
            !                       2       2                2           2       2  2
            !a + bx + cy + dx  + ey  + gxy + hx y + ixy  + jx y 
            !1      2       3   4       5       6           7       8       9              
            !
            ! sweeping p1 shape functions
            do ii = 1,9
            !print*, "=================================== coefs n",ii
            pV = nQp(ii,1)
            pV = pV +nQp(ii,2)*eta1
            pV = pV +nQp(ii,3)*eta2
            pV = pV +nQp(ii,4)*eta1**2
            pV = pV +nQp(ii,5)*eta2**2
            pV = pV +nQp(ii,6)*eta1*eta2
            pV = pV +nQp(ii,7)*eta1**2 * eta1
            pV = pV +nQp(ii,8)*eta1* eta2**2
            pV = pV +nQp(ii,9)*eta1**2 * eta2**2
			if(fieldFlag.eq.1)then
            dom(ib)%nlgu(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			elseif(fieldFlag.eq.2)then
            dom(ib)%nlgv(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			elseif(fieldFlag.eq.3)then
            dom(ib)%nlgw(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			elseif(fieldFlag.eq.4)then
            dom(ib)%nlgp(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			endif
			!
            enddo
            !
            endif ! start time check for initializing shape functions
            !
            !
            if(qf.eq.1)then
            q1(1) = uvec(2)  !dom(ib)%u(id-2,jjc,kd-2)
            q1(2) = uvec(4)  !dom(ib)%u(id+0,jjc,kd-2)
            q1(3) = uvec(12) !dom(ib)%u(id+0,jjc,kd+0)
            q1(4) = uvec(10)  !dom(ib)%u(id-2,jjc,kd+0)
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            q1(5) = uvec(6)  !dom(ib)%u(id-2,jjc,kd-1)
            q1(6) = uvec(3)  !dom(ib)%u(id-1,jjc,kd-2)
            q1(7) = uvec(8)  !dom(ib)%u(id+0,jjc,kd-1)
            q1(8) = uvec(11) !dom(ib)%u(id-1,jjc,kd+0)
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            q1(9) = uvec(7)  !dom(ib)%u(id+0,jjc,kd+0)
            !
            elseif(qf.eq.2)then
            q1(1) = uvec(6)  !dom(ib)%u(id-2,jjc,kd-2)
            q1(2) = uvec(8)  !dom(ib)%u(id+0,jjc,kd-2)
            q1(3) = uvec(16) !dom(ib)%u(id+0,jjc,kd+0)
            q1(4) = uvec(14)  !dom(ib)%u(id-2,jjc,kd+0)
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            q1(5) = uvec(10)  !dom(ib)%u(id-2,jjc,kd-1)
            q1(6) = uvec(7)  !dom(ib)%u(id-1,jjc,kd-2)
            q1(7) = uvec(12)  !dom(ib)%u(id+0,jjc,kd-1)
            q1(8) = uvec(15) !dom(ib)%u(id-1,jjc,kd+0)
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            q1(9) = uvec(11)  !dom(ib)%u(id+0,jjc,kd+0)
            !
            elseif(qf.eq.3)then
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            q1(9) = uvec(6)  !dom(ib)%u(id+0,jjc,kd+0)
            q1(1) = uvec(5)  !dom(ib)%u(id-2,jjc,kd-2)
            q1(2) = uvec(7)  !dom(ib)%u(id+0,jjc,kd-2)
            q1(3) = uvec(15) !dom(ib)%u(id+0,jjc,kd+0)
            q1(4) = uvec(13)  !dom(ib)%u(id-2,jjc,kd+0)
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            q1(5) = uvec(9)  !dom(ib)%u(id-2,jjc,kd-1)
            q1(6) = uvec(6)  !dom(ib)%u(id-1,jjc,kd-2)
            q1(7) = uvec(11)  !dom(ib)%u(id+0,jjc,kd-1)
            q1(8) = uvec(14) !dom(ib)%u(id-1,jjc,kd+0)
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            q1(9) = uvec(10)  !dom(ib)%u(id+0,jjc,kd+0)   
            !
            elseif(qf.eq.4)then
            q1(1) = uvec(1)  !dom(ib)%u(id-2,jjc,kd-2)
            q1(2) = uvec(3)  !dom(ib)%u(id+0,jjc,kd-2)
            q1(3) = uvec(11) !dom(ib)%u(id+0,jjc,kd+0)
            q1(4) = uvec(9)  !dom(ib)%u(id-2,jjc,kd+0)
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            q1(5) = uvec(5)  !dom(ib)%u(id-2,jjc,kd-1)
            q1(6) = uvec(2)  !dom(ib)%u(id-1,jjc,kd-2)   
            q1(7) = uvec(7)  !dom(ib)%u(id+0,jjc,kd-1)   
            q1(8) = uvec(10) !dom(ib)%u(id-1,jjc,kd+0)   
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            q1(9) = uvec(6)  !dom(ib)%u(id-1,jjc,kd-1)   
            !
            endif
            !
            !
			! lets compute the value of utest using a finite element approximation
			fQuadLagrange = 0.0d00
			do ii = 1, 9
			if(fieldFlag.eq.1)then
				fQuadLagrange = fQuadLagrange + q1(ii)*dom(ib)%nlgu(iii,jjj,kkk,ii)
				! debug
				!if(nn.eq.70)then
				!print*,"q1(ii),n1(ii),uVal"
				!print*,q1(ii),dom(ib)%nlgu(iii,jjj,kkk,ii),fQuadLagrange
				!endif
			elseif(fieldFlag.eq.2)then
				fQuadLagrange = fQuadLagrange + q1(ii)*dom(ib)%nlgv(iii,jjj,kkk,ii)
			elseif(fieldFlag.eq.3)then
				fQuadLagrange = fQuadLagrange + q1(ii)*dom(ib)%nlgw(iii,jjj,kkk,ii)
			elseif(fieldFlag.eq.4)then
				fQuadLagrange = fQuadLagrange + q1(ii)*dom(ib)%nlgp(iii,jjj,kkk,ii)
			endif
			enddo
			
			!######################################################################
			END FUNCTION fQuadLagrange
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION fBilinear(infoVec,nx,ny,uvec,mrx,mrz)
			!######################################################################
			!   
			! Least Squares Model using Cramer's solver
			implicit none
			INTEGER, INTENT(IN)::infoVec(8)
			DOUBLE PRECISION, INTENT(IN):: nx(2), ny(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz ! baricentric coordinates i the global element
			!
			DOUBLE PRECISION:: q1(4) ! nodal values and their derivatives
			!,dom(ib)%np1(iii,jjj,kkk,12) these are global variables now
			! Shape funcions for the cubic quadrilateral element
			DOUBLE PRECISION:: nQp(4,4), pV
			! baricentric coordinates on the master element
            DOUBLE PRECISION:: eta1,eta2
			!
			INTEGER:: nn,ib,ll,iii,jjj,kkk,flag1,fieldFlag
            !
			! Iteration variables
			INTEGER:: ii
			!
            !
            !           *   ------------------------------------- *
            !               Vertex 4, n4(-1,1) = 1                   Vertex 3, n3(1,1) = 1
            !           |                                         |
            !           |                                         |
            !           |                                         |
            !           |                                         |
            !           |                                         |
            !           |                                         |
            !           |                                         |
            !           |                                         |
            !           |                                         |
            !
            !           *   ------------------------------------- *
            !               Vertex 1, n1(-1,-1) = 1                  Vertex 2, n2(1,-1) = 1
            !
			!
			!
			!    =============================== Shape function nb
			!
            !a + bx + cy + gxy 
            !1      2       3          
            !
            !nb = a1 + b1*x + c1*y + g1*x*y 
            !     1      2     3     4        
			!
			! utest : interpolated value, that should be close to the true value 'u'
			! ni : shape functions with i = 1,2,3,...,12
			! eta1, eta2 : baricentric coordinates on the master element
			!
			! utest = q1*n1(eta1,eta2) + q2*n2(eta1,eta2) + q3*n4(eta1,eta2) + q4*n4(eta1,eta2) + q5*n5(eta1,eta2) + q6*n6(eta1,eta2) + 
			!     &   q7*n7(eta1,eta2) + q8*n8(eta1,eta2) + q9*n9(eta1,eta2) +q10*n10(eta1,eta2)+q11*n11(eta1,eta2)+q12*n12(eta1,eta2)
			!
			!
			nn = infoVec(1) ! nn	! Node nds(1.5)
			ib = infoVec(2) ! ib 
			ll = infoVec(3) ! ll
			iii = infoVec(4) ! id 
			jjj = infoVec(5) ! jjj
			kkk = infoVec(6) ! kd
			flag1 = infoVec(7) ! flag1: 0 -> uoo, 1 -> ustar, 2 -> u
			fieldFlag = infoVec(8) ! 1 ! fieldFlag for selecting u velocity
			!gcumx = vec3(1) !mrx
			!gcumy = vec3(2) !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			!gcumz = vec3(3) !mrz
			! Lets define the coeficientsl fo the shape functions
			!
			if(itime.le.itime_start+1)then ! start time check for initializing shape functions
            !
			eta1 = -1 + (1 - (-1))*(mrx - nx(1))/(nx(2) - nx(1) )
            eta2 = -1 + (1 - (-1))*(mrz - ny(1))/(ny(2) - ny(1) )
            !
			if(fieldFlag.eq.1)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing u Shape functions"
			endif
            dom(ib)%nblu(iii,jjj,kkk,:) = 0.0d00
			elseif(fieldFlag.eq.2)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing v Shape functions"
			endif
			dom(ib)%nblv(iii,jjj,kkk,:) = 0.0d00
			elseif(fieldFlag.eq.3)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing w Shape functions"
			endif
			dom(ib)%nblw(iii,jjj,kkk,:) = 0.0d00
			elseif(fieldFlag.eq.4)then
			if(nn.eq.70)then
			write(6,*) "Initianlizing p Shape functions"
			endif
			dom(ib)%nblp(iii,jjj,kkk,:) = 0.0d00
			endif
            nQp = 0.0d00
            !
            ! Coefficients for Shape function n1, q1
            ! [ 0.25 -0.25 -0.25  0.25]
            ii = 1
            nQp(ii,1 ) = +0.250d00 
            nQp(ii,2 ) = -0.250d00
            nQp(ii,3 ) = -0.250d00
            nQp(ii,4 ) = +0.250d00
            !
            !
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !
            ! Coefficients for function n2, q2
            ! [ 0.25  0.25 -0.25 -0.25]
            ii = 2
            nQp(ii,1 ) = +0.250d00 
            nQp(ii,2 ) = +0.250d00
            nQp(ii,3 ) = -0.250d00
            nQp(ii,4 ) = -0.250d00
            !
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !
            ! Coefficients for function n3, q3
            ! [0.25 0.25 0.25 0.25]
            ii = 3
            nQp(ii,1 ) = +0.250d00 
            nQp(ii,2 ) = +0.250d00
            nQp(ii,3 ) = +0.250d00
            nQp(ii,4 ) = +0.250d00
            !
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !
            ! Coefficients for function n4, q4
            ! [ 0.25 -0.25  0.25 -0.25]
            ii = 4
            nQp(ii,1 ) = +0.250d00 
            nQp(ii,2 ) = -0.250d00
            nQp(ii,3 ) = +0.250d00
            nQp(ii,4 ) = -0.250d00
            !
            !debug
            !print*, 
            !print*, 
            !print*, "test cubic HP q4 FEM"
            !!!print*, q1(2)
            !!print*, q1
            !!print*, nx
            !!print*, q1
            !print*, mrx, mrz
            !print*, eta1, eta2

            ! lets evaluate the sgape functions
            !
            !                         
            !a + bx + cy + gxy 
            !1      2       3          
            !
            !nb = a1 + b1*x + c1*y + g1*x*y 
            !     1      2     3     4              
            !
            ! sweeping p1 shape functions
            do ii = 1,4
            !print*, "=================================== coefs n",ii
            pV = nQp(ii,1)
            pV = pV +nQp(ii,2)*eta1
            pV = pV +nQp(ii,3)*eta2
            pV = pV +nQp(ii,4)*eta1*eta2
			if(fieldFlag.eq.1)then
            dom(ib)%nblu(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			elseif(fieldFlag.eq.2)then
            dom(ib)%nblv(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			elseif(fieldFlag.eq.3)then
            dom(ib)%nblw(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			elseif(fieldFlag.eq.4)then
            dom(ib)%nblp(iii,jjj,kkk,ii) = pV ! polynomial value of the shape function
			endif
			!
            enddo
            !
            endif ! start time check for initializing shape functions
            !
			!
			q1(1) = uvec(1)  !dom(ib)%u(id-1,jjc,kd-1)
			q1(2) = uvec(2)  !dom(ib)%u(id+0,jjc,kd-1)
			q1(3) = uvec(4)  !dom(ib)%u(id+0,jjc,kd+0)
			q1(4) = uvec(3)  !dom(ib)%u(id-1,jjc,kd+0)
            !
			! lets compute the value of utest using a finite element approximation
			fBilinear = 0.0d00
			do ii = 1, 4
			if(fieldFlag.eq.1)then
				fBilinear = fBilinear + q1(ii)*dom(ib)%nblu(iii,jjj,kkk,ii)
			elseif(fieldFlag.eq.2)then
				fBilinear = fBilinear + q1(ii)*dom(ib)%nblv(iii,jjj,kkk,ii)
			elseif(fieldFlag.eq.3)then
				fBilinear = fBilinear + q1(ii)*dom(ib)%nblw(iii,jjj,kkk,ii)
				! debug
				!if(nn.eq.70)then
				!print*,"q1(ii),n1(ii),uVal"
				!print*,q1(ii),dom(ib)%nblw(iii,jjj,kkk,ii),fBilinear
				!endif
			elseif(fieldFlag.eq.4)then
				fBilinear = fBilinear + q1(ii)*dom(ib)%nblp(iii,jjj,kkk,ii)
			endif
			enddo
			
			!######################################################################
			END FUNCTION fBilinear
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_px1, mirror_px2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjc,kd)
			!	ux2 = dom(ib)%u(id+1,jjc,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = pvec(1)	!dom(ib)%u(id,jjc,kd)
			ux2 = pvec(2) 	!dom(ib)%u(id-1,jjc,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_px1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjc,kd-1)
			!ux2 = dom(ib)%u(id+1,jjc,kd-1)

			! Alternative
			ux1 = pvec(3)	!dom(ib)%u(id,jjc,kd-1)
			ux2 = pvec(4)	!dom(ib)%u(id-1,jjc,kd-1)

			mirror_px2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_px1
			uz2 = mirror_px2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)

			!######################################################################
			END FUNCTION l1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION max_f(n,veck)
			!######################################################################
			INTEGER, INTENT(IN)::n
			DOUBLE PRECISION, INTENT(IN):: veck(n)
			!
			INTEGER:: ii
			DOUBLE PRECISION:: max
			!
			max = veck(1)
			do ii=2,n
				if(veck(ii).gt.max)then
				max = veck(ii)
				endif
			enddo

			max_f = max


			!######################################################################
			END FUNCTION
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION min_f(n,veck)
			!######################################################################
			INTEGER, INTENT(IN)::n
			DOUBLE PRECISION, INTENT(IN):: veck(n)
			!
			INTEGER:: ii
			DOUBLE PRECISION:: min
			!
			min = veck(1)
			do ii=2,n
				if(veck(ii).lt.min)then
				min = veck(ii)
				endif
			enddo

			min_f = min

			!######################################################################
			END FUNCTION
			!######################################################################

!######################################################################		
	END SUBROUTINE ghostCell
!######################################################################	


!######################################################################	
      SUBROUTINE checkEmergingCells
!######################################################################	
	! subroutine for checking if there is any emerging fluid cell from the inmersed body
	! the condition is that for the same cell adress the flag mucx is zero and the flag
	! mucold is either 1,2,3 or 4.
	!
	! In searchGhostCells, the flag mucx is set to zero by default at the beggining. If the 
	! algorithm finds any fluid cell inside the body, mucx takes the value qF, that is, the 
	! quadrant in which that fluid cell is located.
	!
	! Case 1
	! Thus, for the same cell adress, if you have mucx = 0 and mucxold = 1,2,3 or 4, that means that
	! in the last time step, that cell was inside the inmersed body and in the current time step the 
	! cell is actually outside the moving body. When this happens we need to set mucxold = 0.
	!
	! case 2
	! When mucx = 1, 2, 3 or 4 and mucxold = 0, a new cell is inside the inmersed body. 
	! So we need to set mucxold = 1,2,3 or 4.
	!
	! case 3
	! It can also happen that the solid position has rotated and mucx = 1,3 or 4 and mucxold = 2 
      use imb
      use mpi
      use multidata
      use vars
      implicit none
	  !
	  INTEGER::ii,jj,kk,ib,nn,ll,qF,M
	  INTEGER::iii,jjj,kkk,iic,jjc,kkc
	  INTEGER::cu,cv,cw,cp
	  INTEGER::cu_e,cv_e,cw_e,cp_e
	  INTEGER::cu_n,cv_n,cw_n,cp_n
	  INTEGER::iis,iie,jjs,jje,kks,kke
	  INTEGER::St_k, mksPS, mksEL,nnFinish,nnStart
	  DOUBLE PRECISION::gcux,gcumx,gcui,gcumi
	  DOUBLE PRECISION::gcuy,gcumy,gcuj,gcumj
	  DOUBLE PRECISION::gcuz,gcumz,gcuk,gcumk
	  !
	  DOUBLE PRECISION::gcwx,gcwmx,gcwi,gcwmi
	  DOUBLE PRECISION::gcwy,gcwmy,gcwj,gcwmj
	  DOUBLE PRECISION::gcwz,gcwmz,gcwk,gcwmk
	  ! 
	  DOUBLE PRECISION::gcpx,gcpmx,gcpi,gcpmi
	  DOUBLE PRECISION::gcpy,gcpmy,gcpj,gcpmj
	  DOUBLE PRECISION::gcpz,gcpmz,gcpk,gcpmk
	  ! 
	  ! Interface with interpolationF
	  INTEGER::vec2(8)
	  DOUBLE PRECISION::vec3(3)
	  DOUBLE PRECISION::newu0,newu0b,newu
	  DOUBLE PRECISION::neww0,neww0b,neww
	  DOUBLE PRECISION::newp0,newp0b,newp
	  DOUBLE PRECISION::newv0,newv0b,newv
	  !
	  ! Interface with bilinear interpolation
	  DOUBLE PRECISION::nx(2),nz(2),pvec(4),uvec(4),wvec(4)
	  DOUBLE PRECISION::vvec(4)
	  !
      do ib = 1, nbp ! lets sweep only the subdomains with makers
	    if(imbinblock_loc(dom_id(ib)+1).NE.0) then	! Filtering out procesors that do not have accesss 
													! to the domain where there are markers or IB points
		   write(*,*) "checking emergeingCells"
		   kks = 1
		   kke = dom(ib)%ttc_k
		   !if(bc_b.eq.5) kks = kks + 4
		   !if(bc_t.eq.5)	kks = kke - 4
		   !
		   jjs = 1
		   jje = dom(ib)%ttc_j
		   !if(bc_s.eq.5) jjs = jjs + 4
		   !if(bc_n.eq.5) jjs = jje - 4
		   !
		   iis =	1
		   iie = dom(ib)%ttc_i
		   !if(bc_w.eq.5) iis = iis + 4
		   !if(bc_e.eq.5) iis = iie - 4	
		   !
		   cu = 0
		   cv = 0
		   cw = 0
		   cp = 0
		   !
		   cu_e = 0
		   cv_e = 0
		   cw_e = 0
		   cp_e = 0
		   !
		   cu_n = 0
		   cv_n = 0
		   cw_n = 0
		   cp_n = 0
           !
		   do kk=kks,kke
		   do ii=iis,iie
		   do jj=jjs,jje
           if(dom(ib)%mucx(ii,jj,kk).ne.dom(ib)%mucxold(ii,jj,kk))then ! ghost cell treatment for the u velocity field
			!
	  		! Checking for case 1
	  	    if(dom(ib)%mucx(ii,jj,kk).eq.0) then	! ouside
	  	    if(dom(ib)%mucxold(ii,jj,kk).ne.0) then	! inside the cylinder
	  			! We have found an emerging cell
	  			! now we need to update the u velocity of the emerging cell
	  			! dom(ib)%uoo(i,j,k) = ...
			    nn = dom(ib)%mucxoldnn(ii,jj,kk)  ! nn    id for IB point or marker 
				 cu_e = cu_e + 1	! adding an emerging cell to the count
				!                                 
			    if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 !                                 
				 !ib = dom(ib)%mucxoldib(ii,jj,kk)  ! ib    if for layer at which nn marker is located
				 ll = dom(ib)%mucxoldll(ii,jj,kk)  ! ll 
				 iii = dom(ib)%mucxoldi(ii,jj,kk)  ! iii   ox location of the u ghost cell 
				 jjc = dom(ib)%mucxoldj(ii,jj,kk)  ! jjc   oy location of the u ghost cell
				 kkk = dom(ib)%mucxoldk(ii,jj,kk)  ! kkk   oy location of the u ghost cell, !check kkc?
				 qF = dom(ib)%mucxold(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                 
				 gcux  = dom(ib)%mucxoldx(ii,jj,kk) ! ox location of the u ghost cell 
				 gcuy  = dom(ib)%mucxoldy(ii,jj,kk) ! oy location of the u ghost cell
				 gcuz  = dom(ib)%mucxoldz(ii,jj,kk) ! oy location of the u ghost cell
				 !                                 
				 gcumx = dom(ib)%mucxoldmx(ii,jj,kk) ! ox location of the u mirror cell 
				 gcumy = dom(ib)%mucxoldmy(ii,jj,kk) ! oy location of the u mirror cell
				 gcumz = dom(ib)%mucxoldmz(ii,jj,kk) ! oy location of the u mirror cell
				 !                                 
				 gcumi = dom(ib)%mucxoldmi(ii,jj,kk) ! dom(ib)%x id of the u mirror cell 
				 gcumj = dom(ib)%mucxoldmj(ii,jj,kk) ! dom(ib)%y id of the u mirror cell
				 gcumk = dom(ib)%mucxoldmk(ii,jj,kk) ! dom(ib)%z id of the u mirror cell
				 !
				 !
			     !deltaFUnction
			     vec2(1) = nn   ! nn	! Node nds(1.5)
			     vec2(2) = ib   ! ib 
			     vec2(3) = ll   ! ll
			     vec2(4) = iii  ! id 
			     vec2(5) = jjc  ! jjj
			     vec2(6) = kkk  ! kd !check kkc?
			     vec2(7) = 0   ! flag1
			     vec2(8) = 1    ! 1 ! fieldFlag for selecting u velocity
			     vec3(1) = gcux !gcumx !mrx
			     vec3(2) = gcuy !gcumy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
				 vec3(3) = gcuz !gcumz !mrz
				 !
				 if(interpolationScheme.eq.1)then
					call interpolationF(vec2,vec3,newu)	! go with this one
				 elseif(interpolationScheme.eq.2)then
				   ! Bilinear Interpolation
					if(qF.eq.1) then
					   uvec(1) = dom(ib)%u(iii+1,jjc,kkk) ! q11
					   uvec(2) = dom(ib)%u(iii+2,jjc,kkk)   ! q21
					   uvec(3) = dom(ib)%u(iii+1,jjc,kkk-1)   ! q12
					   uvec(4) = dom(ib)%u(iii+2,jjc,kkk-1)	   ! q22
					   !
					   nx(1) = dom(ib)%x(iii+1)
					   nx(2) = dom(ib)%x(iii+2)
					   nz(1) = dom(ib)%zc(kkk)
					   nz(2) = dom(ib)%zc(kkk-1)
					elseif(qF.eq.2) then
					   uvec(1) = dom(ib)%u(iii+1,jjc,kkk) ! q11
					   uvec(2) = dom(ib)%u(iii+2,jjc,kkk)   ! q21
					   uvec(3) = dom(ib)%u(iii+1,jjc,kkk+1)   ! q12
					   uvec(4) = dom(ib)%u(iii+2,jjc,kkk+1)	   ! q22
					   !
					   nx(1) = dom(ib)%x(iii+1)
					   nx(2) = dom(ib)%x(iii+2)
					   nz(1) = dom(ib)%zc(kkk)
					   nz(2) = dom(ib)%zc(kkk+1)
					elseif(qF.eq.3) then
					   uvec(1) = dom(ib)%u(iii-1,jjc,kkk) ! q11
					   uvec(2) = dom(ib)%u(iii-2,jjc,kkk)   ! q21
					   uvec(3) = dom(ib)%u(iii-1,jjc,kkk+1)   ! q12
					   uvec(4) = dom(ib)%u(iii-2,jjc,kkk+1)	   ! q22
					   !
					   nx(1) = dom(ib)%x(iii-1)
					   nx(2) = dom(ib)%x(iii-2)
					   nz(1) = dom(ib)%zc(kkk)
					   nz(2) = dom(ib)%zc(kkk+1)
					elseif(qF.eq.4) then
					   uvec(1) = dom(ib)%u(iii-1,jjc,kkk) ! q11
					   uvec(2) = dom(ib)%u(iii-2,jjc,kkk)   ! q21
					   uvec(3) = dom(ib)%u(iii-1,jjc,kkk-1)   ! q12
					   uvec(4) = dom(ib)%u(iii-2,jjc,kkk-1)	   ! q22
					   !
					   nx(1) = dom(ib)%x(iii-1)
					   nx(2) = dom(ib)%x(iii-2)
					   nz(1) = dom(ib)%zc(kkk)
					   nz(2) = dom(ib)%zc(kkk-1)
					endif
					!
					newu = bl_cramer(nn,nx,nz,uvec,gcux,gcuz)
					!if ( nn.eq.70 ) then
					!	write(6,*) "Mirror u (Bilinear Interpolation: cramer)", nn, mirror_u
					!endif
				 endif
				 !
				 !if(qF.eq.1) newu = 0.7*dom(ib)%u(ii+1,jj,kk-1) 
				 !if(qF.eq.2) newu = 0.7*dom(ib)%u(ii+1,jj,kk+1) 
				 !if(qF.eq.3) newu = 0.7*dom(ib)%u(ii-1,jj,kk+1) 
				 !if(qF.eq.4) newu = 0.7*dom(ib)%u(ii-1,jj,kk-1) 
				 !
				 if(qF.eq.1) newu0b = dom(ib)%u(ii+1,jj,kk-1) 
				 if(qF.eq.2) newu0b = dom(ib)%u(ii+1,jj,kk+1) 
				 if(qF.eq.3) newu0b = dom(ib)%u(ii-1,jj,kk+1) 
				 if(qF.eq.4) newu0b = dom(ib)%u(ii-1,jj,kk-1)
				 !
				 !
				 newu0 = dom(ib)%uoo(ii,jj,kk) ! (2*Up - mirror_u) if ll = 1
				 !
				 !
				 !debug
				 St_k = ibmSt(M) ! number of station of the inmmersed body
				 mksPS = ibmStMkrs(M)	! Markers per station
				 mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				 nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				 nnStart = 1 + (int(St_k/2.0d00))*mksPS
				 !
				 !
				 if (ll.eq.1) then
				!	if(abs(newu0b-newu).lt.abs(newu0b-(-newu0 + 2*U_p))) then
				!		dom(ib)%uoo(ii,jj,kk) = newu	! -newu0 + 2*U_p	! newu
				!	else
						dom(ib)%uoo(ii,jj,kk) =0.5*(newu +( -newu0 + 2*U_p ) )	! newu
				!	endif
				 !- (2*U_p - mirror_w ) + 2*U_p
				 !		-(  newu0 -2*Up  )
				 !
				 !debug
			     if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				    write(*,*) "mucx____mucx____mucx____mucx____mucx____mucx"
				 	write(6,*) vec2
				 	write(6,*) vec3
				 	write(6,*) ii,jj,kk
				  	write(6,*) newu0b,newu,dom(ib)%uoo(ii,jj,kk)
			     endif
				 if (gcumi.eq.0) then
					write(*,*) "In checkEmergingCells gcumi = 0", nn, iii, kkk
					write(*,*) gcux, gcuy, gcuz
				 endif
				 if (gcumj.eq.0) then
					write(*,*) "In checkEmergingCells gcumj = 0", nn, iii, kkk
					write(*,*) gcux, gcuy, gcuz
				 endif
				 if (gcumk.eq.0) then
					write(*,*) "In checkEmergingCells gcumk = 0", nn, iii, kkk
					write(*,*) gcux, gcuy, gcuz
				 endif
				 elseif(ll.eq.2) then
					dom(ib)%uoo(ii,jj,kk) = newu
					!
				 	!debug
			     if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				 	   write(*,*) "mucx____mucx____mucx____mucx____mucx____mucx"
				 		write(6,*) vec2
				 		write(6,*) vec3
				 		write(6,*) ii,jj,kk
				 	 	write(6,*) newu0b,dom(ib)%uoo(ii,jj,kk)
			     	endif
					if (ll.eq.2) then
						write(*,*) "Warning Warning Waring u cell with ll = 2",nn, iii, kkk
						write(*,*) gcux, gcuy, gcuz
					 endif  
					 !
					 if (gcumi.eq.0) then
						write(*,*) "In checkEmergingCells gcumi = 0", nn, iii, kkk
						write(*,*) gcux, gcuy, gcuz
					 endif
					 if (gcumj.eq.0) then
						write(*,*) "In checkEmergingCells gcumj = 0", nn, iii, kkk
						write(*,*) gcux, gcuy, gcuz
					 endif
					 if (gcumk.eq.0) then
						write(*,*) "In checkEmergingCells gcumk = 0", nn, iii, kkk
						write(*,*) gcux, gcuy, gcuz
					 endif
				 endif
				 !
				 !
				 ! Now lets update the flags
				 dom(ib)%mucxold(ii,jj,kk) = 0 
				 dom(ib)%mucxoldnn(ii,jj,kk) = 0
				 dom(ib)%mucxoldib(ii,jj,kk) = 0
				 dom(ib)%mucxoldll(ii,jj,kk) = 0
				 dom(ib)%mucxoldi(ii,jj,kk)  = 0
				 dom(ib)%mucxoldj(ii,jj,kk)  = 0
				 dom(ib)%mucxoldk(ii,jj,kk)  = 0
				 dom(ib)%mucxoldx(ii,jj,kk)  = 0
				 dom(ib)%mucxoldy(ii,jj,kk)  = 0
				 dom(ib)%mucxoldz(ii,jj,kk)  = 0
				 dom(ib)%mucxoldmx(ii,jj,kk) = 0 
				 dom(ib)%mucxoldmy(ii,jj,kk) = 0
				 dom(ib)%mucxoldmz(ii,jj,kk) = 0
				 !
				 dom(ib)%mucxoldmi(ii,jj,kk) = 0 
				 dom(ib)%mucxoldmj(ii,jj,kk) = 0
				 dom(ib)%mucxoldmk(ii,jj,kk) = 0
				 !
				 !dom(ib)%mucx(ii,jj,kk) = 0 ! this way the ghostCell Method will not be applied to this cell
				 dom(ib)%mucxnn(ii,jj,kk) = 0
				 dom(ib)%mucxib(ii,jj,kk) = 0
				 dom(ib)%mucxll(ii,jj,kk) = 0
				 dom(ib)%mucxi(ii,jj,kk)  = 0
				 dom(ib)%mucxj(ii,jj,kk)  = 0
				 dom(ib)%mucxk(ii,jj,kk)  = 0
				 dom(ib)%mucxx(ii,jj,kk)  = 0
				 dom(ib)%mucxy(ii,jj,kk)  = 0
				 dom(ib)%mucxz(ii,jj,kk)  = 0
				 !
				 dom(ib)%mucxmx(ii,jj,kk) = 0 ! ox location of the u mirror cell 
				 dom(ib)%mucxmy(ii,jj,kk) = 0 ! oy location of the u mirror cell
				 dom(ib)%mucxmz(ii,jj,kk) = 0 ! oy location of the u mirror cell
				 !
				 dom(ib)%mucxmi(ii,jj,kk) = 0 ! dom(ib)%x id of the u mirror cell 
				 dom(ib)%mucxmj(ii,jj,kk) = 0 ! dom(ib)%y id of the u mirror cell
				 dom(ib)%mucxmk(ii,jj,kk) = 0 ! dom(ib)%z id of the u mirror cell
			    endif
			 !
			 !
	  	    endif
	  	    endif
	  		!
	  		! Checking for case 2
	  		if(dom(ib)%mucx(ii,jj,kk).ne.0) then
	  		if(dom(ib)%mucxold(ii,jj,kk).eq.0) then
				! we have found a new solid cell (formerly it was a fluid cell)
				! the rest of the info we need has already been saved in the arrays of the familly "mucx..."
				! this was done in the subroutines "searchCells" and "setMirror_u".
			    nn = dom(ib)%mucxnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				cu_n = cu_n + 1	! adding a new ghost cell to the count
				!
				dom(ib)%mucxold(ii,jj,kk)   = dom(ib)%mucx(ii,jj,kk)   ! qF for u ghost cells
				dom(ib)%mucxoldnn(ii,jj,kk) = dom(ib)%mucxnn(ii,jj,kk) ! nn for u ghost cells
				dom(ib)%mucxoldib(ii,jj,kk) = dom(ib)%mucxib(ii,jj,kk) ! ib for u ghost cells
				dom(ib)%mucxoldll(ii,jj,kk) = dom(ib)%mucxll(ii,jj,kk) ! ll for u ghost cells
				dom(ib)%mucxoldi(ii,jj,kk)  = dom(ib)%mucxi(ii,jj,kk)  ! %x  id for u ghost cells
				dom(ib)%mucxoldj(ii,jj,kk)  = dom(ib)%mucxj(ii,jj,kk)  ! %yc id for u ghost cells
				dom(ib)%mucxoldk(ii,jj,kk)  = dom(ib)%mucxk(ii,jj,kk)  ! %z  id for u ghost cells
				dom(ib)%mucxoldx(ii,jj,kk)  = dom(ib)%mucxx(ii,jj,kk)  ! %x  for u ghost cells
				dom(ib)%mucxoldy(ii,jj,kk)  = dom(ib)%mucxy(ii,jj,kk)  ! %yc for u ghost cells
				dom(ib)%mucxoldz(ii,jj,kk)  = dom(ib)%mucxz(ii,jj,kk)  ! %z  for u ghost cells
				dom(ib)%mucxoldmx(ii,jj,kk) = dom(ib)%mucxmx(ii,jj,kk)
				dom(ib)%mucxoldmy(ii,jj,kk) = dom(ib)%mucxmy(ii,jj,kk)
				dom(ib)%mucxoldmz(ii,jj,kk) = dom(ib)%mucxmz(ii,jj,kk)
				dom(ib)%mucxoldmi(ii,jj,kk) = dom(ib)%mucxmi(ii,jj,kk)
				dom(ib)%mucxoldmj(ii,jj,kk) = dom(ib)%mucxmj(ii,jj,kk)
				dom(ib)%mucxoldmk(ii,jj,kk) = dom(ib)%mucxmk(ii,jj,kk)
				! the mirror velocity has already been sed in "setMirror_u"
				!
				endif
	  		endif
	  		endif
	  		!
			endif
			!
			!
	  		!!! Checking for case 3
			if(dom(ib)%mucx(ii,jj,kk).ne.0)then
	  		if(dom(ib)%mucxold(ii,jj,kk).ne.0)then
				! The body has moved and this cell is still inside but we need to update
				! the info for this cell.
			    nn = dom(ib)%mucxnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				cu = cu + 1	! counting a ghost cell that is still inside the inmersed body
				!
				dom(ib)%mucxold(ii,jj,kk)   = dom(ib)%mucx(ii,jj,kk)   ! qF for u ghost cells
				dom(ib)%mucxoldnn(ii,jj,kk) = dom(ib)%mucxnn(ii,jj,kk) ! nn for u ghost cells
				dom(ib)%mucxoldib(ii,jj,kk) = dom(ib)%mucxib(ii,jj,kk) ! ib for u ghost cells
				dom(ib)%mucxoldll(ii,jj,kk) = dom(ib)%mucxll(ii,jj,kk) ! ll for u ghost cells
				dom(ib)%mucxoldi(ii,jj,kk)  = dom(ib)%mucxi(ii,jj,kk)  ! %x  id for u ghost cells
				dom(ib)%mucxoldj(ii,jj,kk)  = dom(ib)%mucxj(ii,jj,kk)  ! %yc id for u ghost cells
				dom(ib)%mucxoldk(ii,jj,kk)  = dom(ib)%mucxk(ii,jj,kk)  ! %z  id for u ghost cells
				dom(ib)%mucxoldx(ii,jj,kk)  = dom(ib)%mucxx(ii,jj,kk)  ! %x  for u ghost cells
				dom(ib)%mucxoldy(ii,jj,kk)  = dom(ib)%mucxy(ii,jj,kk)  ! %yc for u ghost cells
				dom(ib)%mucxoldz(ii,jj,kk)  = dom(ib)%mucxz(ii,jj,kk)  ! %z  for u ghost cells
				!
				dom(ib)%mucxoldmi(ii,jj,kk) = dom(ib)%mucxmi(ii,jj,kk) ! %x  id for u mirror cells
				dom(ib)%mucxoldmj(ii,jj,kk) = dom(ib)%mucxmj(ii,jj,kk) ! %yc id for u mirror cells
				dom(ib)%mucxoldmk(ii,jj,kk) = dom(ib)%mucxmk(ii,jj,kk) ! %z  id for u mirror cells
				!
				dom(ib)%mucxoldmx(ii,jj,kk) = dom(ib)%mucxmx(ii,jj,kk) ! %x  for u mirror cells
				dom(ib)%mucxoldmy(ii,jj,kk) = dom(ib)%mucxmy(ii,jj,kk) ! %yc for u mirror cells
				dom(ib)%mucxoldmz(ii,jj,kk) = dom(ib)%mucxmz(ii,jj,kk) ! %z  for u mirror cells
				!
				! CHECK: remove "if mucxold .eq. 0" in setQuadrant_u
				! the mirror velocity has already been sed in "setMirror_u"
				!
				endif
			endif
			endif
              !
		   ! ghost cell treatment for the u velocity field
		   !
		   !
		   !
		   if(dom(ib)%mwcz(ii,jj,kk).ne.dom(ib)%mwczold(ii,jj,kk))then ! ghost cell treatment for the w velocity field
			!
			  ! Checking for case 1
			  if(dom(ib)%mwcz(ii,jj,kk).eq.0) then
			  if(dom(ib)%mwczold(ii,jj,kk).ne.0) then
				  ! We have found an emerging cell
				  ! now we need to update the u velocity of the emerging cell
				  ! dom(ib)%woo(i,j,k) = ...
				nn = dom(ib)%mwczoldnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 !                                 
				 cw_e = cw_e + 1	! adding an emerging cell to the count
				 !ib = dom(ib)%mwczoldib(ii,jj,kk)  ! ib    if for layer at which nn marker is located
				 ll = dom(ib)%mwczoldll(ii,jj,kk)  ! ll
				 iic = dom(ib)%mwczoldi(ii,jj,kk)  ! iii   ox location of the w ghost cell 
				 jjc = dom(ib)%mwczoldj(ii,jj,kk)  ! jjc   oy location of the w ghost cell
				 kkk = dom(ib)%mwczoldk(ii,jj,kk)  ! kkk   oy location of the w ghost cell, !check kkc?
				 qF = dom(ib)%mwczold(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                 
				 gcwx  = dom(ib)%mwczoldx(ii,jj,kk) ! ox location of the w ghost cell 
				 gcwy  = dom(ib)%mwczoldy(ii,jj,kk) ! oy location of the w ghost cell
				 gcwz  = dom(ib)%mwczoldz(ii,jj,kk) ! oy location of the w ghost cell
				 !                                 
				 gcwmx = dom(ib)%mwczoldmx(ii,jj,kk) ! ox location of the w mirror cell 
				 gcwmy = dom(ib)%mwczoldmy(ii,jj,kk) ! oy location of the w mirror cell
				 gcwmz = dom(ib)%mwczoldmz(ii,jj,kk) ! oy location of the w mirror cell
				 !                                 
				 gcwmi = dom(ib)%mwczoldmi(ii,jj,kk) ! dom(ib)%x id of the w mirror cell 
				 gcwmj = dom(ib)%mwczoldmj(ii,jj,kk) ! dom(ib)%y id of the w mirror cell
				 gcwmk = dom(ib)%mwczoldmk(ii,jj,kk) ! dom(ib)%z id of the w mirror cell
				 !
				 !                                 
				 !deltaFUnction
				 vec2(1) = nn   ! nn	! Node nds(1.5)
				 vec2(2) = ib   ! ib 
				 vec2(3) = ll   ! ll
				 vec2(4) = iic  ! id 
				 vec2(5) = jjc  ! jjj
				 vec2(6) = kkk  ! kd !check kkc?
				 vec2(7) = 0   ! flag1
				 vec2(8) = 1    ! 1 ! fieldFlag for selecting u velocity
				 vec3(1) = gcwx !gcwmx !mrx
				 vec3(2) = gcwy !gcwmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
				 vec3(3) = gcwz !gcwmz !mrz
				 !
				 if(interpolationScheme.eq.1)then
					call interpolationF(vec2,vec3,neww)	! also interpolate for pressure
				 elseif(interpolationScheme.eq.2)then
				 	! Bilinear interpolation
				 	if(qF.eq.1) then
				 	   wvec(1) = dom(ib)%w(iic+1,jjc,kkk) ! q11
				 	   wvec(2) = dom(ib)%w(iic+2,jjc,kkk)   ! q21
				 	   wvec(3) = dom(ib)%w(iic+1,jjc,kkk-1)   ! q12
				 	   wvec(4) = dom(ib)%w(iic+2,jjc,kkk-1)	   ! q22
				 	   !
				 	   nx(1) = dom(ib)%xc(iic+1)
				 	   nx(2) = dom(ib)%xc(iic+2)
				 	   nz(1) = dom(ib)%z(kkk)
				 	   nz(2) = dom(ib)%z(kkk-1)
				 	elseif(qF.eq.2) then
				 	   wvec(1) = dom(ib)%w(iic+1,jjc,kkk) ! q11
				 	   wvec(2) = dom(ib)%w(iic+2,jjc,kkk)   ! q21
				 	   wvec(3) = dom(ib)%w(iic+1,jjc,kkk+1)   ! q12
				 	   wvec(4) = dom(ib)%w(iic+2,jjc,kkk+1)	   ! q22
				 	   !
				 	   nx(1) = dom(ib)%xc(iic+1)
				 	   nx(2) = dom(ib)%xc(iic+2)
				 	   nz(1) = dom(ib)%z(kkk)
				 	   nz(2) = dom(ib)%z(kkk+1)
				 	elseif(qF.eq.3) then
				 	   wvec(1) = dom(ib)%w(iic-1,jjc,kkk) ! q11
				 	   wvec(2) = dom(ib)%w(iic-2,jjc,kkk)   ! q21
				 	   wvec(3) = dom(ib)%w(iic-1,jjc,kkk+1)   ! q12
				 	   wvec(4) = dom(ib)%w(iic-2,jjc,kkk+1)	   ! q22
				 	   !
				 	   nx(1) = dom(ib)%xc(iic-1)
				 	   nx(2) = dom(ib)%xc(iic-2)
				 	   nz(1) = dom(ib)%z(kkk)
				 	   nz(2) = dom(ib)%z(kkk+1)
				 	elseif(qF.eq.4) then
				 	   wvec(1) = dom(ib)%w(iic-1,jjc,kkk) ! q11
				 	   wvec(2) = dom(ib)%w(iic-2,jjc,kkk)   ! q21
				 	   wvec(3) = dom(ib)%w(iic-1,jjc,kkk-1)   ! q12
				 	   wvec(4) = dom(ib)%w(iic-2,jjc,kkk-1)	   ! q22
				 	   !
				 	   nx(1) = dom(ib)%xc(iic-1)
				 	   nx(2) = dom(ib)%xc(iic-2)
				 	   nz(1) = dom(ib)%z(kkk)
				 	   nz(2) = dom(ib)%z(kkk-1)
				 	endif
				 	!
				 	neww = bl_cramer(nn,nx,nz,wvec,gcwx,gcwz)
				 	!if ( nn.eq.70 ) then
				 	!	write(6,*) "Mirror w (Bilinear Interpolation: cramer)", nn, mirror_w
				 	!endif
				 	!
				 endif
				 !
				 !
				 !if(qF.eq.1) neww = 0.7*dom(ib)%w(ii+1,jj,kk-1) 
				 !if(qF.eq.2) neww = 0.7*dom(ib)%w(ii+1,jj,kk+1) 
				 !if(qF.eq.3) neww = 0.7*dom(ib)%w(ii-1,jj,kk+1) 
				 !if(qF.eq.4) neww = 0.7*dom(ib)%w(ii-1,jj,kk-1) 
				 !
				 if(qF.eq.1) neww0b = dom(ib)%w(ii+1,jj,kk-1) 
				 if(qF.eq.2) neww0b = dom(ib)%w(ii+1,jj,kk+1) 
				 if(qF.eq.3) neww0b = dom(ib)%w(ii-1,jj,kk+1) 
				 if(qF.eq.4) neww0b = dom(ib)%w(ii-1,jj,kk-1)
				 !
				 neww0 = dom(ib)%woo(ii,jj,kk)
				 !
				 !
				 !debug
				 St_k = ibmSt(M) ! number of station of	the inmmersed body
				 mksPS = ibmStMkrs(M)   ! Markers per station
				 mksEL = ibmMkrsEL(M)   ! markers in exterior layer of each stations
				 nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				 nnStart = 1 + (int(St_k/2.0d00))*mksPS
				 !
				 !
				 if(ll.eq.1) then
				 !dom(ib)%woo(ii,jj,kk) = neww	! -neww0 + 2*W_p	! neww
				 dom(ib)%woo(ii,jj,kk) =0.5*(neww +( -neww0 + 2*W_p ) )	! newu
				 !
				 !debug
				 if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
					write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
					 write(6,*) vec2
					 write(6,*) vec3
					 write(6,*) ii,jj,kk
					  write(6,*) neww0b,neww,dom(ib)%woo(ii,jj,kk)
				 endif
				 !
				 if (gcwmi.eq.0) then
					write(*,*) "In checkEmergingCells gcwmi = 0", nn, iic, kkk
					write(*,*) gcwx, gcwy, gcwz
				 endif
				 if (gcwmj.eq.0) then
					write(*,*) "In checkEmergingCells gcwmj = 0", nn, iic, kkk
					write(*,*) gcwx, gcwy, gcwz
				 endif
				 if (gcwmk.eq.0) then
					write(*,*) "In checkEmergingCells gcwmk = 0", nn, iic, kkk
					write(*,*) gcwx, gcwy, gcwz
				 endif
				 !
				 elseif(ll.eq.2)then
				 dom(ib)%woo(ii,jj,kk) = neww
				 !
				 if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
					write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
					 write(6,*) vec2
					 write(6,*) vec3
					 write(6,*) ii,jj,kk
					 write(6,*) neww0b,dom(ib)%woo(ii,jj,kk)
				 endif
				 !
				 if (ll.eq.2) then
					write(*,*) "Warning Warning Waring w cell with ll = 2", nn, iic, kkk
					write(*,*) gcwx, gcwy, gcwz
				 endif  
				 !
				 if (gcwmi.eq.0) then
					write(*,*) "In checkEmergingCells gcwmi = 0", nn, iic, kkk
					write(*,*) gcwx, gcwy, gcwz
				 endif
				 if (gcwmj.eq.0) then
					write(*,*) "In checkEmergingCells gcwmj = 0", nn, iic, kkk
					write(*,*) gcwx, gcwy, gcwz
				 endif
				 if (gcwmk.eq.0) then
					write(*,*) "In checkEmergingCells gcwmk = 0", nn, iic, kkk
					write(*,*) gcwx, gcwy, gcwz
				 endif
				 !
				 endif
				 !
				 !
				 ! Now lets update the flags
				 dom(ib)%mwczold(ii,jj,kk) = 0 
				 dom(ib)%mwczoldnn(ii,jj,kk) = 0
				 dom(ib)%mwczoldib(ii,jj,kk) = 0
				 dom(ib)%mwczoldll(ii,jj,kk) = 0
				 dom(ib)%mwczoldi(ii,jj,kk)  = 0
				 dom(ib)%mwczoldj(ii,jj,kk)  = 0
				 dom(ib)%mwczoldk(ii,jj,kk)  = 0
				 dom(ib)%mwczoldx(ii,jj,kk)  = 0
				 dom(ib)%mwczoldy(ii,jj,kk)  = 0
				 dom(ib)%mwczoldz(ii,jj,kk)  = 0
				 !
				 dom(ib)%mwczoldmx(ii,jj,kk) = 0
				 dom(ib)%mwczoldmy(ii,jj,kk) = 0
				 dom(ib)%mwczoldmz(ii,jj,kk) = 0
				 !
				 dom(ib)%mwczoldmi(ii,jj,kk) = 0 
				 dom(ib)%mwczoldmj(ii,jj,kk) = 0
				 dom(ib)%mwczoldmk(ii,jj,kk) = 0
				 !
				 !dom(ib)%mwcz(ii,jj,kk) = 0 ! this way the ghostCell Method will not be applied to this cell
				 dom(ib)%mwcznn(ii,jj,kk) = 0
				 dom(ib)%mwczib(ii,jj,kk) = 0
				 dom(ib)%mwczll(ii,jj,kk) = 0
				 dom(ib)%mwczi(ii,jj,kk)  = 0
				 dom(ib)%mwczj(ii,jj,kk)  = 0
				 dom(ib)%mwczk(ii,jj,kk)  = 0
				 dom(ib)%mwczx(ii,jj,kk)  = 0
				 dom(ib)%mwczy(ii,jj,kk)  = 0
				 dom(ib)%mwczz(ii,jj,kk)  = 0
				 !
				 dom(ib)%mwczmx(ii,jj,kk) = 0
				 dom(ib)%mwczmy(ii,jj,kk) = 0
				 dom(ib)%mwczmz(ii,jj,kk) = 0
				 !
				 dom(ib)%mwczmi(ii,jj,kk) = 0 
				 dom(ib)%mwczmj(ii,jj,kk) = 0
				 dom(ib)%mwczmk(ii,jj,kk) = 0
				endif
			 !
			 !
			  endif
			  endif
			  !
			  ! Checking for case 2
			  if(dom(ib)%mwcz(ii,jj,kk).ne.0) then
			  if(dom(ib)%mwczold(ii,jj,kk).eq.0) then
				! we have found a new solid cell (formerly it was a fluid cell)
				! the rest of the info we need has already been saved in the arrays of the familly "mwcz..."
				! this was done in the subroutines "searchCells" and "setMirror_u".
				nn = dom(ib)%mwcznn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 cw_n = cw_n + 1	! adding a new ghost cell to the count
				!
				dom(ib)%mwczold(ii,jj,kk)   = dom(ib)%mwcz(ii,jj,kk)   ! qF for w ghost cells
				dom(ib)%mwczoldnn(ii,jj,kk) = dom(ib)%mwcznn(ii,jj,kk) ! nn for w ghost cells
				dom(ib)%mwczoldib(ii,jj,kk) = dom(ib)%mwczib(ii,jj,kk) ! ib for w ghost cells
				dom(ib)%mwczoldll(ii,jj,kk) = dom(ib)%mwczll(ii,jj,kk) ! ll for w ghost cells
				dom(ib)%mwczoldi(ii,jj,kk)  = dom(ib)%mwczi(ii,jj,kk)  ! %x  id for w ghost cells
				dom(ib)%mwczoldj(ii,jj,kk)  = dom(ib)%mwczj(ii,jj,kk)  ! %yc id for w ghost cells
				dom(ib)%mwczoldk(ii,jj,kk)  = dom(ib)%mwczk(ii,jj,kk)  ! %z  id for w ghost cells
				dom(ib)%mwczoldx(ii,jj,kk)  = dom(ib)%mwczx(ii,jj,kk)  ! %x  for w ghost cells
				dom(ib)%mwczoldy(ii,jj,kk)  = dom(ib)%mwczy(ii,jj,kk)  ! %yc for w ghost cells
				dom(ib)%mwczoldz(ii,jj,kk)  = dom(ib)%mwczz(ii,jj,kk)  ! %z  for w ghost cells
				!
				dom(ib)%mwczoldmi(ii,jj,kk) = dom(ib)%mwczmi(ii,jj,kk) ! %x  id for w mirror cells
				dom(ib)%mwczoldmj(ii,jj,kk) = dom(ib)%mwczmj(ii,jj,kk) ! %yc id for w mirror cells
				dom(ib)%mwczoldmk(ii,jj,kk) = dom(ib)%mwczmk(ii,jj,kk) ! %z  id for w mirror cells
				!
				dom(ib)%mwczoldmx(ii,jj,kk) = dom(ib)%mwczmx(ii,jj,kk) ! %x  for w mirror cells
				dom(ib)%mwczoldmy(ii,jj,kk) = dom(ib)%mwczmy(ii,jj,kk) ! %yc for w mirror cells
				dom(ib)%mwczoldmz(ii,jj,kk) = dom(ib)%mwczmz(ii,jj,kk) ! %z  for w mirror cells
				! the mirror velocity has already been sed in "setMirror_u"
				!
				endif
			  endif
			  endif
			  !
			  endif
			  !
			  ! Checking for case 3
			  if(dom(ib)%mwcz(ii,jj,kk).ne.0)then
			  if(dom(ib)%mwczold(ii,jj,kk).ne.0)then
				! The body has moved and this cell is still inside but we need to update
				! the info for this cell.
				nn = dom(ib)%mwcznn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 cw   = cw + 1	! counting a ghost cell that is still inside the inmersed body
				!
				dom(ib)%mwczold(ii,jj,kk)   = dom(ib)%mwcz(ii,jj,kk)   ! qF for w ghost cells
				dom(ib)%mwczoldnn(ii,jj,kk) = dom(ib)%mwcznn(ii,jj,kk) ! nn for w ghost cells
				dom(ib)%mwczoldib(ii,jj,kk) = dom(ib)%mwczib(ii,jj,kk) ! ib for w ghost cells
				dom(ib)%mwczoldll(ii,jj,kk) = dom(ib)%mwczll(ii,jj,kk) ! ll for w ghost cells
				dom(ib)%mwczoldi(ii,jj,kk)  = dom(ib)%mwczi(ii,jj,kk)  ! %x  id for w ghost cells
				dom(ib)%mwczoldj(ii,jj,kk)  = dom(ib)%mwczj(ii,jj,kk)  ! %yc id for w ghost cells
				dom(ib)%mwczoldk(ii,jj,kk)  = dom(ib)%mwczk(ii,jj,kk)  ! %z  id for w ghost cells
				dom(ib)%mwczoldx(ii,jj,kk)  = dom(ib)%mwczx(ii,jj,kk)  ! %x  for w ghost cells
				dom(ib)%mwczoldy(ii,jj,kk)  = dom(ib)%mwczy(ii,jj,kk)  ! %yc for w ghost cells
				dom(ib)%mwczoldz(ii,jj,kk)  = dom(ib)%mwczz(ii,jj,kk)  ! %z  for w ghost cells
				!
				dom(ib)%mwczoldmi(ii,jj,kk) = dom(ib)%mwczmi(ii,jj,kk) ! %x  id for w mirror cells
				dom(ib)%mwczoldmj(ii,jj,kk) = dom(ib)%mwczmj(ii,jj,kk) ! %yc id for w mirror cells
				dom(ib)%mwczoldmk(ii,jj,kk) = dom(ib)%mwczmk(ii,jj,kk) ! %z  id for w mirror cells
				dom(ib)%mwczoldmx(ii,jj,kk) = dom(ib)%mwczmx(ii,jj,kk) ! %x  for w mirror cells
				dom(ib)%mwczoldmy(ii,jj,kk) = dom(ib)%mwczmy(ii,jj,kk) ! %yc for w mirror cells
				dom(ib)%mwczoldmz(ii,jj,kk) = dom(ib)%mwczmz(ii,jj,kk) ! %z  for w mirror cells
				!
			  	endif
				!
				! CHECK: remove "if mwczold .eq. 0" in setQuadrant_u
				! the mirror velocity has already been sed in "setMirror_u"
			endif
			endif
			  !
		   ! ghost cell treatment for the w velocity field
		   !
		   !
		   if(dom(ib)%mpc(ii,jj,kk).ne.dom(ib)%mpcold(ii,jj,kk))then
		   ! ghost cell treatment for the p pressure field
				! Checking for case 1
				!
				! the flag "mpc(ii,jj,kk)" was reset previously in the sobroutine call searchGhostCells
				if(dom(ib)%mpc(ii,jj,kk).eq.0) then
				if(dom(ib)%mpcold(ii,jj,kk).ne.0) then
				! We have found an emerging cell
				! now we need to update the u velocity of the emerging cell
				! dom(ib)%p(i,j,k) = ...
				nn = dom(ib)%mpcoldnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 cp_e = cp_e + 1	! adding an emerging cell to the count
				 !                                 
				 ll = dom(ib)%mpcoldll(ii,jj,kk)  ! ll    id for layer at which nn marker is located
				 iic = dom(ib)%mpcoldi(ii,jj,kk)  ! iii   ox location of the u ghost cell 
				 jjc = dom(ib)%mpcoldj(ii,jj,kk)  ! jjc   oy location of the u ghost cell
				 kkc = dom(ib)%mpcoldk(ii,jj,kk)  ! kkk   oy location of the u ghost cell, !check kkc?
				 qF = dom(ib)%mpcold(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                 
				 gcpx  = dom(ib)%mpcoldx(ii,jj,kk) ! ox location of the u ghost cell 
				 gcpy  = dom(ib)%mpcoldy(ii,jj,kk) ! oy location of the u ghost cell
				 gcpz  = dom(ib)%mpcoldz(ii,jj,kk) ! oy location of the u ghost cell
				 !                                 
				 gcpmx = dom(ib)%mpcoldmx(ii,jj,kk) ! ox location of the u mirror cell 
				 gcpmy = dom(ib)%mpcoldmy(ii,jj,kk) ! oy location of the u mirror cell
				 gcpmz = dom(ib)%mpcoldmz(ii,jj,kk) ! oy location of the u mirror cell
				 !                                 
				 gcpmi = dom(ib)%mpcoldmi(ii,jj,kk) ! dom(ib)%x id of the u mirror cell 
				 gcpmj = dom(ib)%mpcoldmj(ii,jj,kk) ! dom(ib)%y id of the u mirror cell
				 gcpmk = dom(ib)%mpcoldmk(ii,jj,kk) ! dom(ib)%z id of the u mirror cell
                 !                                 
                 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				 !!! deltaFUnction
				    !vec2(1) = nn   ! nn	! Node nds(1.5)
				    !vec2(2) = ib   ! ib 
				    !vec2(3) = ll   ! ll
				    !vec2(4) = iic  ! id 
				    !vec2(5) = jjc  ! jjj
				    !vec2(6) = kkc  ! kd !check kkc?
				    !vec2(7) = 0   ! flag1
				    !vec2(8) = 1    ! 1 ! fieldFlag for selecting u velocity
				    !vec3(1) = gcpx !gcpmx !mrx
				    !vec3(2) = gcpy !gcpmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
				    !vec3(3) = gcpz !gcpmz !mrz
                    !call interpolationF(vec2,vec3,newp)				! also interpolate for pressure
                 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				 !!! BILINEAR INTERPOLATION
                 if(qF.eq.1) then
                    pvec(1) = dom(ib)%p(iic+1,jjc,kkc) ! q11
                    pvec(2) = dom(ib)%p(iic+2,jjc,kkc)   ! q21
                    pvec(3) = dom(ib)%p(iic+1,jjc,kkc-1)   ! q12
                    pvec(4) = dom(ib)%p(iic+2,jjc,kkc-1)	   ! q22
                    !
                    nx(1) = dom(ib)%xc(iic+1)
                    nx(2) = dom(ib)%xc(iic+2)
                    nz(1) = dom(ib)%zc(kkc)
                    nz(2) = dom(ib)%zc(kkc-1)
                 elseif(qF.eq.2) then
                    pvec(1) = dom(ib)%p(iic+1,jjc,kkc) ! q11
                    pvec(2) = dom(ib)%p(iic+2,jjc,kkc)   ! q21
                    pvec(3) = dom(ib)%p(iic+1,jjc,kkc+1)   ! q12
                    pvec(4) = dom(ib)%p(iic+2,jjc,kkc+1)	   ! q22
                    !
                    nx(1) = dom(ib)%xc(iic+1)
                    nx(2) = dom(ib)%xc(iic+2)
                    nz(1) = dom(ib)%zc(kkc)
                    nz(2) = dom(ib)%zc(kkc+1)
                 elseif(qF.eq.3) then
                    pvec(1) = dom(ib)%p(iic-1,jjc,kkc) ! q11
                    pvec(2) = dom(ib)%p(iic-2,jjc,kkc)   ! q21
                    pvec(3) = dom(ib)%p(iic-1,jjc,kkc+1)   ! q12
                    pvec(4) = dom(ib)%p(iic-2,jjc,kkc+1)	   ! q22
                    !
                    nx(1) = dom(ib)%xc(iic-1)
                    nx(2) = dom(ib)%xc(iic-2)
                    nz(1) = dom(ib)%zc(kkc)
                    nz(2) = dom(ib)%zc(kkc+1)
                 elseif(qF.eq.4) then
                    pvec(1) = dom(ib)%p(iic-1,jjc,kkc) ! q11
                    pvec(2) = dom(ib)%p(iic-2,jjc,kkc)   ! q21
                    pvec(3) = dom(ib)%p(iic-1,jjc,kkc-1)   ! q12
                    pvec(4) = dom(ib)%p(iic-2,jjc,kkc-1)	   ! q22
                    !
                    nx(1) = dom(ib)%xc(iic-1)
                    nx(2) = dom(ib)%xc(iic-2)
                    nz(1) = dom(ib)%zc(kkc)
                    nz(2) = dom(ib)%zc(kkc-1)
				 endif
				 !
                 newp = bl_cramer(nn,nx,nz,pvec,gcpx,gcpz)
				 !if(qF.eq.1) newp = 0.7*dom(ib)%w(ii+1,jj,kk-1) 
				 !if(qF.eq.2) newp = 0.7*dom(ib)%w(ii+1,jj,kk+1) 
				 !if(qF.eq.3) newp = 0.7*dom(ib)%w(ii-1,jj,kk+1) 
				 !if(qF.eq.4) newp = 0.7*dom(ib)%w(ii-1,jj,kk-1) 
				 !
				 if(qF.eq.1) newp0b = dom(ib)%p(ii+1,jj,kk-1) 
				 if(qF.eq.2) newp0b = dom(ib)%p(ii+1,jj,kk+1) 
				 if(qF.eq.3) newp0b = dom(ib)%p(ii-1,jj,kk+1) 
				 if(qF.eq.4) newp0b = dom(ib)%p(ii-1,jj,kk-1)
				 !
				 newp0 = dom(ib)%p(ii,jj,kk) ! value in the previous time step 
				 !
				 !
				 !debug
				 St_k = ibmSt(M) ! number of station of	the inmmersed body
				 mksPS = ibmStMkrs(M)   ! Markers per station
				 mksEL = ibmMkrsEL(M)   ! markers in exterior layer of each stations
				 nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				 nnStart = 1 + (int(St_k/2.0d00))*mksPS
				 !
				 !
				 if(ll.eq.1) then
					dom(ib)%p(ii,jj,kk) = 0.5*(newp+newp0) !newp0
					!
					!debug
					if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
						write(*,*) "mpc____mpc____mpc____mpc____mpc____mpc"
						 !write(6,*) vec2
						 !write(6,*) vec3
						 write(6,*) ii,jj,kk
						  write(6,*) newp0b,newp0,dom(ib)%p(ii,jj,kk)
					endif
					if (gcpmi.eq.0) then
						write(*,*) "In checkEmergingCells gcpmi = 0", nn, iic, kkc
						write(*,*) gcpx, gcpy, gcpz
					 endif
					 if (gcpmj.eq.0) then
						write(*,*) "In checkEmergingCells gcpmj = 0", nn, iic, kkc
						write(*,*) gcpx, gcpy, gcpz
					 endif
					 if (gcpmk.eq.0) then
						write(*,*) "In checkEmergingCells gcpmk = 0", nn, iic, kkc
						write(*,*) gcpx, gcpy, gcpz
					 endif
				 elseif(ll.eq.2) then
					dom(ib)%p(ii,jj,kk) = newp0
					!
					!debug
					if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
						write(*,*) "mpc____mpc____mpc____mpc____mpc____mpc"
						 !write(6,*) vec2
						 !write(6,*) vec3
						 write(6,*) ii,jj,kk
						  write(6,*) newp0b,newp,dom(ib)%p(ii,jj,kk)
					endif
					if (ll.eq.2) then
				write(*,*) "Warning Warning Waring p cell with ll = 2", nn, iic, kkc
						write(*,*) gcpx, gcpy, gcpz
					 endif  
				 endif
				 !
				 !
				 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				 ! v vlocity
				 if(interpolationScheme.eq.1)then
					call interpolationF(vec2,vec3,newv)	! also interpolate for pressure
					!deltaFUnction
					vec2(1) = nn   ! nn	! Node nds(1.5)
					vec2(2) = ib   ! ib 
					vec2(3) = ll   ! ll
					vec2(4) = iic  ! id 
					vec2(5) = jjc  ! jjj
					vec2(6) = kkc  ! kd !check kkc?
					vec2(7) = 0   ! flag1: 0 -> voo, 1 -> vstar, 2 -> v
					vec2(8) = 1    ! 1 ! fieldFlag for selecting u velocity
					vec3(1) = gcpx !gcvmx !mrx
					vec3(2) = gcpy !gcvmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
					vec3(3) = gcpz !gcvmz !mrz
				 elseif(interpolationScheme.eq.2)then
				 	! Bilinear interpolation
				 	if(qF.eq.1) then
				 	   vvec(1) = dom(ib)%v(iic+1,jjc,kkc) ! q11
				 	   vvec(2) = dom(ib)%v(iic+2,jjc,kkc)   ! q21
				 	   vvec(3) = dom(ib)%v(iic+1,jjc,kkc-1)   ! q12
				 	   vvec(4) = dom(ib)%v(iic+2,jjc,kkc-1)	   ! q22
				 	   !
				 	   nx(1) = dom(ib)%xc(iic+1)
				 	   nx(2) = dom(ib)%xc(iic+2)
				 	   nz(1) = dom(ib)%zc(kkc)
				 	   nz(2) = dom(ib)%zc(kkc-1)
				 	elseif(qF.eq.2) then
				 	   vvec(1) = dom(ib)%v(iic+1,jjc,kkc) ! q11
				 	   vvec(2) = dom(ib)%v(iic+2,jjc,kkc)   ! q21
				 	   vvec(3) = dom(ib)%v(iic+1,jjc,kkc+1)   ! q12
				 	   vvec(4) = dom(ib)%v(iic+2,jjc,kkc+1)	   ! q22
				 	   !
				 	   nx(1) = dom(ib)%xc(iic+1)
				 	   nx(2) = dom(ib)%xc(iic+2)
				 	   nz(1) = dom(ib)%zc(kkc)
				 	   nz(2) = dom(ib)%zc(kkc+1)
				 	elseif(qF.eq.3) then
				 	   vvec(1) = dom(ib)%v(iic-1,jjc,kkc) ! q11
				 	   vvec(2) = dom(ib)%v(iic-2,jjc,kkc)   ! q21
				 	   vvec(3) = dom(ib)%v(iic-1,jjc,kkc+1)   ! q12
				 	   vvec(4) = dom(ib)%v(iic-2,jjc,kkc+1)	   ! q22
				 	   !
				 	   nx(1) = dom(ib)%xc(iic-1)
				 	   nx(2) = dom(ib)%xc(iic-2)
				 	   nz(1) = dom(ib)%zc(kkc)
				 	   nz(2) = dom(ib)%zc(kkc+1)
				 	elseif(qF.eq.4) then
				 	   vvec(1) = dom(ib)%v(iic-1,jjc,kkc) ! q11
				 	   vvec(2) = dom(ib)%v(iic-2,jjc,kkc)   ! q21
				 	   vvec(3) = dom(ib)%v(iic-1,jjc,kkc-1)   ! q12
				 	   vvec(4) = dom(ib)%v(iic-2,jjc,kkc-1)	   ! q22
				 	   !
				 	   nx(1) = dom(ib)%xc(iic-1)
				 	   nx(2) = dom(ib)%xc(iic-2)
				 	   nz(1) = dom(ib)%zc(kkc)
				 	   nz(2) = dom(ib)%zc(kkc-1)
				 	endif
				 	!
				 	newv = bl_cramer(nn,nx,nz,vvec,gcpx,gcpz)
				 	!if ( nn.eq.70 ) then
				 	!	vrite(6,*) "Mirror v (Bilinear Interpolation: cramer)", nn, mirror_v
				 	!endif
				 	!
				 endif
				 !
				 !
				 !
				 !if(qF.eq.1) newv = 0.7*dom(ib)%v(ii+1,jj,kk-1) 
				 !if(qF.eq.2) newv = 0.7*dom(ib)%v(ii+1,jj,kk+1) 
				 !if(qF.eq.3) newv = 0.7*dom(ib)%v(ii-1,jj,kk+1) 
				 !if(qF.eq.4) newv = 0.7*dom(ib)%v(ii-1,jj,kk-1) 
				 !
				 if(qF.eq.1) newv0b = dom(ib)%v(ii+1,jj,kk-1) 
				 if(qF.eq.2) newv0b = dom(ib)%v(ii+1,jj,kk+1) 
				 if(qF.eq.3) newv0b = dom(ib)%v(ii-1,jj,kk+1) 
				 if(qF.eq.4) newv0b = dom(ib)%v(ii-1,jj,kk-1)
				 !
				 newv0 = dom(ib)%voo(ii,jj,kk)
				 !
				 !
				 if(ll.eq.1) then
				 !dom(ib)%voo(ii,jj,kk) = newv	! -newv0 + 2*V_p	! newv
				 dom(ib)%voo(ii,jj,kk) =0.5*(newv +( -newv0 + 2*V_p ) )	! newu
				 !
				 elseif(ll.eq.2)then
				 dom(ib)%voo(ii,jj,kk) = newv
				 !
				 !
				 endif
				 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				 !
				 ! Now lets update the flags
				 dom(ib)%mpcold(ii,jj,kk) = 0 
				 dom(ib)%mpcoldnn(ii,jj,kk) = 0
				 dom(ib)%mpcoldib(ii,jj,kk) = 0
				 dom(ib)%mpcoldll(ii,jj,kk) = 0
				 dom(ib)%mpcoldi(ii,jj,kk)  = 0
				 dom(ib)%mpcoldj(ii,jj,kk)  = 0
				 dom(ib)%mpcoldk(ii,jj,kk)  = 0
				 dom(ib)%mpcoldx(ii,jj,kk)  = 0
				 dom(ib)%mpcoldy(ii,jj,kk)  = 0
				 dom(ib)%mpcoldz(ii,jj,kk)  = 0
				 dom(ib)%mpcoldmi(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmj(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmk(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmx(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmy(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmz(ii,jjj,kk) = 0 !CHECK_AAA
				 !
				 dom(ib)%mpcnn(ii,jj,kk) = 0
				 dom(ib)%mpcib(ii,jj,kk) = 0
				 dom(ib)%mpcll(ii,jj,kk) = 0
				 dom(ib)%mpci(ii,jj,kk)  = 0
				 dom(ib)%mpcj(ii,jj,kk)  = 0
				 dom(ib)%mpck(ii,jj,kk)  = 0
				 dom(ib)%mpcx(ii,jj,kk)  = 0
				 dom(ib)%mpcy(ii,jj,kk)  = 0
				 dom(ib)%mpcz(ii,jj,kk)  = 0
				 dom(ib)%mpcmi(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmj(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmk(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmx(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmy(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmz(ii,jjj,kk) = 0 !CHECK_AAA
				endif
			  endif
			  endif
			  !
			  if(dom(ib)%mpc(ii,jj,kk).ne.0) then	! inside
			  if(dom(ib)%mpcold(ii,jj,kk).eq.0) then ! outside
				! Checking for case 2
				!
				! we have found a new solid cell (formerly it was a fluid cell)
				! the rest of the info we need has already been saved in the arrays of the familly "mpc..."
				! this was done in the subroutines "searchCells" and "setMirror_u".
				nn = dom(ib)%mpcnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 cp_n = cp_n + 1	! adding a new ghost cell to the count
				!
				dom(ib)%mpcold(ii,jj,kk)   = dom(ib)%mpc(ii,jj,kk)   ! qF for p ghost cells
				dom(ib)%mpcoldnn(ii,jj,kk) = dom(ib)%mpcnn(ii,jj,kk) ! nn for p ghost cells
				dom(ib)%mpcoldib(ii,jj,kk) = dom(ib)%mpcib(ii,jj,kk) ! ib for p ghost cells
				dom(ib)%mpcoldll(ii,jj,kk) = dom(ib)%mpcll(ii,jj,kk) ! ll for p ghost cells
				dom(ib)%mpcoldi(ii,jj,kk)  = dom(ib)%mpci(ii,jj,kk)  ! %x  id for p ghost cells centre
				dom(ib)%mpcoldj(ii,jj,kk)  = dom(ib)%mpcj(ii,jj,kk)  ! %yc id for p ghost cells centre
				dom(ib)%mpcoldk(ii,jj,kk)  = dom(ib)%mpck(ii,jj,kk)  ! %z  id for p ghost cells centre
				dom(ib)%mpcoldx(ii,jj,kk)  = dom(ib)%mpcx(ii,jj,kk)  ! %x  for p ghost cells centre
				dom(ib)%mpcoldy(ii,jj,kk)  = dom(ib)%mpcy(ii,jj,kk)  ! %yc for p ghost cells centre
				dom(ib)%mpcoldz(ii,jj,kk)  = dom(ib)%mpcz(ii,jj,kk)  ! %z  for p ghost cells centre
				!
				dom(ib)%mpcoldmi(ii,jjj,kk) = dom(ib)%mpcmi(ii,jjj,kk) !%x  id for p mirror point in fluid cell
				dom(ib)%mpcoldmj(ii,jjj,kk) = dom(ib)%mpcmj(ii,jjj,kk) !%yc id for p mirror point in fluid cell
				dom(ib)%mpcoldmk(ii,jjj,kk) = dom(ib)%mpcmk(ii,jjj,kk) !%z  id for p mirror point in fluid cell
				!
				dom(ib)%mpcoldmx(ii,jjj,kk) = dom(ib)%mpcmx(ii,jjj,kk) !%x  location for p mirror point in fluid cell
				dom(ib)%mpcoldmy(ii,jjj,kk) = dom(ib)%mpcmy(ii,jjj,kk) !%yc location for p mirror point in fluid cell
				dom(ib)%mpcoldmz(ii,jjj,kk) = dom(ib)%mpcmz(ii,jjj,kk) !%z  location for p mirror point in fluid cell
				!
				endif
				!
			  endif
			  endif
			  !
			endif
			!
			!
			if(dom(ib)%mpc(ii,jj,kk).ne.0)then	! inside
			if(dom(ib)%mpcold(ii,jj,kk).ne.0)then	! inside
		  	! Case 3
		  	!
		  	! The body has moved and this cell is still inside but we need to update
			  ! the info for this cell.
				nn = dom(ib)%mpcnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
			if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 cp   = cp + 1	! counting a ghost cell that is still inside the inmersed body
			!
		  	dom(ib)%mpcold(ii,jj,kk)   = dom(ib)%mpc(ii,jj,kk)   ! qF for p ghost cells
		  	dom(ib)%mpcoldnn(ii,jj,kk) = dom(ib)%mpcnn(ii,jj,kk) ! nn for p ghost cells
		  	dom(ib)%mpcoldib(ii,jj,kk) = dom(ib)%mpcib(ii,jj,kk) ! ib for p ghost cells
		  	dom(ib)%mpcoldll(ii,jj,kk) = dom(ib)%mpcll(ii,jj,kk) ! ll for p ghost cells
		  	dom(ib)%mpcoldi(ii,jj,kk)  = dom(ib)%mpci(ii,jj,kk)  ! %x  id for p ghost cells centre
		  	dom(ib)%mpcoldj(ii,jj,kk)  = dom(ib)%mpcj(ii,jj,kk)  ! %yc id for p ghost cells centre
		  	dom(ib)%mpcoldk(ii,jj,kk)  = dom(ib)%mpck(ii,jj,kk)  ! %z  id for p ghost cells centre
		  	dom(ib)%mpcoldx(ii,jj,kk)  = dom(ib)%mpcx(ii,jj,kk)  ! %x  for p ghost cells centre
		  	dom(ib)%mpcoldy(ii,jj,kk)  = dom(ib)%mpcy(ii,jj,kk)  ! %yc for p ghost cells centre
		  	dom(ib)%mpcoldz(ii,jj,kk)  = dom(ib)%mpcz(ii,jj,kk)  ! %z  for p ghost cells centre
		  	!
		  	dom(ib)%mpcoldmi(ii,jj,kk) = dom(ib)%mpcmi(ii,jj,kk) ! %x  id for p mirror point in fluid cells
		  	dom(ib)%mpcoldmj(ii,jj,kk) = dom(ib)%mpcmj(ii,jj,kk) ! %yc id for p mirror point in fluid cells
		  	dom(ib)%mpcoldmk(ii,jj,kk) = dom(ib)%mpcmk(ii,jj,kk) ! %z  id for p mirror point in fluid cells
		  	!
		  	dom(ib)%mpcoldmx(ii,jj,kk) = dom(ib)%mpcmx(ii,jj,kk) ! %x  location for p mirror point in fluid cells
		  	dom(ib)%mpcoldmy(ii,jj,kk) = dom(ib)%mpcmy(ii,jj,kk) ! %yc location for p mirror point in fluid cells
		  	dom(ib)%mpcoldmz(ii,jj,kk) = dom(ib)%mpcmz(ii,jj,kk) ! %z  location for p mirror point in fluid cells
		  	!
		  	!
			endif
			!
			endif	
			endif

			  !
	       ! ghost cell treatment for the p pressure field
		   !
		   !
         enddo !i loop
         enddo !j loop
         enddo !k loop
         if(cu_e.gt.1) write(*,*) "Emerging u ghost cells:", cu_e
         if(cu_n.gt.1) write(*,*) "New u ghost cells:", cu_n
	 if(cu.gt.1) write(*,*) "Total number of u ghost cells:", cu
         !
         if(cw_e.gt.1) write(*,*) "Emerging w ghost cells:", cw_e
       	 if(cw_n.gt.1) write(*,*) "New w ghost cells:", cw_n
	 if(cw.gt.1) write(*,*)	"Total number of w ghost cells:", cw
         !
         if(cp_e.gt.1) write(*,*) "Emerging p ghost cells:", cp_e
       	 if(cp_n.gt.1) write(*,*) "New p ghost cells:", cp_n
	 if(cp.gt.1) write(*,*)	"Total number of p ghost cells:", cp
        endif ! Filtering out procesors
	  enddo ! sweeping subdomains

			CONTAINS

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################
!######################################################################	
      END SUBROUTINE checkEmergingCells
!######################################################################	


!######################################################################			
	  !SUBROUTINE searchGhostCells(flag1)
      SUBROUTINE searchGhostCells
!######################################################################	

        use imb
        use mpi
	    use multidata
        use vars
		
        implicit none


	  !INTEGER, INTENT(IN):: flag1
      INTEGER 	:: M,L
	  
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn,mm,ll
	  INTEGER :: iic, jjc, kkc, ii, jj, kk
	  ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! mm :
	  ! nn : index for nodes belonging to the M-th mody
	  INTEGER ::vec0u(8), vec0w(8)
	  !
	  INTEGER :: nnStart, nnFinish, aa, bb
	  INTEGER :: is,ie,js,je,ks,ke
	  INTEGER :: i_n_cells ,j_n_cells,k_n_cells
	  !
	  DOUBLE PRECISION :: cnx,cny,cnz ! Marker coordinates, cn
	  !
	  ! Boundary Margings
	  DOUBLE PRECISION:: dh, margin,dx_l,dy_l,dz_l,swapTemp
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  INTEGER:: layers2Sweep,mksPS
	  INTEGER:: mksEL, St_k
	  !
	  DOUBLE PRECISION, DIMENSION(3) :: vec1 ! vec1: vector linking markers cn and cn2
	  DOUBLE PRECISION:: origin_x, origin_y, origin_z
	  DOUBLE PRECISION:: origin_xc , origin_yc, origin_zc
	  DOUBLE PRECISION, DIMENSION(19):: ndsx,ndsy,ndsz
	  !
	  !Variables for checking subdomain boundaries 
	  INTEGER:: ius,iue,iws,iwe,ips,ipe
	  INTEGER:: jus,jue,jws,jwe,jps,jpe
	  INTEGER:: kus,kue,kws,kwe,kps,kpe
	  !
	  ! Flags
	  INTEGER :: qFlag,flag2, temp

		temp = 0
	do ib = 1, nbp ! lets sweep only the subdomains with makers
	!
	if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
												! markers are located
		dx_l = dom(ib)%dx
		dy_l= dom(ib)%dy
		dz_l= dom(ib)%dz
		dh = (dx_l*dy_l*dz_l)**(1.0D00/3)
		
		margin = 1.0e-9	!1.0e-5	! Margin for searching if arkers are within the boundaries of a cell
		
		origin_x = dom(ib)%x(1)
		origin_y = dom(ib)%y(1)
		origin_z = dom(ib)%z(1)
		
		origin_xc = dom(ib)%xc(1)
		origin_yc = dom(ib)%yc(1)
		origin_zc = dom(ib)%zc(1)

		! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
		ius=dom(ib)%isu; iue=dom(ib)%ieu 
		! ius: starting cell x coordinate index centre of the u grid (not taking into account the ghost cells outside the boundary of the subdomain)
		! iue: ending cell x coordinate index centre of the u grid (not taking into account the ghost cells outside the boundary of the subdomain)
		jus=dom(ib)%jsu; jue=dom(ib)%jeu
		! jus: starting cell y coordinate index centre of the u grid (not taking into account the ghost cells outside the boundary of the subdomain)
		! jue: ending cell y coordinate index centre of the u grid (not taking into account the ghost cells outside the boundary of the subdomain)
		kus=dom(ib)%ksu; kue=dom(ib)%keu
		!
		iws=dom(ib)%isw; iwe=dom(ib)%iew
		jws=dom(ib)%jsw; jwe=dom(ib)%jew
		kws=dom(ib)%ksw; kwe=dom(ib)%kew
		!
		ips=dom(ib)%isp; ipe=dom(ib)%iep
		jps=dom(ib)%jsp; jpe=dom(ib)%jep
		kps=dom(ib)%ksp; kpe=dom(ib)%kep
		
		i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
		j_n_cells = dom(ib)%ttc_j
		k_n_cells = dom(ib)%ttc_k

		!
		! ghost cell method
		! Initiallizing current cell flags for the fluid cells currently inside the inmersed body
          do kk=1,dom(ib)%ttc_k
          do ii=1,dom(ib)%ttc_i
          do jj=1,dom(ib)%ttc_j
             dom(ib)%mucx(ii,jj,kk) = 0
             dom(ib)%mvcy(ii,jj,kk) = 0
             dom(ib)%mwcz(ii,jj,kk) = 0
             dom(ib)%mpc(ii,jj,kk) = 0
          end do
          end do
          end do
		!
        nnStart = 0
        nnFinish = 0

        St_k = ibmSt(bodynum) ! ibmSt(bodynum): global variable known by all processors
		! allocate(ibmSt(bodynum)) 
		! ibmSt : for each postion, it stores the number of stations defined in each body
		! St_k = 0	! counter of the total number of stations
		! do ii = 1, bodynum
		! 	St_k = St_k + ibmSt(ii)
		! enddo
		! allocate(ibmStMkrs(St_k)) ! for each postion jj, it stores the number of markers in station jj for body M
		! ibmStMkrs( (M-1)*ibmSt(M-1) + M*jj ) : number of markers at station jj for body M
		! 
		! ibmStMkrs
	!	mksPS = ibmStMkrs(ibmSt_k)	
		
		
		! St_k = 0	! counter of the total number of stations
		! do ii = 1, bodynum
		! 	St_k = St_k + ibmSt(ii)
		! enddo
		! allocate(ibmMkrsEL(St_k)) ! for each postion jj, it stores the number of markers in the exterior layer in station jj
		! ibmMkrsEL( (M-1)*ibmSt(M-1) + M*jj ) : number of markers at exterior layer in station k for body M
		! 
		! ibmMkrsEL
	!	mksEL = ibmMkrsEL(ibmSt_k)	! array with the size the number of bodies, bodynum
		do mm = 1, St_k	! sweeping stations
		!
		!layers2Sweep = 20
		!
		! ibmStMkrs(ibmSt_k) : global variable known by all processors
		! ibmSt_k:  Total # Stations in the immersed bodies, global variable known by all processors
		mksPS = ibmStMkrs(ibmSt_k)	! Markers per station, for simplicity all sections have the same number of markers and we just
									! define this variale with the number of markers in the las section
		!
		! ibmMkrsEL(ibmSt_k) : global variable known by all processors
		mksEL = ibmMkrsEL(ibmSt_k)	! markers in exterior layer of each stations, for simplicity all sections have the same number of markers 
									! in the outermost ayer and we just define this variale 
									! with the value for the las section
		!
		nnFinish = mksEL + (mm-1)*mksPS
		nnStart = 1 + (mm-1)*mksPS
		!
		!
		!
		!
		! ghost cell method
		! Initiallizing current cell flags for the fluid cells currently inside the inmersed body
		! debug
		!write(*,*) "ready",mm, dom(ib)%mucxold(94,11,127)
		!write(*,*) dom(ib)%ttc_i,dom(ib)%ttc_j,dom(ib)%ttc_k
          !do kk=1,dom(ib)%ttc_k
          !do ii=1,dom(ib)%ttc_i
          !do jj=1,dom(ib)%ttc_j
		  !   dom(ib)%mucxold(ii,jj,kk) = 0
		  !   ! debug
		  !   !if((ii.eq.94).and.(jj.eq.11).and.(kk.eq.127))then
		  !   !write(*,*) "Set	",dom(ib)%mucxold(ii,jj,kk)
		  !   !endif
          !   !dom(ib)%mvcyold(ii,jj,kk) = 0
          !   dom(ib)%mwczold(ii,jj,kk) = 0
          !   dom(ib)%mpcold(ii,jj,kk) = 0
          !end do
          !end do
          !end do
		! debug
		!  if(dom(ib)%mucxold(94,11,127).ne.0) then
		!	write(*,*) "WARNING WARNING WARNING", dom(ib)%mucxold(94,11,127)
		!  endif
		!  write(*,*) "========================", dom(ib)%mucxold(94,11,127)
		!
		
		!
		ll = 2
		do nn = nnStart, nnFinish	!  sweeping markers outermost layer of each station
		 IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
			!
			ll = 1
			!
			!
			ndsx(1) = nodex_loc(nn) ! nodex_loc : x coordinate for markers / ib points, global variable known by all processors
			ndsy(1) = nodey_loc(nn) ! nodey_loc : y coordinate for markers / ib points, global variable known by all processors
			ndsz(1) = nodez_loc(nn) ! nodez_loc : z coordinate for markers / ib points, global variable known by all processors
			!
			!x
			iii = int ( ( ndsx(1) - origin_x - margin) /dx_l) + 2 
			!
			!x
			jjc = int ( ( ndsy(1) - origin_yc - margin) /dy_l) + 2
			!
			!x
			kkk = int ( ( ndsz(1) - origin_z - margin) /dz_l) + 2	! aka kkkn check note 1
			!
			!x
			iic = int ( ( ndsx(1) - origin_xc - margin) /dx_l) + 2 
			!
			!x
			kkc = int ( ( ndsz(1) - origin_zc - margin) /dz_l) + 2
!Note 1: It makes more sense to work with kkkn in u cells because it gives you the same kkc index for the cell centre of the cell
! that the marker mkz occupies.
! kkc		1		2		3		4		5
! c		0.7		1.7		2.7		3.7		4.7
!
! kkk		1		2		3		4		5
! F			1.2		2.2		3.2		4.2		5.2
!
! OZF	1.2
! OZC	0.7
! dz 	1.0
!
!	mkz		0.8		1.3		1.8		2.3
! 	kkks									0		1		1		2
!	kkcs	1		1		2		2
!
!	kkkn	1		2		2		3
!	kkcn	2		2		3		3
			!
			bb = mksEL + (int(St_k/2.0d00))*mksPS
			aa = 1 + (int(St_k/2.0d00))*mksPS
			!
			if((bc_s.eq.5).and.(bc_n.eq.5))then
				if (jjc .lt. 1) then
					if( (nn.ge.aa).and.(nn.le.bb) ) then
					write(6,*) "Warning jjc .lt. 1 !!",nn,jjc
					endif
					jjc = 1
				endif
				if (jjc .gt. dom(ib)%ttc_j) then
					if( (nn.ge.aa).and.(nn.le.bb) ) then
					write(6,*) "Warning jjc .gt. ttc_j !!",nn,jjc,dom(ib)%ttc_j
					endif
					jjc = dom(ib)%ttc_j
				endif
			else
				if (jjc .lt. jps) then
					if( (nn.ge.aa).and.(nn.le.bb) ) then
					write(6,*) "Warning jjc .lt. jus !!",nn,jjc,jps
					endif
					jjc = jps
				endif
				if (jjc .gt. jpe) then
					if( (nn.ge.aa).and.(nn.le.bb) ) then
					write(6,*) "Warning jjc .gt. jue !!",nn,jjc,jpe
					endif
					jjc = jpe
				endif
			endif
			!
			! Checking iii
			if (iii.lt.ius) then
				if( (nn.ge.aa).and.(nn.le.bb) ) then
				write(6,*) "Warning iii.lt.ius !!",nn,iii,ius
				endif
				!!!aaa iii = ius
			endif
			if (iii.gt.iue) then
				if( (nn.ge.aa).and.(nn.le.bb) ) then
				write(6,*) "Warning iii.gt.iue !!",nn,iii,iue
				endif
				!!!aaa iii = iue
			endif
			!
			! Checking iic
			if( iic.lt.ips) then
				if( (nn.ge.aa).and.(nn.le.bb) ) then
				write(6,*) "Warning iic.lt.ips !!",nn,iic,ips
				endif
				!!!aaa iic = ips
			endif
			if( iic.gt.ipe) then
				if( (nn.ge.aa).and.(nn.le.bb) ) then
				write(6,*) "Warning iic.gt.ipe !!",nn,iic,ipe
				endif
				!!!aaa iic = ipe
			endif
			!
			! Checking kkk
			if (kkk.lt.kws) then
				if( (nn.ge.aa).and.(nn.le.bb) ) then
				write(6,*) "Warning kkk.lt.kws !!",nn,kkk,kws
				endif
				!!!aaa kkk = kws
			endif
			if (kkk.gt.kwe) then
				if( (nn.ge.aa).and.(nn.le.bb) ) then
				write(6,*) "Warning kkk.gt.kwe !!",nn,kkk,kwe
				endif
				!!!aaa kkk = kwe
			endif
			!
			! Checking kkc
			if( kkc.lt.ips) then
				if( (nn.ge.aa).and.(nn.le.bb) ) then
				write(6,*) "Warning kkc.lt.ips !!",nn,kkc,ips
				endif
				!!!aaa kkc = ips
			endif
			if( kkc.gt.ipe) then
				if( (nn.ge.aa).and.(nn.le.bb) ) then
				write(6,*) "Warning kkc.gt.ipe !!",nn,kkc,ipe
				endif
				!!!aaa kkc = ipe
			endif
			!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Checking bounding box for u cell
			if((dom(ib)%x(iii-1)-margin).gt.ndsx(1)) then
				write(6,*) "Warning 1, bounding box too forward !!"
		write(6,*) iii-1, abs(dom(ib)%x(iii-1)-margin),ndsx(1)
			endif
			if((dom(ib)%x(iii)+margin).lt.ndsx(1)) then
				 write(6,*)  "Warning 2, bounding box too behind !!"
			write(6,*) iii, abs(dom(ib)%x(iii-1)-margin),ndsx(1)
			endif
			if((dom(ib)%zc(kkc-1)-margin).gt.ndsz(1)) then
				write(6,*) "Warning 3, bounding box too high !!"
		write(6,*) kkc-1, abs(dom(ib)%zc(kkc-1)-margin),ndsz(1)
			endif
			if((dom(ib)%zc(kkc)+margin).lt.ndsz(1)) then
				write(6,*) "Warning 4, bounding box too low !!"
			write(6,*) kkc, abs(dom(ib)%zc(kkc-1)-margin),ndsz(1)
			endif
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Checking bounding box for w cell
			if((dom(ib)%xc(iic-1)-margin).gt.ndsx(1)) then
				write(6,*) "Warning 11, bounding box too forward !!"
		write(6,*) iic-1,abs(dom(ib)%xc(iic-1)-margin),ndsx(1)
			endif
			if((dom(ib)%xc(iic)+margin).lt.ndsx(1)) then
				 write(6,*)  "Warning 22, bounding box too behind !!"
			write(6,*) iic,abs(dom(ib)%xc(iic-1)-margin),ndsx(1)
			endif
			if((dom(ib)%z(kkk-1)-margin).gt.ndsz(1)) then
				write(6,*) "Warning 33, bounding box too high !!"
		write(6,*) kkk-1, abs(dom(ib)%z(kkk-1)-margin),ndsz(1)
			endif
			if((dom(ib)%z(kkk)+margin).lt.ndsz(1)) then
				write(6,*) "Warning 44, bounding box too low !!"
			write(6,*) kkk, abs(dom(ib)%z(kkk-1)-margin),ndsz(1)
			endif
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Checking bounding box for p cell
			if((dom(ib)%xc(iic-1)-margin).gt.ndsx(1)) then
				write(6,*) "Warning 111, bounding box too forward !!"
		write(6,*) iic-1,abs(dom(ib)%xc(iic-1)-margin),ndsx(1)
			endif
			if((dom(ib)%xc(iic)+margin).lt.ndsx(1)) then
				 write(6,*)  "Warning 222, bounding box too behind !!"
			write(6,*) iic,abs(dom(ib)%xc(iic-1)-margin),ndsx(1)
			endif
			if((dom(ib)%zc(kkc-1)-margin).gt.ndsz(1)) then
				write(6,*) "Warning 333, bounding box too high !!"
		write(6,*) kkc-1, abs(dom(ib)%zc(kkc-1)-margin),ndsz(1)
			endif
			if((dom(ib)%zc(kkc)+margin).lt.ndsz(1)) then
				write(6,*) "Warning 444, bounding box too low !!"
			write(6,*) kkc, abs(dom(ib)%zc(kkc-1)-margin),ndsz(1)
			endif
			!
			!
			! Extrancting coordinates of the neighbouring markers from the same layer
			if (nn .eq. nnStart) then
				! Coordinates of the next marker, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nnFinish)
				ndsy(3) = nodey_loc(nnFinish)
				ndsz(3) = nodez_loc(nnFinish)
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nnFinish-1)
				ndsy(5) = nodey_loc(nnFinish-1)
				ndsz(5) = nodez_loc(nnFinish-1)
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nnFinish-2)
				ndsy(7) = nodey_loc(nnFinish-2)
				ndsz(7) = nodez_loc(nnFinish-2)
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nnFinish-3)
				ndsy(9) = nodey_loc(nnFinish-3)
				ndsz(9) = nodez_loc(nnFinish-3)
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nnFinish-4)
				ndsy(11) = nodey_loc(nnFinish-4)
				ndsz(11) = nodez_loc(nnFinish-4)
				! Coordinates of second previous marker, cn12
				ndsx(12) = nodex_loc(nn+6)
				ndsy(12) = nodey_loc(nn+6)
				ndsz(12) = nodez_loc(nn+6)	
				! Coordinates of second previous marker, cn13
				ndsx(13) = nodex_loc(nnFinish-5)
				ndsy(13) = nodey_loc(nnFinish-5)
				ndsz(13) = nodez_loc(nnFinish-5)
				! Coordinates of second previous marker, cn14
				ndsx(14) = nodex_loc(nn+7)
				ndsy(14) = nodey_loc(nn+7)
				ndsz(14) = nodez_loc(nn+7)
				! Coordinates of second previous marker, cn15
				ndsx(15) = nodex_loc(nnFinish-6)
				ndsy(15) = nodey_loc(nnFinish-6)
				ndsz(15) = nodez_loc(nnFinish-6)
				! Coordinates of second previous marker, cn16
                ndsx(16) = nodex_loc(nn+8)
                ndsy(16) = nodey_loc(nn+8)
                ndsz(16) = nodez_loc(nn+8)
                ! Coordinates of second previous marker, cn17
                ndsx(17) = nodex_loc(nnFinish-7)
                ndsy(17) = nodey_loc(nnFinish-7)
                ndsz(17) = nodez_loc(nnFinish-7)
				! Coordinates of second previous marker, cn18
                ndsx(18) = nodex_loc(nn+9)
                ndsy(18) = nodey_loc(nn+9)
                ndsz(18) = nodez_loc(nn+9)
                ! Coordinates of second previous marker, cn19
                ndsx(19) = nodex_loc(nnFinish-8)
                ndsy(19) = nodey_loc(nnFinish-8)
                ndsz(19) = nodez_loc(nnFinish-8)

			elseif ( nn .eq. nnFinish) then
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nnStart)
				ndsy(2) = nodey_loc(nnStart)
				ndsz(2) = nodez_loc(nnStart)
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nnStart+1)
				ndsy(4) = nodey_loc(nnStart+1)
				ndsz(4) = nodez_loc(nnStart+1)
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)		
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nnStart+2)
				ndsy(6) = nodey_loc(nnStart+2)
				ndsz(6) = nodez_loc(nnStart+2)	
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nnStart+3)
				ndsy(8) = nodey_loc(nnStart+3)
				ndsz(8) = nodez_loc(nnStart+3)	
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nnStart+4)
				ndsy(10) = nodey_loc(nnStart+4)
				ndsz(10) = nodez_loc(nnStart+4)
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)
				! Coordinates of second previous marker, cn12
				ndsx(12) = nodex_loc(nnStart+5)
				ndsy(12) = nodey_loc(nnStart+5)
				ndsz(12) = nodez_loc(nnStart+5)	
				! Coordinates of second previous marker, cn13
				ndsx(13) = nodex_loc(nn-6)
				ndsy(13) = nodey_loc(nn-6)
				ndsz(13) = nodez_loc(nn-6)
				! Coordinates of second previous marker, cn14
				ndsx(14) = nodex_loc(nnStart+6)
				ndsy(14) = nodey_loc(nnStart+6)
				ndsz(14) = nodez_loc(nnStart+6)
				! Coordinates of second previous marker, cn15
				ndsx(15) = nodex_loc(nn-7)
				ndsy(15) = nodey_loc(nn-7)
				ndsz(15) = nodez_loc(nn-7)
				! Coordinates of second previous marker, cn16
                ndsx(16) = nodex_loc(nnStart+7)
                ndsy(16) = nodey_loc(nnStart+7)
                ndsz(16) = nodez_loc(nnStart+7)
                ! Coordinates of second previous marker, cn17
                ndsx(17) = nodex_loc(nn-8)
                ndsy(17) = nodey_loc(nn-8)
                ndsz(17) = nodez_loc(nn-8)
				! Coordinates of second previous marker, cn18
                ndsx(18) = nodex_loc(nnStart+8)
                ndsy(18) = nodey_loc(nnStart+8)
                ndsz(18) = nodez_loc(nnStart+8)
                ! Coordinates of second previous marker, cn19
                ndsx(19) = nodex_loc(nn-9)
                ndsy(19) = nodey_loc(nn-9)
                ndsz(19) = nodez_loc(nn-9)

			elseif (nn .eq. nnStart+1) then			
				! Coordinates of the next marker, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nnStart)
				ndsy(3) = nodey_loc(nnStart)
				ndsz(3) = nodez_loc(nnStart)
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nnFinish)
				ndsy(5) = nodey_loc(nnFinish)
				ndsz(5) = nodez_loc(nnFinish)
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nnFinish-1)
				ndsy(7) = nodey_loc(nnFinish-1)
				ndsz(7) = nodez_loc(nnFinish-1)
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nnFinish-2)
				ndsy(9) = nodey_loc(nnFinish-2)
				ndsz(9) = nodez_loc(nnFinish-2)
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nnFinish-3)
				ndsy(11) = nodey_loc(nnFinish-3)
				ndsz(11) = nodez_loc(nnFinish-3)
				! Coordinates of second previous marker, cn12
				ndsx(12) = nodex_loc(nn+6)
				ndsy(12) = nodey_loc(nn+6)
				ndsz(12) = nodez_loc(nn+6)	
				! Coordinates of second previous marker, cn13
				ndsx(13) = nodex_loc(nnFinish-4)
				ndsy(13) = nodey_loc(nnFinish-4)
				ndsz(13) = nodez_loc(nnFinish-4)
				! Coordinates of second previous marker, cn14
				ndsx(14) = nodex_loc(nn+7)
				ndsy(14) = nodey_loc(nn+7)
				ndsz(14) = nodez_loc(nn+7)
				! Coordinates of second previous marker, cn15
				ndsx(15) = nodex_loc(nnFinish-5)
				ndsy(15) = nodey_loc(nnFinish-5)
				ndsz(15) = nodez_loc(nnFinish-5)
				! Coordinates of second previous marker, cn16
                ndsx(16) = nodex_loc(nn+8)
                ndsy(16) = nodey_loc(nn+8)
                ndsz(16) = nodez_loc(nn+8)
                ! Coordinates of second previous marker, cn17
                ndsx(17) = nodex_loc(nnFinish-6)
                ndsy(17) = nodey_loc(nnFinish-6)
                ndsz(17) = nodez_loc(nnFinish-6)
				! Coordinates of second previous marker, cn18
                ndsx(18) = nodex_loc(nn+9)
                ndsy(18) = nodey_loc(nn+9)
                ndsz(18) = nodez_loc(nn+9)
                ! Coordinates of second previous marker, cn19
                ndsx(19) = nodex_loc(nnFinish-7)
                ndsy(19) = nodey_loc(nnFinish-7)
                ndsz(19) = nodez_loc(nnFinish-7)

			elseif ( nn .eq. nnFinish-1) then
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nnFinish)
				ndsy(2) = nodey_loc(nnFinish)
				ndsz(2) = nodez_loc(nnFinish)
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nnStart)
				ndsy(4) = nodey_loc(nnStart)
				ndsz(4) = nodez_loc(nnStart)
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nnStart+1)
				ndsy(6) = nodey_loc(nnStart+1)
				ndsz(6) = nodez_loc(nnStart+1)	
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nnStart+2)
				ndsy(8) = nodey_loc(nnStart+2)
				ndsz(8) = nodez_loc(nnStart+2)	
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nnStart+3)
				ndsy(10) = nodey_loc(nnStart+3)
				ndsz(10) = nodez_loc(nnStart+3)
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)
				! Coordinates of second previous marker, cn12
				ndsx(12) = nodex_loc(nnStart+4)
				ndsy(12) = nodey_loc(nnStart+4)
				ndsz(12) = nodez_loc(nnStart+4)	
				! Coordinates of second previous marker, cn13
				ndsx(13) = nodex_loc(nn-6)
				ndsy(13) = nodey_loc(nn-6)
				ndsz(13) = nodez_loc(nn-6)
				! Coordinates of second previous marker, cn14
				ndsx(14) = nodex_loc(nnStart+5)
				ndsy(14) = nodey_loc(nnStart+5)
				ndsz(14) = nodez_loc(nnStart+5)
				! Coordinates of second previous marker, cn15
				ndsx(15) = nodex_loc(nn-7)
				ndsy(15) = nodey_loc(nn-7)
				ndsz(15) = nodez_loc(nn-7)
				! Coordinates of second previous marker, cn16
                ndsx(16) = nodex_loc(nnStart+6)
                ndsy(16) = nodey_loc(nnStart+6)
                ndsz(16) = nodez_loc(nnStart+6)
                ! Coordinates of second previous marker, cn17
                ndsx(17) = nodex_loc(nn-8)
                ndsy(17) = nodey_loc(nn-8)
                ndsz(17) = nodez_loc(nn-8)
				! Coordinates of second previous marker, cn18
                ndsx(18) = nodex_loc(nnStart+7)
                ndsy(18) = nodey_loc(nnStart+7)
                ndsz(18) = nodez_loc(nnStart+7)
                ! Coordinates of second previous marker, cn19
                ndsx(19) = nodex_loc(nn-9)
                ndsy(19) = nodey_loc(nn-9)
                ndsz(19) = nodez_loc(nn-9)

			elseif (nn .eq. nnStart+2) then
				! Coordinates of the next marker, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nnStart+1)
				ndsy(3) = nodey_loc(nnStart+1)
				ndsz(3) = nodez_loc(nnStart+1)
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nnStart)
				ndsy(5) = nodey_loc(nnStart)
				ndsz(5) = nodez_loc(nnStart)
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nnFinish)
				ndsy(7) = nodey_loc(nnFinish)
				ndsz(7) = nodez_loc(nnFinish)
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nnFinish-1)
				ndsy(9) = nodey_loc(nnFinish-1)
				ndsz(9) = nodez_loc(nnFinish-1)
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nnFinish-2)
				ndsy(11) = nodey_loc(nnFinish-2)
				ndsz(11) = nodez_loc(nnFinish-2)
				! Coordinates of second previous marker, cn12
				ndsx(12) = nodex_loc(nn+6)
				ndsy(12) = nodey_loc(nn+6)
				ndsz(12) = nodez_loc(nn+6)	
				! Coordinates of second previous marker, cn13
				ndsx(13) = nodex_loc(nnFinish-3)
				ndsy(13) = nodey_loc(nnFinish-3)
				ndsz(13) = nodez_loc(nnFinish-3)
				! Coordinates of second previous marker, cn14
				ndsx(14) = nodex_loc(nn+7)
				ndsy(14) = nodey_loc(nn+7)
				ndsz(14) = nodez_loc(nn+7)
				! Coordinates of second previous marker, cn15
				ndsx(15) = nodex_loc(nnFinish-4)
				ndsy(15) = nodey_loc(nnFinish-4)
				ndsz(15) = nodez_loc(nnFinish-4)
				! Coordinates of second previous marker, cn16
                ndsx(16) = nodex_loc(nn+8)
                ndsy(16) = nodey_loc(nn+8)
                ndsz(16) = nodez_loc(nn+8)
                ! Coordinates of second previous marker, cn17
                ndsx(17) = nodex_loc(nnFinish-5)
                ndsy(17) = nodey_loc(nnFinish-5)
                ndsz(17) = nodez_loc(nnFinish-5)
				! Coordinates of second previous marker, cn18
                ndsx(18) = nodex_loc(nn+9)
                ndsy(18) = nodey_loc(nn+9)
                ndsz(18) = nodez_loc(nn+9)
                ! Coordinates of second previous marker, cn19
                ndsx(19) = nodex_loc(nnFinish-6)
                ndsy(19) = nodey_loc(nnFinish-6)
                ndsz(19) = nodez_loc(nnFinish-6)
                
			elseif ( nn .eq. nnFinish-2) then
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nnFinish-1)
				ndsy(2) = nodey_loc(nnFinish-1)
				ndsz(2) = nodez_loc(nnFinish-1)
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nnFinish)
				ndsy(4) = nodey_loc(nnFinish)
				ndsz(4) = nodez_loc(nnFinish)
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nnStart)
				ndsy(6) = nodey_loc(nnStart)
				ndsz(6) = nodez_loc(nnStart)	
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nnStart+1)
				ndsy(8) = nodey_loc(nnStart+1)
				ndsz(8) = nodez_loc(nnStart+1)	
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nnStart+2)
				ndsy(10) = nodey_loc(nnStart+2)
				ndsz(10) = nodez_loc(nnStart+2)
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)                                            
				! Coordinates of second previous marker, cn12
				ndsx(12) = nodex_loc(nnStart+3)
				ndsy(12) = nodey_loc(nnStart+3)
				ndsz(12) = nodez_loc(nnStart+3)	
				! Coordinates of second previous marker, cn13
				ndsx(13) = nodex_loc(nn-6)
				ndsy(13) = nodey_loc(nn-6)
				ndsz(13) = nodez_loc(nn-6)
				! Coordinates of second previous marker, cn14
				ndsx(14) = nodex_loc(nnStart+4)
				ndsy(14) = nodey_loc(nnStart+4)
				ndsz(14) = nodez_loc(nnStart+4)
				! Coordinates of second previous marker, cn15
				ndsx(15) = nodex_loc(nn-7)
				ndsy(15) = nodey_loc(nn-7)
				ndsz(15) = nodez_loc(nn-7)
				! Coordinates of second previous marker, cn16
                ndsx(16) = nodex_loc(nnStart+5)
                ndsy(16) = nodey_loc(nnStart+5)
                ndsz(16) = nodez_loc(nnStart+5)
                ! Coordinates of second previous marker, cn17
                ndsx(17) = nodex_loc(nn-8)
                ndsy(17) = nodey_loc(nn-8)
                ndsz(17) = nodez_loc(nn-8)
				! Coordinates of second previous marker, cn18
                ndsx(18) = nodex_loc(nnStart+6)
                ndsy(18) = nodey_loc(nnStart+6)
                ndsz(18) = nodez_loc(nnStart+6)
                ! Coordinates of second previous marker, cn19
                ndsx(19) = nodex_loc(nn-9)
                ndsy(19) = nodey_loc(nn-9)
                ndsz(19) = nodez_loc(nn-9)

			elseif (nn .eq. nnStart+3) then
					! Coordinates of the next marker, cn2
					ndsx(2) = nodex_loc(nn+1)
					ndsy(2) = nodey_loc(nn+1)
					ndsz(2) = nodez_loc(nn+1)
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nnStart+2)
					ndsy(3) = nodey_loc(nnStart+2)
					ndsz(3) = nodez_loc(nnStart+2)
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nn+2)
					ndsy(4) = nodey_loc(nn+2)
					ndsz(4) = nodez_loc(nn+2)
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nnStart+1)
					ndsy(5) = nodey_loc(nnStart+1)
					ndsz(5) = nodez_loc(nnStart+1)
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nn+3)
					ndsy(6) = nodey_loc(nn+3)
					ndsz(6) = nodez_loc(nn+3)	
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nnStart)
					ndsy(7) = nodey_loc(nnStart)
					ndsz(7) = nodez_loc(nnStart)
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nn+4)
					ndsy(8) = nodey_loc(nn+4)
					ndsz(8) = nodez_loc(nn+4)	
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nnFinish)
					ndsy(9) = nodey_loc(nnFinish)
					ndsz(9) = nodez_loc(nnFinish)
					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nn+5)
					ndsy(10) = nodey_loc(nn+5)
					ndsz(10) = nodez_loc(nn+5)
					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nnFinish-1)
					ndsy(11) = nodey_loc(nnFinish-1)
					ndsz(11) = nodez_loc(nnFinish-1)
				    ! Coordinates of second previous marker, cn12
                    ndsx(12) = nodex_loc(nn+6)
                    ndsy(12) = nodey_loc(nn+6)
                    ndsz(12) = nodez_loc(nn+6)	
                    ! Coordinates of second previous marker, cn13
                    ndsx(13) = nodex_loc(nnFinish-2)
                    ndsy(13) = nodey_loc(nnFinish-2)
                    ndsz(13) = nodez_loc(nnFinish-2)
                    ! Coordinates of second previous marker, cn14
                    ndsx(14) = nodex_loc(nn+7)
                    ndsy(14) = nodey_loc(nn+7)
                    ndsz(14) = nodez_loc(nn+7)
                    ! Coordinates of second previous marker, cn15
                    ndsx(15) = nodex_loc(nnFinish-3)
                    ndsy(15) = nodey_loc(nnFinish-3)
                    ndsz(15) = nodez_loc(nnFinish-3)
				    ! Coordinates of second previous marker, cn16
                    ndsx(16) = nodex_loc(nn+8)
                    ndsy(16) = nodey_loc(nn+8)
                    ndsz(16) = nodez_loc(nn+8)
                    ! Coordinates of second previous marker, cn17
                    ndsx(17) = nodex_loc(nnFinish-4)
                    ndsy(17) = nodey_loc(nnFinish-4)
                    ndsz(17) = nodez_loc(nnFinish-4)
				    ! Coordinates of second previous marker, cn18
                    ndsx(18) = nodex_loc(nn+9)
                    ndsy(18) = nodey_loc(nn+9)
                    ndsz(18) = nodez_loc(nn+9)
                    ! Coordinates of second previous marker, cn19
                    ndsx(19) = nodex_loc(nnFinish-5)
                    ndsy(19) = nodey_loc(nnFinish-5)
                    ndsz(19) = nodez_loc(nnFinish-5)

				elseif ( nn .eq. nnFinish-3) then
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-2)
					ndsy(2) = nodey_loc(nnFinish-2)
					ndsz(2) = nodez_loc(nnFinish-2)
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-1)
					ndsy(4) = nodey_loc(nnFinish-1)
					ndsz(4) = nodez_loc(nnFinish-1)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish)
					ndsy(6) = nodey_loc(nnFinish)
					ndsz(6) = nodez_loc(nnFinish)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnStart)
					ndsy(8) = nodey_loc(nnStart)
					ndsz(8) = nodez_loc(nnStart)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnStart+1)
					ndsy(10) = nodey_loc(nnStart+1)
					ndsz(10) = nodez_loc(nnStart+1)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)
					
				    ! Coordinates of second previous marker, cn12
				    ndsx(12) = nodex_loc(nnStart+2)
				    ndsy(12) = nodey_loc(nnStart+2)
				    ndsz(12) = nodez_loc(nnStart+2)	
				    ! Coordinates of second previous marker, cn13
				    ndsx(13) = nodex_loc(nn-6)
				    ndsy(13) = nodey_loc(nn-6)
				    ndsz(13) = nodez_loc(nn-6)
				    ! Coordinates of second previous marker, cn14
				    ndsx(14) = nodex_loc(nnStart+3)
				    ndsy(14) = nodey_loc(nnStart+3)
				    ndsz(14) = nodez_loc(nnStart+3)
				    ! Coordinates of second previous marker, cn15
				    ndsx(15) = nodex_loc(nn-7)
				    ndsy(15) = nodey_loc(nn-7)
				    ndsz(15) = nodez_loc(nn-7)

				    ! Coordinates of second previous marker, cn16
                    ndsx(16) = nodex_loc(nnStart+4)
                    ndsy(16) = nodey_loc(nnStart+4)
                    ndsz(16) = nodez_loc(nnStart+4)
                    
                    ! Coordinates of second previous marker, cn17
                    ndsx(17) = nodex_loc(nn-8)
                    ndsy(17) = nodey_loc(nn-8)
                    ndsz(17) = nodez_loc(nn-8)

				    ! Coordinates of second previous marker, cn18
				    ndsx(18) = nodex_loc(nnStart+5)
				    ndsy(18) = nodey_loc(nnStart+5)
				    ndsz(18) = nodez_loc(nnStart+5)
                    
				    ! Coordinates of second previous marker, cn19
				    ndsx(19) = nodex_loc(nn-9)
				    ndsy(19) = nodey_loc(nn-9)
				    ndsz(19) = nodez_loc(nn-9)

				elseif (nn .eq. nnStart+4) then
			
					! Coordinates of the next marker, cn2
					ndsx(2) = nodex_loc(nn+1)
					ndsy(2) = nodey_loc(nn+1)
					ndsz(2) = nodez_loc(nn+1)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nnStart+3)
					ndsy(3) = nodey_loc(nnStart+3)
					ndsz(3) = nodez_loc(nnStart+3)
					
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nn+2)
					ndsy(4) = nodey_loc(nn+2)
					ndsz(4) = nodez_loc(nn+2)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nnStart+2)
					ndsy(5) = nodey_loc(nnStart+2)
					ndsz(5) = nodez_loc(nnStart+2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nn+3)
					ndsy(6) = nodey_loc(nn+3)
					ndsz(6) = nodez_loc(nn+3)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nnStart+1)
					ndsy(7) = nodey_loc(nnStart+1)
					ndsz(7) = nodez_loc(nnStart+1)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nn+4)
					ndsy(8) = nodey_loc(nn+4)
					ndsz(8) = nodez_loc(nn+4)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nnStart)
					ndsy(9) = nodey_loc(nnStart)
					ndsz(9) = nodez_loc(nnStart)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nn+5)
					ndsy(10) = nodey_loc(nn+5)
					ndsz(10) = nodez_loc(nn+5)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nnFinish)
					ndsy(11) = nodey_loc(nnFinish)
					ndsz(11) = nodez_loc(nnFinish)

				    ! Coordinates of second previous marker, cn12
                    ndsx(12) = nodex_loc(nn+6)
                    ndsy(12) = nodey_loc(nn+6)
                    ndsz(12) = nodez_loc(nn+6)	
                
                    ! Coordinates of second previous marker, cn13
                    ndsx(13) = nodex_loc(nnFinish-1)
                    ndsy(13) = nodey_loc(nnFinish-1)
                    ndsz(13) = nodez_loc(nnFinish-1)
    
                    ! Coordinates of second previous marker, cn14
                    ndsx(14) = nodex_loc(nn+7)
                    ndsy(14) = nodey_loc(nn+7)
                    ndsz(14) = nodez_loc(nn+7)
                    
                    ! Coordinates of second previous marker, cn15
                    ndsx(15) = nodex_loc(nnFinish-2)
                    ndsy(15) = nodey_loc(nnFinish-2)
                    ndsz(15) = nodez_loc(nnFinish-2)
				    ! Coordinates of second previous marker, cn16
                    ndsx(16) = nodex_loc(nn+8)
                    ndsy(16) = nodey_loc(nn+8)
                    ndsz(16) = nodez_loc(nn+8)
                    ! Coordinates of second previous marker, cn17
                    ndsx(17) = nodex_loc(nnFinish-3)
                    ndsy(17) = nodey_loc(nnFinish-3)
                    ndsz(17) = nodez_loc(nnFinish-3)

				    ! Coordinates of second previous marker, cn18
                    ndsx(18) = nodex_loc(nn+9)
                    ndsy(18) = nodey_loc(nn+9)
                    ndsz(18) = nodez_loc(nn+9)
                    
                    ! Coordinates of second previous marker, cn19
                    ndsx(19) = nodex_loc(nnFinish-4)
                    ndsy(19) = nodey_loc(nnFinish-4)
                    ndsz(19) = nodez_loc(nnFinish-4)

				elseif ( nn .eq. nnFinish-4) then
			
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-3)
					ndsy(2) = nodey_loc(nnFinish-3)
					ndsz(2) = nodez_loc(nnFinish-3)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-2)
					ndsy(4) = nodey_loc(nnFinish-2)
					ndsz(4) = nodez_loc(nnFinish-2)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish-1)
					ndsy(6) = nodey_loc(nnFinish-1)
					ndsz(6) = nodez_loc(nnFinish-1)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnFinish)
					ndsy(8) = nodey_loc(nnFinish)
					ndsz(8) = nodez_loc(nnFinish)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnStart)
					ndsy(10) = nodey_loc(nnStart)
					ndsz(10) = nodez_loc(nnStart)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)
				    ! Coordinates of second previous marker, cn12
				    ndsx(12) = nodex_loc(nnStart+1)
				    ndsy(12) = nodey_loc(nnStart+1)
				    ndsz(12) = nodez_loc(nnStart+1)	
				    ! Coordinates of second previous marker, cn13
				    ndsx(13) = nodex_loc(nn-6)
				    ndsy(13) = nodey_loc(nn-6)
				    ndsz(13) = nodez_loc(nn-6)
				    ! Coordinates of second previous marker, cn14
				    ndsx(14) = nodex_loc(nnStart+2)
				    ndsy(14) = nodey_loc(nnStart+2)
				    ndsz(14) = nodez_loc(nnStart+2)
				    ! Coordinates of second previous marker, cn15
				    ndsx(15) = nodex_loc(nn-7)
				    ndsy(15) = nodey_loc(nn-7)
				    ndsz(15) = nodez_loc(nn-7)

				    ! Coordinates of second previous marker, cn16
                    ndsx(16) = nodex_loc(nnStart+3)
                    ndsy(16) = nodey_loc(nnStart+3)
                    ndsz(16) = nodez_loc(nnStart+3)
                    
                    ! Coordinates of second previous marker, cn17
                    ndsx(17) = nodex_loc(nn-8)
                    ndsy(17) = nodey_loc(nn-8)
                    ndsz(17) = nodez_loc(nn-8)

				    ! Coordinates of second previous marker, cn18
				    ndsx(18) = nodex_loc(nnStart+4)
				    ndsy(18) = nodey_loc(nnStart+4)
				    ndsz(18) = nodez_loc(nnStart+4)
                    
				    ! Coordinates of second previous marker, cn19
				    ndsx(19) = nodex_loc(nn-9)
				    ndsy(19) = nodey_loc(nn-9)
				    ndsz(19) = nodez_loc(nn-9)

                    elseif (nn .eq. nnStart+5) then
			
                        ! Coordinates of the next marker, cn2
                        ndsx(2) = nodex_loc(nn+1)
                        ndsy(2) = nodey_loc(nn+1)
                        ndsz(2) = nodez_loc(nn+1)
                
                        ! Coordinates of the previous marker, cn3
                        ndsx(3) = nodex_loc(nnStart+4)
                        ndsy(3) = nodey_loc(nnStart+4)
                        ndsz(3) = nodez_loc(nnStart+4)
                        
                        ! Coordinates of second next marker, cn4
                        ndsx(4) = nodex_loc(nn+2)
                        ndsy(4) = nodey_loc(nn+2)
                        ndsz(4) = nodez_loc(nn+2)
                
                        ! Coordinates of second previous marker, cn5
                        ndsx(5) = nodex_loc(nnStart+3)
                        ndsy(5) = nodey_loc(nnStart+3)
                        ndsz(5) = nodez_loc(nnStart+3)
                
                        ! Coordinates of second previous marker, cn6
                        ndsx(6) = nodex_loc(nn+3)
                        ndsy(6) = nodey_loc(nn+3)
                        ndsz(6) = nodez_loc(nn+3)	
                
                        ! Coordinates of second previous marker, cn7
                        ndsx(7) = nodex_loc(nnStart+2)
                        ndsy(7) = nodey_loc(nnStart+2)
                        ndsz(7) = nodez_loc(nnStart+2)
                
                        ! Coordinates of second previous marker, cn8
                        ndsx(8) = nodex_loc(nn+4)
                        ndsy(8) = nodey_loc(nn+4)
                        ndsz(8) = nodez_loc(nn+4)	
                
                        ! Coordinates of second previous marker, cn9
                        ndsx(9) = nodex_loc(nnStart+1)
                        ndsy(9) = nodey_loc(nnStart+1)
                        ndsz(9) = nodez_loc(nnStart+1)
    
                        ! Coordinates of second previous marker, cn10
                        ndsx(10) = nodex_loc(nn+5)
                        ndsy(10) = nodey_loc(nn+5)
                        ndsz(10) = nodez_loc(nn+5)
    
                        ! Coordinates of second previous marker, cn11
                        ndsx(11) = nodex_loc(nnStart)
                        ndsy(11) = nodey_loc(nnStart)
                        ndsz(11) = nodez_loc(nnStart)
    
                        ! Coordinates of second previous marker, cn12
                        ndsx(12) = nodex_loc(nn+6)
                        ndsy(12) = nodey_loc(nn+6)
                        ndsz(12) = nodez_loc(nn+6)	
                    
                        ! Coordinates of second previous marker, cn13
                        ndsx(13) = nodex_loc(nnFinish)
                        ndsy(13) = nodey_loc(nnFinish)
                        ndsz(13) = nodez_loc(nnFinish)
        
                        ! Coordinates of second previous marker, cn14
                        ndsx(14) = nodex_loc(nn+7)
                        ndsy(14) = nodey_loc(nn+7)
                        ndsz(14) = nodez_loc(nn+7)
                        
                        ! Coordinates of second previous marker, cn15
                        ndsx(15) = nodex_loc(nnFinish-1)
                        ndsy(15) = nodey_loc(nnFinish-1)
                        ndsz(15) = nodez_loc(nnFinish-1)
				        
                        ! Coordinates of second previous marker, cn16
                        ndsx(16) = nodex_loc(nn+8)
                        ndsy(16) = nodey_loc(nn+8)
                        ndsz(16) = nodez_loc(nn+8)

                        ! Coordinates of second previous marker, cn17
                        ndsx(17) = nodex_loc(nnFinish-2)
                        ndsy(17) = nodey_loc(nnFinish-2)
                        ndsz(17) = nodez_loc(nnFinish-2)

				        ! Coordinates of second previous marker, cn18
                        ndsx(18) = nodex_loc(nn+9)
                        ndsy(18) = nodey_loc(nn+9)
                        ndsz(18) = nodez_loc(nn+9)
                        
                        ! Coordinates of second previous marker, cn19
                        ndsx(19) = nodex_loc(nnFinish-3)
                        ndsy(19) = nodey_loc(nnFinish-3)
                        ndsz(19) = nodez_loc(nnFinish-3)

				elseif ( nn .eq. nnFinish-5) then
			
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-4)
					ndsy(2) = nodey_loc(nnFinish-4)
					ndsz(2) = nodez_loc(nnFinish-4)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-3)
					ndsy(4) = nodey_loc(nnFinish-3)
					ndsz(4) = nodez_loc(nnFinish-3)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish-2)
					ndsy(6) = nodey_loc(nnFinish-2)
					ndsz(6) = nodez_loc(nnFinish-2)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnFinish-1)
					ndsy(8) = nodey_loc(nnFinish-1)
					ndsz(8) = nodez_loc(nnFinish-1)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnFinish)
					ndsy(10) = nodey_loc(nnFinish)
					ndsz(10) = nodez_loc(nnFinish)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)
				    ! Coordinates of second previous marker, cn12
				    ndsx(12) = nodex_loc(nnStart)
				    ndsy(12) = nodey_loc(nnStart)
				    ndsz(12) = nodez_loc(nnStart)	
				    ! Coordinates of second previous marker, cn13
				    ndsx(13) = nodex_loc(nn-6)
				    ndsy(13) = nodey_loc(nn-6)
				    ndsz(13) = nodez_loc(nn-6)
				    ! Coordinates of second previous marker, cn14
				    ndsx(14) = nodex_loc(nnStart+1)
				    ndsy(14) = nodey_loc(nnStart+1)
				    ndsz(14) = nodez_loc(nnStart+1)
				    ! Coordinates of second previous marker, cn15
				    ndsx(15) = nodex_loc(nn-7)
				    ndsy(15) = nodey_loc(nn-7)
				    ndsz(15) = nodez_loc(nn-7)

				    ! Coordinates of second previous marker, cn16
                    ndsx(16) = nodex_loc(nnStart+2)
                    ndsy(16) = nodey_loc(nnStart+2)
                    ndsz(16) = nodez_loc(nnStart+2)
                    
                    ! Coordinates of second previous marker, cn17
                    ndsx(17) = nodex_loc(nn-8)
                    ndsy(17) = nodey_loc(nn-8)
                    ndsz(17) = nodez_loc(nn-8)

				    ! Coordinates of second previous marker, cn18
				    ndsx(18) = nodex_loc(nnStart+3)
				    ndsy(18) = nodey_loc(nnStart+3)
				    ndsz(18) = nodez_loc(nnStart+3)
                    
				    ! Coordinates of second previous marker, cn19
				    ndsx(19) = nodex_loc(nn-9)
				    ndsy(19) = nodey_loc(nn-9)
				    ndsz(19) = nodez_loc(nn-9)

                        elseif (nn .eq. nnStart+6) then
			
                            ! Coordinates of the next marker, cn2
                            ndsx(2) = nodex_loc(nn+1)
                            ndsy(2) = nodey_loc(nn+1)
                            ndsz(2) = nodez_loc(nn+1)
                    
                            ! Coordinates of the previous marker, cn3
                            ndsx(3) = nodex_loc(nnStart+5)
                            ndsy(3) = nodey_loc(nnStart+5)
                            ndsz(3) = nodez_loc(nnStart+5)
                            
                            ! Coordinates of second next marker, cn4
                            ndsx(4) = nodex_loc(nn+2)
                            ndsy(4) = nodey_loc(nn+2)
                            ndsz(4) = nodez_loc(nn+2)
                    
                            ! Coordinates of second previous marker, cn5
                            ndsx(5) = nodex_loc(nnStart+4)
                            ndsy(5) = nodey_loc(nnStart+4)
                            ndsz(5) = nodez_loc(nnStart+4)
                    
                            ! Coordinates of second previous marker, cn6
                            ndsx(6) = nodex_loc(nn+3)
                            ndsy(6) = nodey_loc(nn+3)
                            ndsz(6) = nodez_loc(nn+3)	
                    
                            ! Coordinates of second previous marker, cn7
                            ndsx(7) = nodex_loc(nnStart+3)
                            ndsy(7) = nodey_loc(nnStart+3)
                            ndsz(7) = nodez_loc(nnStart+3)
                    
                            ! Coordinates of second previous marker, cn8
                            ndsx(8) = nodex_loc(nn+4)
                            ndsy(8) = nodey_loc(nn+4)
                            ndsz(8) = nodez_loc(nn+4)	
                    
                            ! Coordinates of second previous marker, cn9
                            ndsx(9) = nodex_loc(nnStart+2)
                            ndsy(9) = nodey_loc(nnStart+2)
                            ndsz(9) = nodez_loc(nnStart+2)
        
                            ! Coordinates of second previous marker, cn10
                            ndsx(10) = nodex_loc(nn+5)
                            ndsy(10) = nodey_loc(nn+5)
                            ndsz(10) = nodez_loc(nn+5)
        
                            ! Coordinates of second previous marker, cn11
                            ndsx(11) = nodex_loc(nnStart+1)
                            ndsy(11) = nodey_loc(nnStart+1)
                            ndsz(11) = nodez_loc(nnStart+1)
        
                            ! Coordinates of second previous marker, cn12
                            ndsx(12) = nodex_loc(nn+6)
                            ndsy(12) = nodey_loc(nn+6)
                            ndsz(12) = nodez_loc(nn+6)	
                        
                            ! Coordinates of second previous marker, cn13
                            ndsx(13) = nodex_loc(nnStart)
                            ndsy(13) = nodey_loc(nnStart)
                            ndsz(13) = nodez_loc(nnStart)
            
                            ! Coordinates of second previous marker, cn14
                            ndsx(14) = nodex_loc(nn+7)
                            ndsy(14) = nodey_loc(nn+7)
                            ndsz(14) = nodez_loc(nn+7)
                            
                            ! Coordinates of second previous marker, cn15
                            ndsx(15) = nodex_loc(nnFinish)
                            ndsy(15) = nodey_loc(nnFinish)
                            ndsz(15) = nodez_loc(nnFinish)

				            ! Coordinates of second previous marker, cn16
                            ndsx(16) = nodex_loc(nn+8)
                            ndsy(16) = nodey_loc(nn+8)
                            ndsz(16) = nodez_loc(nn+8)
                            
                            ! Coordinates of second previous marker, cn17
                            ndsx(17) = nodex_loc(nnFinish-1)
                            ndsy(17) = nodey_loc(nnFinish-1)
                            ndsz(17) = nodez_loc(nnFinish-1)

				            ! Coordinates of second previous marker, cn18
                            ndsx(18) = nodex_loc(nn+9)
                            ndsy(18) = nodey_loc(nn+9)
                            ndsz(18) = nodez_loc(nn+9)
                            
                            ! Coordinates of second previous marker, cn19
                            ndsx(19) = nodex_loc(nnFinish-2)
                            ndsy(19) = nodey_loc(nnFinish-2)
                            ndsz(19) = nodez_loc(nnFinish-2)

				elseif ( nn .eq. nnFinish-6) then
			
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-5)
					ndsy(2) = nodey_loc(nnFinish-5)
					ndsz(2) = nodez_loc(nnFinish-5)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-4)
					ndsy(4) = nodey_loc(nnFinish-4)
					ndsz(4) = nodez_loc(nnFinish-4)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish-3)
					ndsy(6) = nodey_loc(nnFinish-3)
					ndsz(6) = nodez_loc(nnFinish-3)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnFinish-2)
					ndsy(8) = nodey_loc(nnFinish-2)
					ndsz(8) = nodez_loc(nnFinish-2)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnFinish-1)
					ndsy(10) = nodey_loc(nnFinish-1)
					ndsz(10) = nodez_loc(nnFinish-1)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)
				    ! Coordinates of second previous marker, cn12
				    ndsx(12) = nodex_loc(nnFinish)
				    ndsy(12) = nodey_loc(nnFinish)
				    ndsz(12) = nodez_loc(nnFinish)
				    ! Coordinates of second previous marker, cn13
				    ndsx(13) = nodex_loc(nn-6)
				    ndsy(13) = nodey_loc(nn-6)
				    ndsz(13) = nodez_loc(nn-6)
				    ! Coordinates of second previous marker, cn14
				    ndsx(14) = nodex_loc(nnStart)
				    ndsy(14) = nodey_loc(nnStart)
				    ndsz(14) = nodez_loc(nnStart)
				    ! Coordinates of second previous marker, cn15
				    ndsx(15) = nodex_loc(nn-7)
				    ndsy(15) = nodey_loc(nn-7)
				    ndsz(15) = nodez_loc(nn-7)
				    ! Coordinates of second previous marker, cn16
                    ndsx(16) = nodex_loc(nnStart+1)
                    ndsy(16) = nodey_loc(nnStart+1)
                    ndsz(16) = nodez_loc(nnStart+1)
                    ! Coordinates of second previous marker, cn17
                    ndsx(17) = nodex_loc(nn-8)
                    ndsy(17) = nodey_loc(nn-8)
                    ndsz(17) = nodez_loc(nn-8)
				    ! Coordinates of second previous marker, cn18
				    ndsx(18) = nodex_loc(nnStart+2)
				    ndsy(18) = nodey_loc(nnStart+2)
				    ndsz(18) = nodez_loc(nnStart+2)
				    ! Coordinates of second previous marker, cn19
				    ndsx(19) = nodex_loc(nn-9)
				    ndsy(19) = nodey_loc(nn-9)
				    ndsz(19) = nodez_loc(nn-9)
                    

                    elseif (nn .eq. nnStart+7) then
			
                        ! Coordinates of the next marker, cn2
                        ndsx(2) = nodex_loc(nn+1)
                        ndsy(2) = nodey_loc(nn+1)
                        ndsz(2) = nodez_loc(nn+1)
                
                        ! Coordinates of the previous marker, cn3
                        ndsx(3) = nodex_loc(nnStart+6)
                        ndsy(3) = nodey_loc(nnStart+6)
                        ndsz(3) = nodez_loc(nnStart+6)
                        
                        ! Coordinates of second next marker, cn4
                        ndsx(4) = nodex_loc(nn+2)
                        ndsy(4) = nodey_loc(nn+2)
                        ndsz(4) = nodez_loc(nn+2)
                
                        ! Coordinates of second previous marker, cn5
                        ndsx(5) = nodex_loc(nnStart+5)
                        ndsy(5) = nodey_loc(nnStart+5)
                        ndsz(5) = nodez_loc(nnStart+5)
                
                        ! Coordinates of second previous marker, cn6
                        ndsx(6) = nodex_loc(nn+3)
                        ndsy(6) = nodey_loc(nn+3)
                        ndsz(6) = nodez_loc(nn+3)	
                
                        ! Coordinates of second previous marker, cn7
                        ndsx(7) = nodex_loc(nnStart+4)
                        ndsy(7) = nodey_loc(nnStart+4)
                        ndsz(7) = nodez_loc(nnStart+4)
                
                        ! Coordinates of second previous marker, cn8
                        ndsx(8) = nodex_loc(nn+4)
                        ndsy(8) = nodey_loc(nn+4)
                        ndsz(8) = nodez_loc(nn+4)	
                
                        ! Coordinates of second previous marker, cn9
                        ndsx(9) = nodex_loc(nnStart+3)
                        ndsy(9) = nodey_loc(nnStart+3)
                        ndsz(9) = nodez_loc(nnStart+3)
    
                        ! Coordinates of second previous marker, cn10
                        ndsx(10) = nodex_loc(nn+5)
                        ndsy(10) = nodey_loc(nn+5)
                        ndsz(10) = nodez_loc(nn+5)
    
                        ! Coordinates of second previous marker, cn11
                        ndsx(11) = nodex_loc(nnStart+2)
                        ndsy(11) = nodey_loc(nnStart+2)
                        ndsz(11) = nodez_loc(nnStart+2)
    
                        ! Coordinates of second previous marker, cn12
                        ndsx(12) = nodex_loc(nn+6)
                        ndsy(12) = nodey_loc(nn+6)
                        ndsz(12) = nodez_loc(nn+6)	
                    
                        ! Coordinates of second previous marker, cn13
                        ndsx(13) = nodex_loc(nnStart+1)
                        ndsy(13) = nodey_loc(nnStart+1)
                        ndsz(13) = nodez_loc(nnStart+1)
        
                        ! Coordinates of second previous marker, cn14
                        ndsx(14) = nodex_loc(nn+7)
                        ndsy(14) = nodey_loc(nn+7)
                        ndsz(14) = nodez_loc(nn+7)
                        
                        ! Coordinates of second previous marker, cn15
                        ndsx(15) = nodex_loc(nnStart)
                        ndsy(15) = nodey_loc(nnStart)
                        ndsz(15) = nodez_loc(nnStart)

                        ! Coordinates of second previous marker, cn16
                        ndsx(16) = nodex_loc(nn+8)
                        ndsy(16) = nodey_loc(nn+8)
                        ndsz(16) = nodez_loc(nn+8)
                        
                        ! Coordinates of second previous marker, cn17
                        ndsx(17) = nodex_loc(nnFinish)
                        ndsy(17) = nodey_loc(nnFinish)
                        ndsz(17) = nodez_loc(nnFinish)

				        ! Coordinates of second previous marker, cn18
                        ndsx(18) = nodex_loc(nn+9)
                        ndsy(18) = nodey_loc(nn+9)
                        ndsz(18) = nodez_loc(nn+9)
                        
                        ! Coordinates of second previous marker, cn19
                        ndsx(19) = nodex_loc(nnFinish-1)
                        ndsy(19) = nodey_loc(nnFinish-1)
                        ndsz(19) = nodez_loc(nnFinish-1)

				elseif ( nn .eq. nnFinish-7) then
			
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-6)
					ndsy(2) = nodey_loc(nnFinish-6)
					ndsz(2) = nodez_loc(nnFinish-6)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-5)
					ndsy(4) = nodey_loc(nnFinish-5)
					ndsz(4) = nodez_loc(nnFinish-5)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish-4)
					ndsy(6) = nodey_loc(nnFinish-4)
					ndsz(6) = nodez_loc(nnFinish-4)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnFinish-3)
					ndsy(8) = nodey_loc(nnFinish-3)
					ndsz(8) = nodez_loc(nnFinish-3)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnFinish-2)
					ndsy(10) = nodey_loc(nnFinish-2)
					ndsz(10) = nodez_loc(nnFinish-2)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)
				    ! Coordinates of second previous marker, cn12
				    ndsx(12) = nodex_loc(nnFinish-1)
				    ndsy(12) = nodey_loc(nnFinish-1)
				    ndsz(12) = nodez_loc(nnFinish-1)
				    ! Coordinates of second previous marker, cn13
				    ndsx(13) = nodex_loc(nn-6)
				    ndsy(13) = nodey_loc(nn-6)
				    ndsz(13) = nodez_loc(nn-6)
				    ! Coordinates of second previous marker, cn14
				    ndsx(14) = nodex_loc(nnFinish)
				    ndsy(14) = nodey_loc(nnFinish)
				    ndsz(14) = nodez_loc(nnFinish)
				    ! Coordinates of second previous marker, cn15
				    ndsx(15) = nodex_loc(nn-7)
				    ndsy(15) = nodey_loc(nn-7)
				    ndsz(15) = nodez_loc(nn-7)
				    ! Coordinates of second previous marker, cn16
                    ndsx(16) = nodex_loc(nnStart)
                    ndsy(16) = nodey_loc(nnStart)
                    ndsz(16) = nodez_loc(nnStart)
                    
                    ! Coordinates of second previous marker, cn17
                    ndsx(17) = nodex_loc(nn-8)
                    ndsy(17) = nodey_loc(nn-8)
                    ndsz(17) = nodez_loc(nn-8)

				    ! Coordinates of second previous marker, cn18
				    ndsx(18) = nodex_loc(nnStart+1)
				    ndsy(18) = nodey_loc(nnStart+1)
				    ndsz(18) = nodez_loc(nnStart+1)
                    
				    ! Coordinates of second previous marker, cn19
				    ndsx(19) = nodex_loc(nn-9)
				    ndsy(19) = nodey_loc(nn-9)
				    ndsz(19) = nodez_loc(nn-9)

                    elseif (nn .eq. nnStart+8) then
			
                        ! Coordinates of the next marker, cn2
                        ndsx(2) = nodex_loc(nn+1)
                        ndsy(2) = nodey_loc(nn+1)
                        ndsz(2) = nodez_loc(nn+1)
                
                        ! Coordinates of the previous marker, cn3
                        ndsx(3) = nodex_loc(nnStart+7)
                        ndsy(3) = nodey_loc(nnStart+7)
                        ndsz(3) = nodez_loc(nnStart+7)
                        
                        ! Coordinates of second next marker, cn4
                        ndsx(4) = nodex_loc(nn+2)
                        ndsy(4) = nodey_loc(nn+2)
                        ndsz(4) = nodez_loc(nn+2)
                
                        ! Coordinates of second previous marker, cn5
                        ndsx(5) = nodex_loc(nnStart+6)
                        ndsy(5) = nodey_loc(nnStart+6)
                        ndsz(5) = nodez_loc(nnStart+6)
                
                        ! Coordinates of second previous marker, cn6
                        ndsx(6) = nodex_loc(nn+3)
                        ndsy(6) = nodey_loc(nn+3)
                        ndsz(6) = nodez_loc(nn+3)	
                
                        ! Coordinates of second previous marker, cn7
                        ndsx(7) = nodex_loc(nnStart+5)
                        ndsy(7) = nodey_loc(nnStart+5)
                        ndsz(7) = nodez_loc(nnStart+5)
                
                        ! Coordinates of second previous marker, cn8
                        ndsx(8) = nodex_loc(nn+4)
                        ndsy(8) = nodey_loc(nn+4)
                        ndsz(8) = nodez_loc(nn+4)	
                
                        ! Coordinates of second previous marker, cn9
                        ndsx(9) = nodex_loc(nnStart+4)
                        ndsy(9) = nodey_loc(nnStart+4)
                        ndsz(9) = nodez_loc(nnStart+4)
    
                        ! Coordinates of second previous marker, cn10
                        ndsx(10) = nodex_loc(nn+5)
                        ndsy(10) = nodey_loc(nn+5)
                        ndsz(10) = nodez_loc(nn+5)
    
                        ! Coordinates of second previous marker, cn11
                        ndsx(11) = nodex_loc(nnStart+3)
                        ndsy(11) = nodey_loc(nnStart+3)
                        ndsz(11) = nodez_loc(nnStart+3)
    
                        ! Coordinates of second previous marker, cn12
                        ndsx(12) = nodex_loc(nn+6)
                        ndsy(12) = nodey_loc(nn+6)
                        ndsz(12) = nodez_loc(nn+6)	
                    
                        ! Coordinates of second previous marker, cn13
                        ndsx(13) = nodex_loc(nnStart+2)
                        ndsy(13) = nodey_loc(nnStart+2)
                        ndsz(13) = nodez_loc(nnStart+2)
        
                        ! Coordinates of second previous marker, cn14
                        ndsx(14) = nodex_loc(nn+7)
                        ndsy(14) = nodey_loc(nn+7)
                        ndsz(14) = nodez_loc(nn+7)
                        
                        ! Coordinates of second previous marker, cn15
                        ndsx(15) = nodex_loc(nnStart+1)
                        ndsy(15) = nodey_loc(nnStart+1)
                        ndsz(15) = nodez_loc(nnStart+1)

                        ! Coordinates of second previous marker, cn16
                        ndsx(16) = nodex_loc(nn+8)
                        ndsy(16) = nodey_loc(nn+8)
                        ndsz(16) = nodez_loc(nn+8)
                        
                        ! Coordinates of second previous marker, cn17
                        ndsx(17) = nodex_loc(nnStart)
                        ndsy(17) = nodey_loc(nnStart)
                        ndsz(17) = nodez_loc(nnStart)

				        ! Coordinates of second previous marker, cn18
                        ndsx(18) = nodex_loc(nn+9)
                        ndsy(18) = nodey_loc(nn+9)
                        ndsz(18) = nodez_loc(nn+9)
                        
                        ! Coordinates of second previous marker, cn19
                        ndsx(19) = nodex_loc(nnFinish)
                        ndsy(19) = nodey_loc(nnFinish)
                        ndsz(19) = nodez_loc(nnFinish)

				elseif ( nn .eq. nnFinish-8) then
			
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-7)
					ndsy(2) = nodey_loc(nnFinish-7)
					ndsz(2) = nodez_loc(nnFinish-7)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-6)
					ndsy(4) = nodey_loc(nnFinish-6)
					ndsz(4) = nodez_loc(nnFinish-6)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish-5)
					ndsy(6) = nodey_loc(nnFinish-5)
					ndsz(6) = nodez_loc(nnFinish-5)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnFinish-4)
					ndsy(8) = nodey_loc(nnFinish-4)
					ndsz(8) = nodez_loc(nnFinish-4)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnFinish-3)
					ndsy(10) = nodey_loc(nnFinish-3)
					ndsz(10) = nodez_loc(nnFinish-3)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)
				    ! Coordinates of second previous marker, cn12
				    ndsx(12) = nodex_loc(nnFinish-2)
				    ndsy(12) = nodey_loc(nnFinish-2)
				    ndsz(12) = nodez_loc(nnFinish-2)
				    ! Coordinates of second previous marker, cn13
				    ndsx(13) = nodex_loc(nn-6)
				    ndsy(13) = nodey_loc(nn-6)
				    ndsz(13) = nodez_loc(nn-6)
				    ! Coordinates of second previous marker, cn14
				    ndsx(14) = nodex_loc(nnFinish-1)
				    ndsy(14) = nodey_loc(nnFinish-1)
				    ndsz(14) = nodez_loc(nnFinish-1)
				    ! Coordinates of second previous marker, cn15
				    ndsx(15) = nodex_loc(nn-7)
				    ndsy(15) = nodey_loc(nn-7)
				    ndsz(15) = nodez_loc(nn-7)
				    ! Coordinates of second previous marker, cn16
                    ndsx(16) = nodex_loc(nnFinish)
                    ndsy(16) = nodey_loc(nnFinish)
                    ndsz(16) = nodez_loc(nnFinish)
                    
                    ! Coordinates of second previous marker, cn17
                    ndsx(17) = nodex_loc(nn-8)
                    ndsy(17) = nodey_loc(nn-8)
                    ndsz(17) = nodez_loc(nn-8)

				    ! Coordinates of second previous marker, cn18
				    ndsx(18) = nodex_loc(nnStart)
				    ndsy(18) = nodey_loc(nnStart)
				    ndsz(18) = nodez_loc(nnStart)
                    
				    ! Coordinates of second previous marker, cn19
				    ndsx(19) = nodex_loc(nn-9)
				    ndsy(19) = nodey_loc(nn-9)
				    ndsz(19) = nodez_loc(nn-9)
			else
			
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)										
			
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
				
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)

				! Coordinates of second previous marker, cn8
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)	
			
				! Coordinates of second previous marker, cn9
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)

				! Coordinates of second previous marker, cn12
				ndsx(12) = nodex_loc(nn+6)
				ndsy(12) = nodey_loc(nn+6)
				ndsz(12) = nodez_loc(nn+6)	
			
				! Coordinates of second previous marker, cn13
				ndsx(13) = nodex_loc(nn-6)
				ndsy(13) = nodey_loc(nn-6)
				ndsz(13) = nodez_loc(nn-6)

				! Coordinates of second previous marker, cn14
				ndsx(14) = nodex_loc(nn+7)
				ndsy(14) = nodey_loc(nn+7)
				ndsz(14) = nodez_loc(nn+7)
				
				! Coordinates of second previous marker, cn15
				ndsx(15) = nodex_loc(nn-7)
				ndsy(15) = nodey_loc(nn-7)
				ndsz(15) = nodez_loc(nn-7)

				! Coordinates of second previous marker, cn16
				ndsx(16) = nodex_loc(nn+8)
				ndsy(16) = nodey_loc(nn+8)
				ndsz(16) = nodez_loc(nn+8)
				
				! Coordinates of second previous marker, cn17
				ndsx(17) = nodex_loc(nn-8)
				ndsy(17) = nodey_loc(nn-8)
				ndsz(17) = nodez_loc(nn-8)

				! Coordinates of second previous marker, cn18
				ndsx(18) = nodex_loc(nn+9)
				ndsy(18) = nodey_loc(nn+9)
				ndsz(18) = nodez_loc(nn+9)
				
				! Coordinates of second previous marker, cn19
				ndsx(19) = nodex_loc(nn-9)
				ndsy(19) = nodey_loc(nn-9)
				ndsz(19) = nodez_loc(nn-9)

			endif
			!
			flag2 = 0
			!
			!
			vec0u(1) = nn 
			vec0u(2) = ll 
			vec0u(3) = ib 
			vec0u(4) = iii
			vec0u(5) = jjc
			vec0u(6) = kkk
			vec0u(8) = lag_bod_loc(nn)
			!
			vec0w(1) = nn 
			vec0w(2) = ll 
			vec0w(3) = ib 
			vec0w(4) = iic
			vec0w(5) = jjc
			vec0w(6) = kkk
			vec0w(8) = lag_bod_loc(nn)
			!
			!	!
				! ( 0, 90 ] First quadrant?
				if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
				if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
					qFlag = 1
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				! ( 90, 180 ] 2nd quadrant?
				if ( (ndsx(2) - ndsx(1)) .le. -margin) then
				if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
					qFlag = 2
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				! ( 180, 270 ] 3rd quadrant?
				if ( (ndsx(2) - ndsx(1)) .le. margin) then
				if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
					qFlag = 3
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				! ( 270, 360 ] 4th quadrant?
				if ( (ndsx(2) - ndsx(1)) .gt. margin) then
				if ( (ndsz(2) - ndsz(1)) .le. margin) then
					qFlag = 4
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				!
				!
		 endif	! Ensuring processor ID matches subdomain ID???
		enddo	!  sweeping markers outermost layer of each station
		!
		!do nn = 1, maxnodeIBS	! sweeping markers
		!do nn = nnFinish+1, mm*mksPS
			!IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
			!!
			!ll = 2
			!!
			!ndsx(1) = nodex_loc(nn) 
			!ndsy(1) = nodey_loc(nn) 
			!ndsz(1) = nodez_loc(nn)
			!!
			!iii = int ( ( ndsx(1) - origin_x - margin) /dx_l) + 2 
			!jjc = int ( ( ndsy(1) - origin_yc - margin) /dy_l) + 2
			!kkk = int ( ( ndsz(1) - origin_z - margin) /dz_l) + 2	! aka kkkn check note 1
			!!
			!iic = int ( ( ndsx(1) - origin_xc - margin) /dx_l) + 2 
			!kkc = int ( ( ndsz(1) - origin_zc - margin) /dz_l) + 2
			!!
			!! Check for not modifying the ghost layer beyoud the boundaries of the control volume
			!if (jjc .lt. js) then
			!	jjc = js
			!endif
			!if (jjc .gt. je) then
			!	jjc = je
			!endif
			!!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!! Checking bounding box for u cell
			!if((dom(ib)%x(iii-1)-margin).gt.ndsx(1)) then
			!	write(6,*) "Warning 1, bounding box too high!!"
			!endif
			!if((dom(ib)%x(iii)+margin).lt.ndsx(1)) then
			!	 write(6,*)  "Warning 2, bounding box too low!!"
			!endif
			!if((dom(ib)%zc(kkc-1)-margin).gt.ndsz(1)) then
			!	write(6,*) "Warning 3, bounding box too forward!!"
			!endif
			!if((dom(ib)%zc(kkc)+margin).lt.ndsz(1)) then
			!	write(6,*) "Warning 4, bounding box too behind!!"
			!endif
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!! Checking bounding box for w cell
			!if((dom(ib)%xc(iic-1)-margin).gt.ndsx(1)) then
			!	write(6,*) "Warning 11, bounding box too high!!"
			!endif
			!if((dom(ib)%xc(iic)+margin).lt.ndsx(1)) then
			!	 write(6,*)  "Warning 22, bounding box too low!!"
			!endif
			!if((dom(ib)%z(kkk-1)-margin).gt.ndsz(1)) then
			!	write(6,*) "Warning 33, bounding box too forward!!"
			!endif
			!if((dom(ib)%z(kkk)+margin).lt.ndsz(1)) then
			!	write(6,*) "Warning 44, bounding box too behind!!"
			!endif
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!! Checking bounding box for p cell
			!if((dom(ib)%xc(iic-1)-margin).gt.ndsx(1)) then
			!	write(6,*) "Warning 111, bounding box too high!!"
			!endif
			!if((dom(ib)%xc(iic)+margin).lt.ndsx(1)) then
			!	 write(6,*)  "Warning 222, bounding box too low!!"
			!endif
			!if((dom(ib)%zc(kkc-1)-margin).gt.ndsz(1)) then
			!	write(6,*) "Warning 333, bounding box too forward!!"
			!endif
			!if((dom(ib)%zc(kkc)+margin).lt.ndsz(1)) then
			!	write(6,*) "Warning 444, bounding box too behind!!"
			!endif
			!
			!
			! Extrancting coordinates of the neighbouring markers from the same layer
			!if (nn .eq. nnStart) then
			!	! Coordinates of the next marker, cn2
			!	ndsx(2) = nodex_loc(nn+1)
			!	ndsy(2) = nodey_loc(nn+1)
			!	ndsz(2) = nodez_loc(nn+1)
			!	! Coordinates of the previous marker, cn3
			!	ndsx(3) = nodex_loc(nnFinish)
			!	ndsy(3) = nodey_loc(nnFinish)
			!	ndsz(3) = nodez_loc(nnFinish)
			!	! Coordinates of second next marker, cn4
			!	ndsx(4) = nodex_loc(nn+2)
			!	ndsy(4) = nodey_loc(nn+2)
			!	ndsz(4) = nodez_loc(nn+2)
			!	! Coordinates of second previous marker, cn5
			!	ndsx(5) = nodex_loc(nnFinish-1)
			!	ndsy(5) = nodey_loc(nnFinish-1)
			!	ndsz(5) = nodez_loc(nnFinish-1)
			!	! Coordinates of second previous marker, cn6
			!	ndsx(6) = nodex_loc(nn+3)
			!	ndsy(6) = nodey_loc(nn+3)
			!	ndsz(6) = nodez_loc(nn+3)	
			!	! Coordinates of second previous marker, cn7
			!	ndsx(7) = nodex_loc(nnFinish-2)
			!	ndsy(7) = nodey_loc(nnFinish-2)
			!	ndsz(7) = nodez_loc(nnFinish-2)
			!	! Coordinates of second previous marker, cn8
			!	ndsx(8) = nodex_loc(nn+4)
			!	ndsy(8) = nodey_loc(nn+4)
			!	ndsz(8) = nodez_loc(nn+4)	
			!	! Coordinates of second previous marker, cn9
			!	ndsx(9) = nodex_loc(nnFinish-3)
			!	ndsy(9) = nodey_loc(nnFinish-3)
			!	ndsz(9) = nodez_loc(nnFinish-3)
			!	! Coordinates of second previous marker, cn10
			!	ndsx(10) = nodex_loc(nn+5)
			!	ndsy(10) = nodey_loc(nn+5)
			!	ndsz(10) = nodez_loc(nn+5)
			!	! Coordinates of second previous marker, cn11
			!	ndsx(11) = nodex_loc(nnFinish-4)
			!	ndsy(11) = nodey_loc(nnFinish-4)
			!	ndsz(11) = nodez_loc(nnFinish-4)
			!elseif ( nn .eq. nnFinish) then
			!	! Coordinates of the next markers, cn2
			!	ndsx(2) = nodex_loc(nnStart)
			!	ndsy(2) = nodey_loc(nnStart)
			!	ndsz(2) = nodez_loc(nnStart)
			!	! Coordinates of the previous marker, cn3
			!	ndsx(3) = nodex_loc(nn-1)
			!	ndsy(3) = nodey_loc(nn-1)
			!	ndsz(3) = nodez_loc(nn-1)
			!	! Coordinates of second next marker, cn4
			!	ndsx(4) = nodex_loc(nnStart+1)
			!	ndsy(4) = nodey_loc(nnStart+1)
			!	ndsz(4) = nodez_loc(nnStart+1)
			!	! Coordinates of second previous marker, cn5
			!	ndsx(5) = nodex_loc(nn-2)
			!	ndsy(5) = nodey_loc(nn-2)
			!	ndsz(5) = nodez_loc(nn-2)		
			!	! Coordinates of second previous marker, cn6
			!	ndsx(6) = nodex_loc(nnStart+2)
			!	ndsy(6) = nodey_loc(nnStart+2)
			!	ndsz(6) = nodez_loc(nnStart+2)	
			!	! Coordinates of second previous marker, cn7
			!	ndsx(7) = nodex_loc(nn-3)
			!	ndsy(7) = nodey_loc(nn-3)
			!	ndsz(7) = nodez_loc(nn-3)
			!	! Coordinates of second previous marker, cn8
			!	ndsx(8) = nodex_loc(nnStart+3)
			!	ndsy(8) = nodey_loc(nnStart+3)
			!	ndsz(8) = nodez_loc(nnStart+3)	
			!	! Coordinates of second previous marker, cn9
			!	ndsx(9) = nodex_loc(nn-4)
			!	ndsy(9) = nodey_loc(nn-4)
			!	ndsz(9) = nodez_loc(nn-4)
			!	! Coordinates of second previous marker, cn10
			!	ndsx(10) = nodex_loc(nnStart+4)
			!	ndsy(10) = nodey_loc(nnStart+4)
			!	ndsz(10) = nodez_loc(nnStart+4)
			!	! Coordinates of second previous marker, cn11
			!	ndsx(11) = nodex_loc(nn-5)
			!	ndsy(11) = nodey_loc(nn-5)
			!	ndsz(11) = nodez_loc(nn-5)
			!elseif (nn .eq. nnStart+1) then
			!	! Coordinates of the next marker, cn2
			!	ndsx(2) = nodex_loc(nn+1)
			!	ndsy(2) = nodey_loc(nn+1)
			!	ndsz(2) = nodez_loc(nn+1)
			!	! Coordinates of the previous marker, cn3
			!	ndsx(3) = nodex_loc(nnStart)
			!	ndsy(3) = nodey_loc(nnStart)
			!	ndsz(3) = nodez_loc(nnStart)
			!	! Coordinates of second next marker, cn4
			!	ndsx(4) = nodex_loc(nn+2)
			!	ndsy(4) = nodey_loc(nn+2)
			!	ndsz(4) = nodez_loc(nn+2)
			!	! Coordinates of second previous marker, cn5
			!	ndsx(5) = nodex_loc(nnFinish)
			!	ndsy(5) = nodey_loc(nnFinish)
			!	ndsz(5) = nodez_loc(nnFinish)
			!	! Coordinates of second previous marker, cn6
			!	ndsx(6) = nodex_loc(nn+3)
			!	ndsy(6) = nodey_loc(nn+3)
			!	ndsz(6) = nodez_loc(nn+3)	
			!	! Coordinates of second previous marker, cn7
			!	ndsx(7) = nodex_loc(nnFinish-1)
			!	ndsy(7) = nodey_loc(nnFinish-1)
			!	ndsz(7) = nodez_loc(nnFinish-1)
			!	! Coordinates of second previous marker, cn8
			!	ndsx(8) = nodex_loc(nn+4)
			!	ndsy(8) = nodey_loc(nn+4)
			!	ndsz(8) = nodez_loc(nn+4)	
			!	! Coordinates of second previous marker, cn9
			!	ndsx(9) = nodex_loc(nnFinish-2)
			!	ndsy(9) = nodey_loc(nnFinish-2)
			!	ndsz(9) = nodez_loc(nnFinish-2)
			!	! Coordinates of second previous marker, cn10
			!	ndsx(10) = nodex_loc(nn+5)
			!	ndsy(10) = nodey_loc(nn+5)
			!	ndsz(10) = nodez_loc(nn+5)
			!	! Coordinates of second previous marker, cn11
			!	ndsx(11) = nodex_loc(nnFinish-3)
			!	ndsy(11) = nodey_loc(nnFinish-3)
			!	ndsz(11) = nodez_loc(nnFinish-3)
			!elseif ( nn .eq. nnFinish-1) then
			!	! Coordinates of the next markers, cn2
			!	ndsx(2) = nodex_loc(nnFinish)
			!	ndsy(2) = nodey_loc(nnFinish)
			!	ndsz(2) = nodez_loc(nnFinish)
			!	! Coordinates of the previous marker, cn3
			!	ndsx(3) = nodex_loc(nn-1)
			!	ndsy(3) = nodey_loc(nn-1)
			!	ndsz(3) = nodez_loc(nn-1)
			!	! Coordinates of second next marker, cn4
			!	ndsx(4) = nodex_loc(nnStart)
			!	ndsy(4) = nodey_loc(nnStart)
			!	ndsz(4) = nodez_loc(nnStart)
			!	! Coordinates of second previous marker, cn5
			!	ndsx(5) = nodex_loc(nn-2)
			!	ndsy(5) = nodey_loc(nn-2)
			!	ndsz(5) = nodez_loc(nn-2)
			!	! Coordinates of second previous marker, cn6
			!	ndsx(6) = nodex_loc(nnStart+1)
			!	ndsy(6) = nodey_loc(nnStart+1)
			!	ndsz(6) = nodez_loc(nnStart+1)	
			!	! Coordinates of second previous marker, cn7
			!	ndsx(7) = nodex_loc(nn-3)
			!	ndsy(7) = nodey_loc(nn-3)
			!	ndsz(7) = nodez_loc(nn-3)
			!	! Coordinates of second previous marker, cn8
			!	ndsx(8) = nodex_loc(nnStart+2)
			!	ndsy(8) = nodey_loc(nnStart+2)
			!	ndsz(8) = nodez_loc(nnStart+2)	
			!	! Coordinates of second previous marker, cn9
			!	ndsx(9) = nodex_loc(nn-4)
			!	ndsy(9) = nodey_loc(nn-4)
			!	ndsz(9) = nodez_loc(nn-4)
			!	! Coordinates of second previous marker, cn10
			!	ndsx(10) = nodex_loc(nnStart+3)
			!	ndsy(10) = nodey_loc(nnStart+3)
			!	ndsz(10) = nodez_loc(nnStart+3)
			!	! Coordinates of second previous marker, cn11
			!	ndsx(11) = nodex_loc(nn-5)
			!	ndsy(11) = nodey_loc(nn-5)
			!	ndsz(11) = nodez_loc(nn-5)
			!elseif (nn .eq. nnStart+2) then
			!	! Coordinates of the next marker, cn2
			!	ndsx(2) = nodex_loc(nn+1)
			!	ndsy(2) = nodey_loc(nn+1)
			!	ndsz(2) = nodez_loc(nn+1)
			!	! Coordinates of the previous marker, cn3
			!	ndsx(3) = nodex_loc(nnStart+1)
			!	ndsy(3) = nodey_loc(nnStart+1)
			!	ndsz(3) = nodez_loc(nnStart+1)
			!	! Coordinates of second next marker, cn4
			!	ndsx(4) = nodex_loc(nn+2)
			!	ndsy(4) = nodey_loc(nn+2)
			!	ndsz(4) = nodez_loc(nn+2)
			!	! Coordinates of second previous marker, cn5
			!	ndsx(5) = nodex_loc(nnStart)
			!	ndsy(5) = nodey_loc(nnStart)
			!	ndsz(5) = nodez_loc(nnStart)
			!	! Coordinates of second previous marker, cn6
			!	ndsx(6) = nodex_loc(nn+3)
			!	ndsy(6) = nodey_loc(nn+3)
			!	ndsz(6) = nodez_loc(nn+3)	
			!	! Coordinates of second previous marker, cn7
			!	ndsx(7) = nodex_loc(nnFinish)
			!	ndsy(7) = nodey_loc(nnFinish)
			!	ndsz(7) = nodez_loc(nnFinish)
			!	! Coordinates of second previous marker, cn8
			!	ndsx(8) = nodex_loc(nn+4)
			!	ndsy(8) = nodey_loc(nn+4)
			!	ndsz(8) = nodez_loc(nn+4)	
			!	! Coordinates of second previous marker, cn9
			!	ndsx(9) = nodex_loc(nnFinish-1)
			!	ndsy(9) = nodey_loc(nnFinish-1)
			!	ndsz(9) = nodez_loc(nnFinish-1)
			!	! Coordinates of second previous marker, cn10
			!	ndsx(10) = nodex_loc(nn+5)
			!	ndsy(10) = nodey_loc(nn+5)
			!	ndsz(10) = nodez_loc(nn+5)
			!	! Coordinates of second previous marker, cn11
			!	ndsx(11) = nodex_loc(nnFinish-2)
			!	ndsy(11) = nodey_loc(nnFinish-2)
			!	ndsz(11) = nodez_loc(nnFinish-2)
			!elseif ( nn .eq. nnFinish-2) then
			!	! Coordinates of the next markers, cn2
			!	ndsx(2) = nodex_loc(nnFinish-1)
			!	ndsy(2) = nodey_loc(nnFinish-1)
			!	ndsz(2) = nodez_loc(nnFinish-1)
			!	! Coordinates of the previous marker, cn3
			!	ndsx(3) = nodex_loc(nn-1)
			!	ndsy(3) = nodey_loc(nn-1)
			!	ndsz(3) = nodez_loc(nn-1)
			!	! Coordinates of second next marker, cn4
			!	ndsx(4) = nodex_loc(nnFinish)
			!	ndsy(4) = nodey_loc(nnFinish)
			!	ndsz(4) = nodez_loc(nnFinish)
			!	! Coordinates of second previous marker, cn5
			!	ndsx(5) = nodex_loc(nn-2)
			!	ndsy(5) = nodey_loc(nn-2)
			!	ndsz(5) = nodez_loc(nn-2)
			!	! Coordinates of second previous marker, cn6
			!	ndsx(6) = nodex_loc(nnStart)
			!	ndsy(6) = nodey_loc(nnStart)
			!	ndsz(6) = nodez_loc(nnStart)	
			!	! Coordinates of second previous marker, cn7
			!	ndsx(7) = nodex_loc(nn-3)
			!	ndsy(7) = nodey_loc(nn-3)
			!	ndsz(7) = nodez_loc(nn-3)
			!	! Coordinates of second previous marker, cn8
			!	ndsx(8) = nodex_loc(nnStart+1)
			!	ndsy(8) = nodey_loc(nnStart+1)
			!	ndsz(8) = nodez_loc(nnStart+1)
			!	! Coordinates of second previous marker, cn9
			!	ndsx(9) = nodex_loc(nn-4)
			!	ndsy(9) = nodey_loc(nn-4)
			!	ndsz(9) = nodez_loc(nn-4)
			!	! Coordinates of second previous marker, cn10
			!	ndsx(10) = nodex_loc(nnStart+2)
			!	ndsy(10) = nodey_loc(nnStart+2)
			!	ndsz(10) = nodez_loc(nnStart+2)
			!	! Coordinates of second previous marker, cn11
			!	ndsx(11) = nodex_loc(nn-5)
			!	ndsy(11) = nodey_loc(nn-5)
			!	ndsz(11) = nodez_loc(nn-5)
			!	elseif (nn .eq. nnStart+3) then
			!		! Coordinates of the next marker, cn2
			!		ndsx(2) = nodex_loc(nn+1)
			!		ndsy(2) = nodey_loc(nn+1)
			!		ndsz(2) = nodez_loc(nn+1)
			!		! Coordinates of the previous marker, cn3
			!		ndsx(3) = nodex_loc(nnStart+2)
			!		ndsy(3) = nodey_loc(nnStart+2)
			!		ndsz(3) = nodez_loc(nnStart+2)
			!		! Coordinates of second next marker, cn4
			!		ndsx(4) = nodex_loc(nn+2)
			!		ndsy(4) = nodey_loc(nn+2)
			!		ndsz(4) = nodez_loc(nn+2)
			!		! Coordinates of second previous marker, cn5
			!		ndsx(5) = nodex_loc(nnStart+1)
			!		ndsy(5) = nodey_loc(nnStart+1)
			!		ndsz(5) = nodez_loc(nnStart+1)
			!		! Coordinates of second previous marker, cn6
			!		ndsx(6) = nodex_loc(nn+3)
			!		ndsy(6) = nodey_loc(nn+3)
			!		ndsz(6) = nodez_loc(nn+3)	
			!		! Coordinates of second previous marker, cn7
			!		ndsx(7) = nodex_loc(nnStart)
			!		ndsy(7) = nodey_loc(nnStart)
			!		ndsz(7) = nodez_loc(nnStart)
			!		! Coordinates of second previous marker, cn8
			!		ndsx(8) = nodex_loc(nn+4)
			!		ndsy(8) = nodey_loc(nn+4)
			!		ndsz(8) = nodez_loc(nn+4)	
			!		! Coordinates of second previous marker, cn9
			!		ndsx(9) = nodex_loc(nnFinish)
			!		ndsy(9) = nodey_loc(nnFinish)
			!		ndsz(9) = nodez_loc(nnFinish)
			!		! Coordinates of second previous marker, cn10
			!		ndsx(10) = nodex_loc(nn+5)
			!		ndsy(10) = nodey_loc(nn+5)
			!		ndsz(10) = nodez_loc(nn+5)
			!		! Coordinates of second previous marker, cn11
			!		ndsx(11) = nodex_loc(nnFinish-1)
			!		ndsy(11) = nodey_loc(nnFinish-1)
			!		ndsz(11) = nodez_loc(nnFinish-1)
			!	elseif ( nn .eq. nnFinish-3) then
			!		! Coordinates of the next markers, cn2
			!		ndsx(2) = nodex_loc(nnFinish-2)
			!		ndsy(2) = nodey_loc(nnFinish-2)
			!		ndsz(2) = nodez_loc(nnFinish-2)
			!		! Coordinates of the previous marker, cn3
			!		ndsx(3) = nodex_loc(nn-1)
			!		ndsy(3) = nodey_loc(nn-1)
			!		ndsz(3) = nodez_loc(nn-1)
			!		! Coordinates of second next marker, cn4
			!		ndsx(4) = nodex_loc(nnFinish-1)
			!		ndsy(4) = nodey_loc(nnFinish-1)
			!		ndsz(4) = nodez_loc(nnFinish-1)
			!		! Coordinates of second previous marker, cn5
			!		ndsx(5) = nodex_loc(nn-2)
			!		ndsy(5) = nodey_loc(nn-2)
			!		ndsz(5) = nodez_loc(nn-2)
			!		! Coordinates of second previous marker, cn6
			!		ndsx(6) = nodex_loc(nnFinish)
			!		ndsy(6) = nodey_loc(nnFinish)
			!		ndsz(6) = nodez_loc(nnFinish)	
			!		! Coordinates of second previous marker, cn7
			!		ndsx(7) = nodex_loc(nn-3)
			!		ndsy(7) = nodey_loc(nn-3)
			!		ndsz(7) = nodez_loc(nn-3)
			!		! Coordinates of second previous marker, cn8
			!		ndsx(8) = nodex_loc(nnStart)
			!		ndsy(8) = nodey_loc(nnStart)
			!		ndsz(8) = nodez_loc(nnStart)	
			!		! Coordinates of second previous marker, cn9
			!		ndsx(9) = nodex_loc(nn-4)
			!		ndsy(9) = nodey_loc(nn-4)
			!		ndsz(9) = nodez_loc(nn-4)
			!		! Coordinates of second previous marker, cn10
			!		ndsx(10) = nodex_loc(nnStart+1)
			!		ndsy(10) = nodey_loc(nnStart+1)
			!		ndsz(10) = nodez_loc(nnStart+1)
			!		! Coordinates of second previous marker, cn11
			!		ndsx(11) = nodex_loc(nn-5)
			!		ndsy(11) = nodey_loc(nn-5)
			!		ndsz(11) = nodez_loc(nn-5)
			!		
			!	elseif (nn .eq. nnStart+4) then
			!		! Coordinates of the next marker, cn2
			!		ndsx(2) = nodex_loc(nn+1)
			!		ndsy(2) = nodey_loc(nn+1)
			!		ndsz(2) = nodez_loc(nn+1)
			!		! Coordinates of the previous marker, cn3
			!		ndsx(3) = nodex_loc(nnStart+3)
			!		ndsy(3) = nodey_loc(nnStart+3)
			!		ndsz(3) = nodez_loc(nnStart+3)
			!		! Coordinates of second next marker, cn4
			!		ndsx(4) = nodex_loc(nn+2)
			!		ndsy(4) = nodey_loc(nn+2)
			!		ndsz(4) = nodez_loc(nn+2)
			!		! Coordinates of second previous marker, cn5
			!		ndsx(5) = nodex_loc(nnStart+2)
			!		ndsy(5) = nodey_loc(nnStart+2)
			!		ndsz(5) = nodez_loc(nnStart+2)
			!		! Coordinates of second previous marker, cn6
			!		ndsx(6) = nodex_loc(nn+3)
			!		ndsy(6) = nodey_loc(nn+3)
			!		ndsz(6) = nodez_loc(nn+3)	
			!		! Coordinates of second previous marker, cn7
			!		ndsx(7) = nodex_loc(nnStart+1)
			!		ndsy(7) = nodey_loc(nnStart+1)
			!		ndsz(7) = nodez_loc(nnStart+1)
			!		! Coordinates of second previous marker, cn8
			!		ndsx(8) = nodex_loc(nn+4)
			!		ndsy(8) = nodey_loc(nn+4)
			!		ndsz(8) = nodez_loc(nn+4)	
			!		! Coordinates of second previous marker, cn9
			!		ndsx(9) = nodex_loc(nnStart)
			!		ndsy(9) = nodey_loc(nnStart)
			!		ndsz(9) = nodez_loc(nnStart)
			!		! Coordinates of second previous marker, cn10
			!		ndsx(10) = nodex_loc(nn+5)
			!		ndsy(10) = nodey_loc(nn+5)
			!		ndsz(10) = nodez_loc(nn+5)
			!		! Coordinates of second previous marker, cn11
			!		ndsx(11) = nodex_loc(nnFinish)
			!		ndsy(11) = nodey_loc(nnFinish)
			!		ndsz(11) = nodez_loc(nnFinish)
			!	elseif ( nn .eq. nnFinish-4) then
			!		! Coordinates of the next markers, cn2
			!		ndsx(2) = nodex_loc(nnFinish-3)
			!		ndsy(2) = nodey_loc(nnFinish-3)
			!		ndsz(2) = nodez_loc(nnFinish-3)
			!		! Coordinates of the previous marker, cn3
			!		ndsx(3) = nodex_loc(nn-1)
			!		ndsy(3) = nodey_loc(nn-1)
			!		ndsz(3) = nodez_loc(nn-1)
			!		! Coordinates of second next marker, cn4
			!		ndsx(4) = nodex_loc(nnFinish-2)
			!		ndsy(4) = nodey_loc(nnFinish-2)
			!		ndsz(4) = nodez_loc(nnFinish-2)
			!		! Coordinates of second previous marker, cn5
			!		ndsx(5) = nodex_loc(nn-2)
			!		ndsy(5) = nodey_loc(nn-2)
			!		ndsz(5) = nodez_loc(nn-2)
			!		! Coordinates of second previous marker, cn6
			!		ndsx(6) = nodex_loc(nnFinish-1)
			!		ndsy(6) = nodey_loc(nnFinish-1)
			!		ndsz(6) = nodez_loc(nnFinish-1)	
			!		! Coordinates of second previous marker, cn7
			!		ndsx(7) = nodex_loc(nn-3)
			!		ndsy(7) = nodey_loc(nn-3)
			!		ndsz(7) = nodez_loc(nn-3)
			!		! Coordinates of second previous marker, cn8
			!		ndsx(8) = nodex_loc(nnFinish)
			!		ndsy(8) = nodey_loc(nnFinish)
			!		ndsz(8) = nodez_loc(nnFinish)	
			!		! Coordinates of second previous marker, cn9
			!		ndsx(9) = nodex_loc(nn-4)
			!		ndsy(9) = nodey_loc(nn-4)
			!		ndsz(9) = nodez_loc(nn-4)
			!		! Coordinates of second previous marker, cn10
			!		ndsx(10) = nodex_loc(nnStart)
			!		ndsy(10) = nodey_loc(nnStart)
			!		ndsz(10) = nodez_loc(nnStart)
			!		! Coordinates of second previous marker, cn11
			!		ndsx(11) = nodex_loc(nn-5)
			!		ndsy(11) = nodey_loc(nn-5)
			!		ndsz(11) = nodez_loc(nn-5)
			!else
			!	! Coordinates of the next markers, cn2
			!	ndsx(2) = nodex_loc(nn+1)
			!	ndsy(2) = nodey_loc(nn+1)
			!	ndsz(2) = nodez_loc(nn+1)
			!	! Coordinates of the previous marker, cn3
			!	ndsx(3) = nodex_loc(nn-1)
			!	ndsy(3) = nodey_loc(nn-1)
			!	ndsz(3) = nodez_loc(nn-1)
			!	! Coordinates of second next marker, cn4
			!	ndsx(4) = nodex_loc(nn+2)
			!	ndsy(4) = nodey_loc(nn+2)
			!	ndsz(4) = nodez_loc(nn+2)
			!	! Coordinates of second previous marker, cn5
			!	ndsx(5) = nodex_loc(nn-2)
			!	ndsy(5) = nodey_loc(nn-2)
			!	ndsz(5) = nodez_loc(nn-2)
			!	! Coordinates of second previous marker, cn6
			!	ndsx(6) = nodex_loc(nn+3)
			!	ndsy(6) = nodey_loc(nn+3)
			!	ndsz(6) = nodez_loc(nn+3)	
			!	! Coordinates of second previous marker, cn7
			!	ndsx(7) = nodex_loc(nn-3)
			!	ndsy(7) = nodey_loc(nn-3)
			!	ndsz(7) = nodez_loc(nn-3)
			!	! Coordinates of second previous marker, cn8
			!	ndsx(8) = nodex_loc(nn+4)
			!	ndsy(8) = nodey_loc(nn+4)
			!	ndsz(8) = nodez_loc(nn+4)	
			!	! Coordinates of second previous marker, cn9
			!	ndsx(9) = nodex_loc(nn-4)
			!	ndsy(9) = nodey_loc(nn-4)
			!	ndsz(9) = nodez_loc(nn-4)
			!	! Coordinates of second previous marker, cn8
			!	ndsx(10) = nodex_loc(nn+5)
			!	ndsy(10) = nodey_loc(nn+5)
			!	ndsz(10) = nodez_loc(nn+5)	
			!	! Coordinates of second previous marker, cn9
			!	ndsx(11) = nodex_loc(nn-5)
			!	ndsy(11) = nodey_loc(nn-5)
			!	ndsz(11) = nodez_loc(nn-5)
			!endif
			!!
			!flag2 = 0	
			!!
			!vec0u(1) = nn 
			!vec0u(2) = ll 
			!vec0u(3) = ib 
			!vec0u(4) = iii
			!vec0u(5) = jjc
			!vec0u(6) = kkk
			!vec0u(8) = lag_bod_loc(nn)
			!!
			!vec0w(1) = nn 
			!vec0w(2) = ll 
			!vec0w(3) = ib 
			!vec0w(4) = iic
			!vec0w(5) = jjc
			!vec0w(6) = kkk
			!vec0w(8) = lag_bod_loc(nn)
			!!!
			!	!
			!	! ( 0, 90 ] First quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
			!	if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
			!		qFlag = 1
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,2)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,2)
			!		call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
			!	endif
			!	endif
			!	! ( 90, 180 ] 2nd quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .le. -margin) then
			!	if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
			!		qFlag = 2
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,2)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,2)
			!		call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
			!	endif
			!	endif
			!	! ( 180, 270 ] 3rd quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .le. margin) then
			!	if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
			!		qFlag = 3
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,2)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,2)
			!		call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
			!	endif
			!	endif
			!	! ( 270, 360 ] 4th quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .gt. margin) then
			!	if ( (ndsz(2) - ndsz(1)) .le. margin) then
			!		qFlag = 4
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,2)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,2)
			!		call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
			!	endif
			!	endif
			!	!
			!ENDIF	! Ensuring processor ID matches subdomain ID???
		!enddo	! Sweeping markers of the inner layers
		!
		enddo	! sweeping stations
		!
		!
	endif ! Filtering out procesors
	!
	enddo ! End of the  loop sweeping the domains

!######################################################################
	END SUBROUTINE searchGhostCells
!######################################################################	


!######################################################################			
	SUBROUTINE setQuadrant_u(vec0,ndsx,ndsz,fieldF)
!######################################################################		
		use imb
		use mpi
		use multidata

		implicit none

		! temporal variables
		DOUBLE PRECISION:: temp, t1, t2

		! Input valriables
		INTEGER, INTENT(IN):: vec0(8)
		INTEGER:: nn, ll, ib, iii,jjj,kkk, qF, M
		INTEGER, INTENT(IN):: fieldF
		DOUBLE PRECISION, INTENT(IN)::ndsx(19),ndsz(19)

		! safety variables
		DOUBLE PRECISION:: margin

		! Intersections
		DOUBLE PRECISION:: ys, ys2

		! Locations of faces
		DOUBLE PRECISION:: as4,as3,as2,as,ae,ae2,ae3

		DOUBLE PRECISION:: cs3,cs2,cs,ce,ce2,ce3

		DOUBLE PRECISION:: zc0,zc1, zc2, zc3, zc4,zc5
		! Indeces of faces
		INTEGER:: ke0,ke,ke2,ke3,ke4,ke5
		INTEGER:: ie,is, is2, is3,is4

		! Special variables for avoiding selecting cell outise the geometry in the 2nd and 4th quarters
		INTEGER:: isq, keq, ieq
		DOUBLE PRECISION:: asq, aeq
		INTEGER:: fxq1, fzq1, fxq2, fzq2, fxs3, fzs3, fxk3, fzk3
		!
		! Flags
		INTEGER:: flag1, flag2,flagA,flagB,flagC
		INTEGER:: slanted, debugF
		DOUBLE PRECISION:: fx, fz

		! Interfaces
		INTEGER:: vec1(8)
		!
		!
		!
		nn  = vec0(1)
		ll  = vec0(2)
		ib  = vec0(3)
		iii = vec0(4)
		jjj = vec0(5)
		kkk = vec0(6)
		qF  = vec0(7)
		 M  = vec0(8)
		 !
		vec1(1) = nn
		vec1(2) = ib
		vec1(3) = ll
		vec1(4) = iii
		vec1(5) = jjj
		vec1(6) = kkk
		vec1(7) = qF
		vec1(8) = M

		margin = 1.0e-5

	!	if (myrank.eq. master ) then ! The control is passed down to the master processor
		if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN
			IF(imb_block_loc(nn).eq.dom_id(ib)) then
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 1st quadrant
				
		if (qF.eq.1) then

		as = dom(ib)%x(iii-1) 
		as2 = dom(ib)%x(iii-2)
		as3 = dom(ib)%x(iii-3)
		as4 = as3 - abs(as3-as2)!dom(ib)%x(iii-4)
		asq = as

		ae = dom(ib)%x(iii) 
		aeq = as !ae
		
		ae2 = dom(ib)%x(iii+1)
		ae3 = dom(ib)%x(iii+2)
		
		cs3 = dom(ib)%z(kkk-3)
		cs2 = dom(ib)%z(kkk-2)
		cs = dom(ib)%z(kkk-1)

		ce = dom(ib)%z(kkk) 
		ce2 = dom(ib)%z(kkk+1)
		ce3 = dom(ib)%z(kkk+2)	

		zc1 = dom(ib)%zc(kkk)	! cell centre. We want to obtain the mirror value for this cell centre
		zc2 = dom(ib)%zc(kkk+1)	! cell centre. We want to obtain the mirror value for this cell centre
		zc3 = dom(ib)%zc(kkk+2)	! cell centre. We want to obtain the mirror value for this cell centre
		zc4 = dom(ib)%zc(kkk+3)	! cell centre. We want to obtain the mirror value for this cell centre		
		zc5 = zc4 + abs(zc4-zc3)!dom(ib)%zc(kkk+4)	! cell centre. We want to obtain the mirror value for this cell centre		
		!
		ie = iii; ke = kkk
		ke2 = kkk+1; ke3 = kkk+2; ke4 = kkk+3; ke5 = kkk+4

		is = iii-1 ; is2 = iii-2; is3 = iii - 3; is4 = iii-4
		isq = is; keq = ke
		ieq = is	

		fx = 1
		fz = 1
		fxq1 = fx
		fzq1 = fz
		fxq2 = fx
		fzq2 = fz
		fxs3 = fx
		fzs3 = fz

		endif

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 2nd quadrant

		if (qF.eq.2) then

			ae3 = dom(ib)%x(iii-3)
			ae2 = dom(ib)%x(iii-2)	
			ae = dom(ib)%x(iii-1) 
	
			as = dom(ib)%x(iii) 
			asq = ae
			aeq = ae

			as2 = dom(ib)%x(iii-2)
			as3 = dom(ib)%x(iii-3)
			as4 = as3 - abs(as3 -as2) !dom(ib)%x(iii-4)

			

			cs3 = dom(ib)%z(kkk-3)
			cs2 = dom(ib)%z(kkk-2)
			cs = dom(ib)%z(kkk-1)
	
			ce = dom(ib)%z(kkk) 
			ce2 = dom(ib)%z(kkk+1)
			ce3 = dom(ib)%z(kkk+2)			

			zc1 = dom(ib)%zc(kkk)	! cell centre. We want to obtain the mirror value for this cell centre
			zc2 = dom(ib)%zc(kkk-1)	! cell centre. We want to obtain the mirror value for this cell centre
			zc3 = dom(ib)%zc(kkk-2)	! cell centre. We want to obtain the mirror value for this cell centre
			zc4 = dom(ib)%zc(kkk-3)	! cell centre. We want to obtain the mirror value for this cell centre
			zc5 = zc4 - abs(zc4-zc3)!dom(ib)%zc(kkk-4)	! cell centre. We want to obtain the mirror value for this cell centre
			!
			ie = iii-1; ke = kkk
			ke2 = kkk-1; ke3 = kkk-2; ke4 = kkk-3; ke5 = kkk-4
	
			is = iii; is2 = iii-2; is3 = iii - 3; is4 = iii-4
			isq = is; keq = kkk + 1
			ieq = ie
				
			fx = -1
			fz = -1
			fxq1 = fx
			fzq1 = fz
			fxq2 = -fx
			fzq2 = -fz
			fxs3 = -fx
			fzs3 = -fz
	
			endif


		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 3rd quadrant
				
			if (qF.eq.3) then

				ae3 = dom(ib)%x(iii-3)
				ae2 = dom(ib)%x(iii-2)	
				ae = dom(ib)%x(iii-1) 
		
				as = dom(ib)%x(iii) 
				asq = as
				aeq = as
	
				as2 = dom(ib)%x(iii+1)
				as3 = dom(ib)%x(iii+2)
				as4 = as3 + abs(as3 - as2) !dom(ib)%x(iii+3)
	
				
	
				cs3 = dom(ib)%z(kkk-3)
				cs2 = dom(ib)%z(kkk-2)
				cs = dom(ib)%z(kkk-1)
		
				ce = dom(ib)%z(kkk) 
				ce2 = dom(ib)%z(kkk+1)
				ce3 = dom(ib)%z(kkk+2)	

				zc1 = dom(ib)%zc(kkk)	! cell centre. We want to obtain the mirror value for this cell centre
				zc2 = dom(ib)%zc(kkk-1)	! cell centre. We want to obtain the mirror value for this cell centre
				zc3 = dom(ib)%zc(kkk-2)	! cell centre. We want to obtain the mirror value for this cell centre
				zc4 = dom(ib)%zc(kkk-3)	! cell centre. We want to obtain the mirror value for this cell centre
				zc5 = zc4 - abs(zc4 - zc3) ! dom(ib)%zc(kkk-4)	! cell centre. We want to obtain the mirror value for this cell centre
				!
				ie = iii-1; ke = kkk
				ke2 = kkk-1; ke3 = kkk-2; ke4 = kkk-3;  ke5 = kkk-4
		
				is = iii; is2 = iii+1; is3 = iii+2; is4 = iii+3
				isq = is; keq = ke		
				ieq = is
						
			!	is = iii; is2 = iii; is3 = iii + 1

				fx = -1
				fz = -1
				fxq1 = -fx
				fzq1 = -fz
				fxq2 = fx
				fzq2 = fz
				fxs3 = fx
				fzs3 = fz
			
		
				endif			

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 4th quadrant
				
			if (qF.eq.4) then

				ae3 = dom(ib)%x(iii+2)
				ae2 = dom(ib)%x(iii+1)	
				ae = dom(ib)%x(iii) 
				!
				as = dom(ib)%x(iii-1) 
				asq = ae
				aeq = ae
				as2 = dom(ib)%x(iii+1)
				as3 = dom(ib)%x(iii+2)
				as4 = as3 + abs(as3 - as2) ! dom(ib)%x(iii+3)
				
				cs3 = dom(ib)%z(kkk-3)
				cs2 = dom(ib)%z(kkk-2)
				cs = dom(ib)%z(kkk-1)
		
				ce = dom(ib)%z(kkk) 
				ce2 = dom(ib)%z(kkk+1)
				ce3 = dom(ib)%z(kkk+2)	

				zc1 = dom(ib)%zc(kkk)	! cell centre. We want to obtain the mirror value for this cell centre
				zc2 = dom(ib)%zc(kkk+1)	! cell centre. We want to obtain the mirror value for this cell centre
				zc3 = dom(ib)%zc(kkk+2)	! cell centre. We want to obtain the mirror value for this cell centre
				zc4 = dom(ib)%zc(kkk+3)	! cell centre. We want to obtain the mirror value for this cell centre
				zc5 = zc4 + abs(zc4 - zc3) !dom(ib)%zc(kkk+4)	! cell centre. We want to obtain the mirror value for this cell centre
				!
				ie = iii; ke = kkk
				ke2 = kkk+1; ke3 = kkk+2; ke4 = kkk+3;  ke5 = kkk+4
		
				is = iii-1; is2 = iii+1; is3 = iii+2; is4 = iii+3
				isq = ie; keq = kkk - 1
				ieq = ie
		
				fx = 1
				fz = 1
				fxq1 = fx
				fzq1 = fz
				fxq2 = -fx
				fzq2 = -fz
				fxs3 = -fx
				fzs3 = -fz
		
				endif

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Checking quadrants

		flag1 = 0
		flag2 = 0
		flagA = 0
		flagB = 0
		flagC = 0
		!
		slanted = 1

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE E
			! debug
		!!if((nn.gt.416).and.(nn.lt.(449))) then
		!!	!	!	write(6,*) nn, k ,rott_loc(nn)
		!!			write(6,*) nn, qf
		!!			write(6,*) ae, as,as3
		!!			write(6,*) zc1
		!!			write(6,*) ndsx(6),ndsx(4), ndsx(2) 
		!!			write(6,*) ndsx(1),ndsx(3), ndsx(5)
		!!			write(6,*) ndsz(6),ndsz(4), ndsz(2)
		!!			write(6,*) ndsz(1),ndsz(3), ndsz(5)
		!!	!		write(6,*) dom(ib)%mucx(ie,jjj,ke),qF
		!!	!		write(6,*) !dom(ib)%uoo(ie,jjj,ke)
		!!!	!	!write(6,*) qF, fieldF, fieldVal
		!!!	!	!write(6,*) vec2(1),vec2(2),vec2(3)
		!!!	!	!write(6,*) vec2(4),vec2(5),vec2(6)
		!!!	!	!write(6,*) vec2(7),vec2(8)
		!!!	!	!write(6,*) vec3(1),vec3(2),vec3(3)
		!!!	!	!write(6,*) "======================="
		!!	endif
		!	if((nn.gt.23).and.(nn.lt.(27))) then
		!	!	!	write(6,*) nn, k ,rott_loc(nn)
		!			write(6,*) nn, ie,jjj,ke
		!			write(6,*) ae, as 
		!			write(6,*) ndsx(2), ndsx(1)
		!	!		write(6,*) dom(ib)%mucx(ie,jjj,ke),qF
		!	!		write(6,*) !dom(ib)%uoo(ie,jjj,ke)
		!	!	!write(6,*) qF, fieldF, fieldVal
		!	!	!write(6,*) vec2(1),vec2(2),vec2(3)
		!	!	!write(6,*) vec2(4),vec2(5),vec2(6)
		!	!	!write(6,*) vec2(7),vec2(8)
		!	!	!write(6,*) vec3(1),vec3(2),vec3(3)
		!	!	!write(6,*) "======================="
		!	endif
		if ( ( ndsx(2) -  ae )*fx.gt. -margin ) then	! The East Face is pierced for the FIRTS TIME
			!
			ys = ndsz(1) + (ndsz(2) - ndsz(1))*(ae - ndsx(1))/(ndsx(2) - ndsx(1))
			!
			! case a.1.1.1	 Checking if u(ie,jjj,ke) is above cn-cn2
			!12345
			if(dom(ib)%mucx(ie,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1)then
			slanted = 1
			! Checking for vertical segments
			if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then
				!if( (zc1-ndsz(1))*fzq2 .gt. -margin)then 	! horizontal lower bound
				!if( (zc1-ndsz(2))*fzq2 .lt. margin)then	! horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east	bound
				debugF = 1
				call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0 ! The segment is not slanted
				else
					flagC = 1 ! first layer not included
				!endif
				!endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(4) - ndsz(2)) .lt. margin ) ) then ! checking corners 1-2q and 3-4q
				if( (zc1-ndsz(2))*fzq2 .lt. margin)then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				debugF = 2
				call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				else
				!call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
				!slanted = 0
				endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(3)).lt.margin).and.
     & 			(abs(ndsz(2) - ndsz(1)) .lt. margin ) ) then ! checking corners 2-1q and 4-3q
				if( (as-ndsx(1))*fxq2 .lt. margin)then
				if( (zc1-ndsz(2))*fzq2 .lt. margin)then
				debugF = 3
				call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				!2else
				!2call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				!2slanted = 0
				endif
				!else
				!	if( (zc1-ndsz(2))*fzq2 .lt. margin)then
				!	call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				!	slanted = 0
				!	!2else
				!	!2call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				!	!2slanted = 0
				!	endif
				endif
			endif
			if((abs(ndsx(4)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(2)) .lt. margin ) ) then ! checking corners 2-3q and 4-1q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc1-ndsz(1))*fzq2 .lt. margin)then
				debugF = 4
				call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				!2else
				!2call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				!2slanted = 0
				endif
				else
			!		if( (zc1-ndsz(1))*fzq2 .lt. margin)then
			!		call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
			!		slanted = 0
			!		!2else
			!		!2call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
			!		!2slanted = 0
			!		endif
				endif
			endif
			if((abs(ndsx(2)-ndsx(1)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(3)) .lt. margin ) ) then ! checking corners 3-2q and 1-4q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc1-ndsz(1))*fzq2 .gt. -margin)then
				debugF = 5
				call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				endif
				endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then
				if( (zc1-ndsz(1))*fzq2 .lt. margin)then
				debugF = 6
				call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				!if(nn.lt.8) then
				!	write(*,*) "zc1", ie, ke
				!	write(*,*) ae, zc1
				!endif
				else
				flagA = 2		! Horizontal Segment not included
				slanted = 0
				!if(nn.lt.8) then
				!	debugF = -1
				!	write(*,*) "zc1 missed"
				!endif
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc1 - ys)*fz .gt. -margin ) then		
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2  !CHECK12345 
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
		        ! There  may be an issue			
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
					!dom(ib)%uoo(ie,jjj,ke) = t2
				endif
			!	flagA = 1
			!endif
			! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
			else
				!flag2 = 
				flagA = 1 ! First layer not selected
		
			endif
			endif ! slanted flag
			!
			!else!12345
			!
			! debug
			! if((nn.gt.9240).and.(nn.lt.(9240+126))) then
			! !	write(6,*) nn, k ,rott_loc(nn)
			! 	if(fieldF.eq.1) then
			! 	write(6,*) nn, ie,jjj,ke
			! 	write(6,*) dom(ib)%mucx(ie,jjj,ke),qF
			! 	write(6,*) dom(ib)%ustar(ie,jjj,ke),  fieldF
			! 	endif
			! 	if(fieldF.eq.2) then
			! 	write(6,*) nn, ie,jjj,ke
			! 	write(6,*) dom(ib)%mucx(ie,jjj,ke),qF
			! 	write(6,*) dom(ib)%u(ie,jjj,ke),  fieldF
			! 	endif
			! !write(6,*) qF, fieldF, fieldVal
			! !write(6,*) vec2(1),vec2(2),vec2(3)
			! !write(6,*) vec2(4),vec2(5),vec2(6)
			! !write(6,*) vec2(7),vec2(8)
			! !write(6,*) vec3(1),vec3(2),vec3(3)
			! !write(6,*) "======================="
			! endif
			!
			endif!12345 
			!
			!
			!
		! case a.1.1.2	 Checking if u(ie,jjj,ke2) is above cn-cn2
			!12345 
			if(dom(ib)%mucx(ie,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			slanted = 1
			if( abs(ndsx(4) - ndsx(1)) .lt. margin ) then	! Checking for vertical segments
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then	!	horizontal lower bound
				if( (zc2-ndsz(4))*fzq2 .lt. margin)then		!	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical outer bound
				debugF = 220
				call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				slanted = 0
				else
					flagC = 1 ! first layer not included
				endif
				endif
				!endif
			elseif( abs(ndsx(2) - ndsx(1)) .lt. margin ) then	! Checking for vertical segments
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then	!	horizontal lower bound
				if( (zc2-ndsz(2))*fzq2 .lt. margin)then		!	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical west bound
				debugF = 221
				call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				slanted = 0
				else
					flagC = 1
				endif
				endif
				!endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then		!	vertical west bound
				if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
				debugF = 222
				call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				slanted = 0
				if(nn.lt.8)then
					!write(*,*) "zc2", nn, ie, ke2
					!write(*,*) ae, zc2
				endif
				else
					write(*,*) "zc2 missed"
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc2 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				! There  may be an issue			
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                    !dom(ib)%uoo(ie,jjj,ke2) = t2
				endif
			!	flagA = 1
			else
				!flagA = 1
				!flagC = 1
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
			!
			! case a.1.1.2	 Checking if u(ie,jjj,ke3) is above cn-cn2
			!12345 
			if(dom(ib)%mucx(ie,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			slanted = 1
			if( abs(ndsx(6) - ndsx(1)) .lt. margin ) then	! Checking for vertical segments
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then 	!	horizontal lower bound
				if( (zc3-ndsz(6))*fzq2 .lt. margin)then		!	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
				debugF = 330
				call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
				slanted = 0
				else
					flagC = 1 ! first layer not included
				endif
				!endif
				endif
			elseif( abs(ndsx(4) - ndsx(1)) .lt. margin ) then 	! Checking for vertical segments
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then		!	horizontal lower bound 
				if( (zc3-ndsz(4))*fzq2 .lt. margin)then 		! 	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then			!	vertical east	bound
				debugF = 331
				call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
				slanted = 0
				else
					flagC = 1
				endif
				!endif
				endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(3)) .lt. margin ) then
				if( (ae-ndsx(3))*fxq2 .lt. margin)then			!	vertical east	bound
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then			!	vertical west	bound
				if( (zc3-ndsz(1))*fzq2 .lt. margin)then			! 	horizontal upper bound
				debugF = 332
				call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
				slanted = 0
				!if(nn.lt.8)then
				!	write(*,*) "zc3", nn, ie, ke3
				!	write(*,*) ae, zc3
				!endif
					!if((flagA.eq.1).and.(ke4.gt.8))then
					if(flagA.eq.2)then
					call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
					slanted = 0
					!if(nn.lt.8)then
					!	write(*,*) "zc4", nn, ie, ke4
					!	write(*,*) ae, zc4
					!endif
					endif
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc3 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				! There  may be an issue
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                    !dom(ib)%uoo(ie,jjj,ke3) = t2
				endif
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
			!
			!
		elseif ( ( ndsx(4) - ae )*fx .gt. -margin ) then	! The East face is pierced for the FIRST TIME
		!
		ys = ndsz(2) + (ndsz(4)-ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
		!
		!
		!
		!
			! case a.2.1.1	Checking if u(ie,jjj,ke) is above cn2-cn4
			!12345 
		if(dom(ib)%mucx(ie,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                    !dom(ib)%uoo(ie,jjj,ke) = t2
				endif
			!	flagB = 1
			else
				!flag2 = 1
				flagB = 1 ! firts layer not included within the nds4-nds1 segment
			endif
			endif!12345 

			! case a.2.1.2  Checking if u(ie,jjj,ke2) is above cn2-cn4 
			!12345 
			if(dom(ib)%mucx(ie,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if( ( zc2 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                    !dom(ib)%uoo(ie,jjj,ke2) = t2
				endif
			!	flagB = 1
			else
			!	flagB = 1
			endif
			endif!12345 
			!
			!
		! case a.1.1.2	 Checking if u(ie,jjj,ke3) is above cn-cn2
			!12345 
			if(dom(ib)%mucx(ie,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if( ( zc3 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
		! There  may be an issue
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                    !dom(ib)%uoo(ie,jjj,ke3) = t2
				endif		
			endif
			endif!12345 
		!
		!
		!
		! WARNING A				
		!else			
		elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too
			!
            !
			!
			! case a.2.1.1	Checking if u(ieq,jjj,ke) is above cn4-cn6
			!12345 
			if(dom(ib)%mucx(ieq,jjj,ke).eq.0) then	! checking if this cell has already been flagged
				!if(1) then
				slanted = 1
				if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
				!if( (zc1-ndsz(3))*fzq2 .gt. -margin)then			!	horizontal lower bound
				if( (zc1-ndsz(2))*fzq2 .lt. margin)then				!	horizontal upper bound
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then			!	vertical east bound
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					slanted = 0
					endif
				endif
				!endif
				endif
				if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
					if( (aeq-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
					if( (aeq-ndsx(2))*fxq2 .gt. -margin)then	!	vertical west bound
					if( (zc1-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					slanted = 0
					endif
					endif
					endif
				endif
			!	! Checking for slanted segments
				if(slanted.eq.1)then
				if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc1 - ys2)*fzq1 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fzq1 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke) = t2
					endif
			! There  may be an issue			
				else
					! WARNING	WARNING	WARNING
					if( ( zc1 - ndsz(4) )*fzq1 .gt. -margin)then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke) = t2
					endif
				endif ! ndsx(3)
				endif! slanted flag
				endif!12345 
			!
			!
			!
			! case a.2.1.2  Checking if u(ieq,jjj,ke2) is above cn4-cn6 
				!12345 
				if(dom(ib)%mucx(ieq,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
				!if(1) then
				slanted = 1
				if( abs(ndsx(4) - ndsx(1)) .lt. margin ) then			! Checking for vertical segments
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc2-ndsz(4))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					slanted = 0
					endif
				endif
				!endif
				elseif( abs(ndsx(2) - ndsx(1)) .lt. margin ) then		! Checking for vertical segments
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc2-ndsz(2))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					slanted = 0
					endif
				endif
				!endif
				endif
				if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
					if( (aeq-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
					if( (aeq-ndsx(2))*fxq2 .gt. -margin)then	!	vertical west bound
					if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					slanted = 0
					endif
					endif
					endif
				endif
				! Checking for slanted segments
				if(slanted.eq.1)then
				if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc2 - ys2)*fzq1 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq1 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke2) = t2
						!if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke2) = t2
					endif
				!WARNING	WARNING	WARNING
				elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq1 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke2) = t2
					endif
				else
					if( ( zc2 - ndsz(6) )*fzq1 .gt. -margin)then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke2) = t2
					endif
				endif		
				endif!12345 
				endif ! slanted flag
				!
				!
				!
				!
				! case a.1.1.2	 Checking if u(ieq,jjj,ke3) is above cn4-cn6
				!12345 
				if(dom(ib)%mucx(ieq,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
				!if(1) then
				slanted = 1
				if( abs(ndsx(6) - ndsx(1)) .lt. margin ) then			! Checking for vertical segments
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc3-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then
						call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					slanted = 0
					endif
				endif
				!endif
				elseif( abs(ndsx(4) - ndsx(1)) .lt. margin ) then		! Checking for vertical segments
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc3-ndsz(4))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
						call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					slanted = 0
					endif
				endif
				!endif
				endif
				if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
					if( (aeq-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
					if( (aeq-ndsx(2))*fxq2 .gt. -margin)then	!	vertical west bound
					if( (zc3-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					slanted = 0
						if(flagA.eq.2)then
						call setMirror_u(vec1,ndsx,ndsz,ieq,ke4,aeq,zc4,t2)
						slanted = 0
						endif
					endif
					endif
					endif
				endif
				! Checking for slanted segments
				if(slanted.eq.1)then
				if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc3 - ys2)*fzq1 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc3 - ys2)*fzq1 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke3) = t2
					endif
				! WARNING	WARNING	WARNING
				elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc3 - ys2)*fzq1 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke3) = t2
				   !if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke3) = t2
					endif
				else
					if( ( zc3 - ndsz(4) )*fzq1 .gt. -margin)then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke3) = t2
					endif
				endif
				endif ! slanted flag
				endif!12345 
				!
				!
				!
				!
				flagC = 1 ! first layer not included
				!
				!
				!
				!
		! WARNING A	
		else	! The East face has not been pierced 
			!flag1 = 1
			flagC = 1 ! first layer not included
			flagA = 2		! Horizontal Segment not included
			!
		endif !!! FINISHED CHECKING FACE E
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S
		!
		!12345 
		if(dom(ib)%mucx(is,jjj,ke).eq.0) then	! checking if this cell has already been flagged
        !if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
			!if( (zc1-ndsz(3))*fzq2 .gt. -margin)then		! Horizontal lower bound
			if( (zc1-ndsz(2))*fzq2 .lt. margin)then			! Horizontal upper bound
			if( (as-ndsx(1))*fx .lt. margin)then			! Vertical west bound
				! 1q	> 0			> 0		pierced
				! 2q	> 0			> 0		pierced
				! 3q	< 0			> 0		pierced 
				! 4q	< 0			> 0		pierced
				call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
				slanted = 0
			endif
			endif
			endif
		if( abs(ndsz(2) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as-ndsx(3))*fxq2 .lt. margin)then		! Vertical west bound
			if( (as-ndsx(2))*fxq2 .gt. -margin)then		! Vertical east bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then		! Horizontal lower bound
			call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
			slanted = 0
			!else
			!call setMirror_u(vec1,ndsx,ndsz,is,ke2,as,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
		if(slanted.eq.1)then
		! Checking for slanted segments
		if ( (ndsx(3) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
			! 1q	if pierced  ./	ndsx(3) < as	fx > 0	pass
			! 2q		||		.\	ndsx(3) > as	fx < 0	pass
			! 3q		||		/*	ndsx(3) > as	fx < 0	pass
			! 4q		||		\*	ndsx(3) < as	fx > 0	pass
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is,jjj,ke) is bellow cn3-cn
			if( ( zc1 - ys)*fz .gt. -margin ) then
				! 1q	if inside   ./	zc1 > ys	fz > 0	pass
				! 2q		||  	.\	zc1 < ys	fz < 0	pass
				! 3q		||	    /*	zc1 < ys	fz < 0	pass
				! 4q		||	    \*	zc1 > ys	fz > 0	pass
				if ( ( ndsx(5) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					! 1q	if pierced  twice	/*	ndsx(5) > as	fx > 0	pass
					! 2q		||				\*	ndsx(5) < as	fx < 0	pass
					! 3q		||				./	ndsx(5) < as	fx < 0	pass
					! 4q		||				.\	ndsx(5) > as	fx > 0	pass
					ys2=ndsz(5)+(ndsz(3)-ndsz(5))*(as-ndsx(5))/(ndsx(3)-ndsx(5))	
					if( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if inside   /*	zc1 < ys2	fz > 0	pass
						! 2q		||	   	\*	zc1 > ys2	fz < 0	pass
						! 3q		||	   	./	zc1 > ys2	fz < 0	pass
						! 4q		||	   	.\	zc1 < ys2	fz > 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q	    always      	\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q	    always      	_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  again	*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*\	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 /
					!
					! 2q	 |.
					!		 /
					!
					!		/
					! 3q	|*
					!
					!		/
                    ! 4q   *|
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                    !dom(ib)%uoo(is,jjj,ke) = t2
                    !endif
				endif		
			endif
			!				
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is,jjj,ke) is bellow cn3-cn5 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(7) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
                    if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
            	        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
            	        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
            	        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
            	        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	    !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                    !dom(ib)%uoo(is,jjj,ke) = t2
                    !endif
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is,jjj,ke) is bellow cn5-cn7 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(9) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(as-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
						!dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
                    if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2	
                    !dom(ib)%uoo(is,jjj,ke) = t2
                    !endif
				endif
			endif ! zc1
        else ! Face S has not been pierces so far
				!	1q	*|      is = iii-1
				!	2q	 |*     is = iii
				!	3q	 |.     is = iii
				!	4q	.|      is = iii-1
				if ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q		always  		\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q		always  		_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q	
                        ! debug
                        write(*,*)  "ndsx2"
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*/	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
                    endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	 |.
					!		 |
					!
					!		 |
					! 3q	 |*
					!
					!		 |
                    ! 4q	*|
					if( ( zc1 - ndsz(6) )*fzq2 .lt. margin)then
					if((qf.eq.2).or.(qf.eq.4))then
				!	if( ( ndsx(6) - as )*fxq2 .gt. -margin)then
				!	call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                !    !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2	
                !    !dom(ib)%uoo(is,jjj,ke) = t2
				!	endif
					else ! Warning: lets apply this only in qf = 1, 4
					call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2	
                    !dom(ib)%uoo(is,jjj,ke) = t2
                    endif
					endif
				endif
		endif	 ! ndsx(3)! Finished Check of Face S1 ke
		endif	! slanted flag
		endif!12345
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2
		!
		!12345 
		if(dom(ib)%mucx(is2,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then	! Checking for vertical segments
			if( (zc1-ndsz(3))*fzq2 .gt. -margin)then	! Horizontal lower bound
			!if( (zc1-ndsz(2))*fzq2 .lt. margin)then	! Horizontal upper bound
			if( (as2-ndsx(1))*fx .lt. margin)then		! Vertical east bound
				! 1q	> 0			> 0		pierced
				! 2q	> 0			> 0		pierced
				! 3q	< 0			> 0		pierced 
				! 4q	< 0			> 0		pierced
				call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
				slanted = 0
			endif
			!endif
			endif
		endif
		if( abs(ndsz(4) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(4))*fxq2 .lt. margin)then		! Vertical west bound
		!	if( (as2-ndsx(1))*fxq2 .gt. -margin)then	! Vertical east bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then
			call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
			slanted = 0
			endif
		!	endif
			endif
		endif
		! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		! 1q	if pierced  ./	ndsx(3) < as2	fxq2 > 0	pass
		! 2q		||		./	ndsx(3) < as2	fxq2 > 0	pass
		! 3q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
		! 4q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
		ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
		! case b.1.1.1  Checking if u(is2,jjj,ke) is2 bellow cn3-cn
		if( ( zc1 - ys)*fzq2 .gt. -margin ) then
			! 1q	if inside   ./	zc1 > ys	fzq2 > 0	pass
			! 2q		||  	./	zc1 > ys	fzq2 > 0	pass
			! 3q		||	    /*	zc1 < ys	fzq2 < 0	pass
			! 4q		||	    /*	zc1 < ys	fzq2 < 0	pass
			if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
				! 1q	if pierced  twice	/*	ndsx(5) > as2	fxq2 > 0	pass
				! 2q		||				/*	ndsx(5) > as2	fxq2 > 0	pass
				! 3q		||				./	ndsx(5) < as2	fxq2 < 0	pass
				! 4q		||				./	ndsx(5) < as2	fxq2 < 0	pass
				ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( zc1 - ys2)*fzq2 .lt. margin) then
					! 1q	if inside   /*	zc1 < ys2	fzq2 > 0	pass
					! 2q		||	   	/*	zc1 < ys2	fzq2 > 0	pass
					! 3q		||	   	./	zc1 > ys2	fzq2 < 0	pass
					! 4q		||	   	./	zc1 > ys2	fzq2 < 0	pass
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
					!dom(ib)%uoo(is2,jjj,ke) = t2
				endif
			elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
				! 2q	if pierced  again	*\	ndsx(2) < as2	fxq2 > 0	pass
				! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
				! 4q	if pierced  again	\.	ndsx(2) > as2	fxq2 < 0	pass
				ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					! 1q
					! 2q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
					! 3q
					! 4q	if pierced  again	\.	zc1 > ys2	fzq2 < 0	pass
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
					!dom(ib)%uoo(is2,jjj,ke) = t2
				endif
			elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				! 1q	if pierced  again	*\	ndsx(4) < as2	fxq2 > 0	pass
				! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
				! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
				! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
					! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
					! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
					! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
					!dom(ib)%uoo(is2,jjj,ke) = t2
				endif
			elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
					!dom(ib)%uoo(is2,jjj,ke) = t2
				endif
			else	! Face S has not been pierces so far BUT is inside the inmersed body
				! 1q	.|
				!		 /
				!
				! 2q	.|
				!		 /
				!
				!		/
				! 3q	|*
				!
				!		/
				! 4q	|*
				call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
				!dom(ib)%uoo(is2,jjj,ke) = t2
			endif		
		endif
						
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjj,ke) is2 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
					!dom(ib)%uoo(is2,jjj,ke) = t2
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke) is2 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2	
					!dom(ib)%uoo(is2,jjj,ke) = t2
				endif				
			endif ! zc1
		else ! Face S has not been pierces so far
				!	1q	*|
				!	2q	*|
				!	3q	|.
				!	4q	|.
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
					! 2q	if pierced  		*\	ndsx(2) < as2	fxq2 > 0	pass
					! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
					! 4q	if pierced  		\.	ndsx(2) > as2	fxq2 < 0	pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q
						! 2q	if pierced  	*\	zc1 < ys2	fzq2 > 0	pass
						! 3q
						! 4q	if pierced  	\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as2	fxq2 > 0	pass
					! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
					! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
						! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
						! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
						!dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
		!			! 1q	.|		.|
		!			!		 |		 |
		!			!
		!			! 2q	.|		 |.
		!			!		 |		 |
		!			!
		!			!		|		 |
		!			! 3q	|*3		 |*
		!			!
		!			!		|		 |
		!			! 4q	|*		*|
					!!! circle-square difference
					if( ( zc1 - ndsz(6) )*fzq2 .lt. margin)then
						! 2q 	fzq2 > 0	checking if n6z is above zc1? yes -> 
						! 4q	fzq2 < 0
					!call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					if((qf.eq.2).or.(qf.eq.4))then
					if( ( ndsx(6) - as2 )*fxq2 .lt. margin)then
						! -> 		2q	fxq2 > 0	checking if n6x pierces as2 for the first time? yes - >
						!-->	 	4q	fzq2 < 0
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					elseif( ( ndsx(8) - as2 )*fxq2 .lt. margin )then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					elseif( ( zc1 - ndsz(8) )*fzq2 .lt. margin )then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					endif
					else ! 1q and 3q
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					endif
					endif
				endif
		endif	 ! ndsx(3)! Finis2hed Check of Face S2 ke
		endif	! slanted flag
		endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2 ke2
		!
		!12345 
		if(dom(ib)%mucx(is2,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(4) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			!if( (zc2-ndsz(3))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc2-ndsz(4))*fzq2 .lt. margin)then					!	horizontal upper bound 
    			if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound	
				call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
				slanted = 0
				endif
			endif
			!endif
		elseif( abs(ndsx(2) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		!if( (zc2-ndsz(3))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc2-ndsz(2))*fzq2 .lt. margin)then					!	horizontal upper bound 
    		if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
			slanted = 0
			endif
		endif
		!endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
		! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
					!dom(ib)%uoo(is2,jjj,ke2) = t2
				endif		
				endif
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
				! case b.2.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn3-cn5 
				if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
					!dom(ib)%uoo(is2,jjj,ke2) = t2
				endif	
				endif
			! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn5-cn7 
				if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2	
					!dom(ib)%uoo(is2,jjj,ke2) = t2
				endif
				endif
		else ! Face S has not been pierces so far
				!!!!!!!!!!!! 
				! fxq2	 1 1	-1 1	-1-1	-1-1
				! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
				! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
				! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				!
				!
				! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
				!		call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
						!dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				else
				!! checking 1q and 3q
				!if((qf.eq.1).or.(qf.eq.3))then ! rectangle
				!if( ( zc1 - ndsz(6) )*fxq2 .lt. margin)then
				! call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
				!endif
				!!elseif( ( ndsx(2) - as4)*fxq2 .lt. margin)then
				!!ys2=ndsz(1)+(ndsz(2) - ndsz(1))*(as4-ndsx(1))/(ndsx(2)-ndsx(1))
				!!if ( ( zc1 - ys2)*fzq2 .lt. margin) then
				!!call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				!!endif
				!!
				!! checking 2q and 4q
				!elseif( ( zc1 - ndsz(6) )*fxq2 .lt. margin)then
				! call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
				!endif
				! !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2	
				! !dom(ib)%uoo(is3,jjj,ke) = t2
				!
				!!! circle-square difference
				!
				if( ( zc2 - ndsz(6) )*fzq2 .lt. margin)then
					if((qf.eq.2).or.(qf.eq.4))then
					if( ( ndsx(6) - as2 )*fxq2 .lt. margin)then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					elseif( ( ndsx(8) - as2 )*fxq2 .lt. margin )then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc2,t2)
					elseif( ( zc1 - ndsz(8) )*fzq2 .lt. margin )then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc2,t2)
					endif
					else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					endif
				endif
				endif
				!!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke2
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2 ke3
		!
		!12345 
		if(dom(ib)%mucx(is2,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
		slanted = 1!!!aaa
		!!!bbb
		!if(1) then	! checking if this cell has already been flagged
		!if(slanted.eq.0)then
		!if( abs(ndsx(8) - ndsx(7)) .lt. margin ) then			! Checking for vertical segments
		!	if( (zc3-ndsz(7))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		!	if( (zc3-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
		!		if( (as2-ndsx(1))*fxq2 .lt. margin)then
		!		call setMirror_u(vec1,ndsx,ndsz,is3,ke3,as2,zc3,t2)
		!		!slanted = 0
		!		endif
		!	endif
		!	endif
		!elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		!if( (zc3-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		!if( (zc3-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
		!	if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
		!	call setMirror_u(vec1,ndsx,ndsz,is3,ke3,as2,zc3,t2)
		!	!slanted = 0
		!	endif
		!endif
		!endif
		!endif
		!if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
		!	if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
		!	if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
		!	if( (zc3-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
		!	call setMirror_u(vec1,ndsx,ndsz,is3,ke3,as2,zc3,t2)
		!	!lanted = 0
		!	if(flagA.eq.1)then
		!		call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as2,zc4,t2)
		!		slanted = 0
		!	endif
		!	endif
		!	endif
		!	endif
		!endif
		!endif
		! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			 ! case b.1.1.1  Checking if u(is2,jjj,ke3) is2 bellow cn3-cn
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke3r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					 if( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 else
					 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
					 !dom(ib)%uoo(is2,jjj,ke3) = t2
				 endif		
			 endif				
		 ! The the West face has not yet been pierced	
		 elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			 ! case b.2.1.1  Checking if u(is2,jjj,ke3) is2 bellow cn3-cn5 
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke3r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					 if( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 else
					 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
					 !dom(ib)%uoo(is2,jjj,ke3) = t2
				 endif		
			 endif
		 ! The Face S has not been pierced so far	
		 elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			 ! case b.2.1.1  Checking if u(is2,jjj,ke3) is2 bellow cn5-cn7 
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 else
					 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2	
					 !dom(ib)%uoo(is2,jjj,ke3) = t2
				 endif
			 endif
		 elseif ( (ndsx(9) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as2-ndsx(9))/(ndsx(7)-ndsx(9))
			 ! case b.2.1.1  Checking if u(is2,jjj,ke3) is2 bellow cn5-cn7 
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
						 !dom(ib)%uoo(is2,jjj,ke3) = t2
					 endif
				 else
					 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2	
					 !dom(ib)%uoo(is2,jjj,ke3) = t2
				 endif
			 endif
		 else ! Face S has not been pierces so far
			 !!!!!!!!!!!! 
			 ! fxq2	 1 1	-1 1	-1-1	-1-1
			 ! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
			 ! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
			 ! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			 ! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			 !
			 !
			 ! 1q 	if pierced *\		 ys2 	> zc3 -	-> 	fzq2 = 1
			 ! 2q 	if pierced *\		 ys2 	> zc3 -	-> 	fzq2 = 1
			 ! 3q 	if pierced \. 		 ys2 	< zc3 -	-> 	fzq2 = -1
			 ! 4q 	if pierced \. 		 ys2 	< zc3 -	-> 	fzq2 = -1
			 if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
					 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
					 !dom(ib)%uoo(is2,jjj,ke3) = t2
				 endif
			 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
					 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
					 !dom(ib)%uoo(is2,jjj,ke3) = t2
				 endif
			 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
				 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
					 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke3) = t2
					 !dom(ib)%uoo(is2,jjj,ke3) = t2
				 endif
			 else
				!
				!!! circle-square difference
				!
				 if( ( zc3 - ndsz(8) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(8) - as2 )*fxq2 .lt. margin)then		
				 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				elseif( ( ndsx(10) - as2 )*fxq2 .lt. margin )then
				 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				elseif( ( zc3 - ndsz(10) )*fzq2 .lt. margin )then
				 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				endif
				else
				 call setMirror_u(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				endif
				 endif
			 endif
			 !!!!!!!!!!!!
		 endif	! ndsx(3) ! Finis2hed Check of Face S2 ke3
		 endif ! slanted flag
		 endif!12345  
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke
		!
		if(flagC.eq.1)then
		!12345 
	 	if(dom(ib)%mucx(is3,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(6) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc1-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
    			if( (as3-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				slanted = 0
				endif
			endif
			endif
		elseif( abs(ndsx(4) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc1-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
    		if( (as3-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as3-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as3-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
			slanted = 0
			endif
			endif
			endif
		endif
		! Checking for slanted segments
		if(slanted.eq.1)then 
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			 ! case b.1.1.1  Checking if u(is3,jjj,ke) is3 bellow cn3-cn
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					 if( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 else
					 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
					 !dom(ib)%uoo(is3,jjj,ke) = t2
				 endif		
			 endif				
		 ! The the West face has not yet been pierced	
		 elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			 ! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn3-cn5 
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					 if( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 else
					 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
					 !dom(ib)%uoo(is3,jjj,ke) = t2
				 endif		
			 endif
		 ! The Face S has not been pierced so far	
		 elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			 ! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn5-cn7 
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 else
					 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2	
					 !dom(ib)%uoo(is3,jjj,ke) = t2
				 endif
			 endif
		 elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			 ! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn5-cn7 
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
						 !dom(ib)%uoo(is3,jjj,ke) = t2
					 endif
				 else
					 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2	
					 !dom(ib)%uoo(is3,jjj,ke) = t2
				 endif
			 endif
		 else ! Face S has not been pierces so far
			 !!!!!!!!!!!! 
			 ! fxq2	 1 1	-1 1	-1-1	-1-1
			 ! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			 ! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			 ! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			 ! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			 !
			 !
			 ! 1q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			 ! 2q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			 ! 3q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			 ! 4q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
					 !dom(ib)%uoo(is3,jjj,ke) = t2
				 endif
			 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
					 !dom(ib)%uoo(is3,jjj,ke) = t2
				 endif
			 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
					 !dom(ib)%uoo(is3,jjj,ke) = t2
				 endif
			 else
			!	! checking 1q and 3q
			!	if((qf.eq.1).or.(qf.eq.3))then ! rectangle
			!	if( ( zc1 - ndsz(8) )*fxq2 .lt. margin)then
			!	 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
			!	endif
			!	!elseif( ( ndsx(2) - as4)*fxq2 .lt. margin)then
			!	!ys2=ndsz(1)+(ndsz(2) - ndsz(1))*(as4-ndsx(1))/(ndsx(2)-ndsx(1))
			!	!if ( ( zc1 - ys2)*fzq2 .lt. margin) then
			!	!call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
			!	!endif
			!	!
			!	! checking 2q and 4q
			!	elseif( ( zc1 - ndsz(8) )*fxq2 .lt. margin)then
			!	 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
			!	endif
			!	 !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2	
			!	 !dom(ib)%uoo(is3,jjj,ke) = t2
				!
				!!! circle-square difference
				!
				if( ( zc1 - ndsz(8) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				 if( ( ndsx(8) - as3 )*fxq2 .lt. margin)then
				 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				 elseif( ( ndsx(10) - as3 )*fxq2 .lt. margin )then
				 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				 elseif( ( zc1 - ndsz(10) )*fzq2 .lt. margin )then
				 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				 endif
				else
				 call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				endif
				endif
			 endif
			 !!!!!!!!!!!!
		 endif	! ndsx(3) ! Finis3hed Check of Face S3 ke
		 endif!12345 
		endif ! slanted flag
		endif ! flagC
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke2
		!
		!12345 
		!!!if(flagC.eq.1)then
		if(dom(ib)%mucx(is3,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(6) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc2-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
				if( (as3-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				slanted = 0
				endif
			endif
			endif
		elseif( abs(ndsx(4) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc2-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as3-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as3-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as3-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
					!dom(ib)%uoo(is3,jjj,ke2) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn3-cn5 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
					!dom(ib)%uoo(is3,jjj,ke2) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2	
					!dom(ib)%uoo(is3,jjj,ke2) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
						!dom(ib)%uoo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2	
					!dom(ib)%uoo(is3,jjj,ke2) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
					!dom(ib)%uoo(is3,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
					!dom(ib)%uoo(is3,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
					!dom(ib)%uoo(is3,jjj,ke2) = t2
				endif
			else
				!
				!!! circle-square difference
				!
		 		if( ( zc2 - ndsz(8) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(8) - as3 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				elseif( ( ndsx(10) - as3 )*fxq2 .lt. margin )then
				call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				elseif( ( zc2 - ndsz(10) )*fzq2 .lt. margin )then
				call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				endif
				else
				call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S3 ke2
		endif ! slanted flag
		endif!12345
		!!!endif! flagC 
		!
		!
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S4 ke
		!
		!12345 
		if(dom(ib)%mucx(is4,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		!if( (flagC.eq.1).or.(flagD.eq.1)) then
		if( (flagC.eq.1) ) then
		slanted = 1
		if( abs(ndsx(6) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc1-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then
        	call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(4) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc1-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as4-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as4-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as4- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is4,jjj,ke) is4 bellow cn3-cn
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as4)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is4,jjj,ke) is4 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as4)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is4,jjj,ke) is4 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2	
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif
			endif
		elseif ( (ndsx(9) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as4-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is4,jjj,ke) is4 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2	
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif
			endif
		elseif ( (ndsx(11) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as4-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is4,jjj,ke) is4 bellow cn5-cn9 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
						!dom(ib)%uoo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2	
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as4	but if is4 is pierced *\ 	ndsx(4)	< as4	-> 	fxq2 = 1
			! 2q *\						if is4 is pierced *\	ndsx(4)	< as4	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as4	but if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			! 4q \.						if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif
			elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif
			elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif
			elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif
			elseif ( ( ndsx(12) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as4-ndsx(10))/(ndsx(12)-ndsx(10))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif
			elseif ( ( ndsx(14) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as4-ndsx(12))/(ndsx(14)-ndsx(12))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2
					!dom(ib)%uoo(is4,jjj,ke) = t2
				endif
			else
			!	! checking 1q and 3q
			!	if((qf.eq.1).or.(qf.eq.3))then ! rectangle
			!	if( ( zc1 - ndsz(14) )*fxq2 .lt. margin)then
			!	call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			!	endif
			!	!elseif( ( ndsx(2) - as4)*fxq2 .lt. margin)then
			!	!ys2=ndsz(1)+(ndsz(2) - ndsz(1))*(as4-ndsx(1))/(ndsx(2)-ndsx(1))
			!	!if ( ( zc1 - ys2)*fzq2 .lt. margin) then
			!	!call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			!	!endif
			!	!
			!	! checking 2q and 4q
			!	elseif( ( zc1 - ndsz(14) )*fxq2 .lt. margin)then
			!	call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			!	endif
			!	!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke) = t2	
			!	!dom(ib)%uoo(is4,jjj,ke) = t2
				!
				!!! circle-square difference
				!
				if( ( zc1 - ndsz(14) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ??? if( ( ndsx(12) - as4 )*fxq2 .lt. margin)then
				if( ( ndsx(14) - as4 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				!!! check ??? elseif( ( ndsx(14) - as4 )*fxq2 .lt. margin )then
				elseif( ( ndsx(16) - as4 )*fxq2 .lt. margin )then
				call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				!!! check ??? elseif( ( zc1 - ndsz(14) )*fzq2 .lt. margin )then
				elseif( ( zc1 - ndsz(16) )*fzq2 .lt. margin )then
				call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				endif
				else
				call setMirror_u(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis4hed Check of Face S4 ke
		endif	! checking for flagC / flagD
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		!
	    !!!!!!!!!!!!!!!!!!
	    !!! CHECKING FACE S4 ke2
	    !
	    !12345 
		if(dom(ib)%mucx(is4,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		!if( (flagC.eq.1).or.(flagD.eq.1)) then
		if( (flagC.eq.1) ) then
		slanted = 1
		if( abs(ndsx(8) - ndsx(5)) .lt. margin ) then			! Checking for vertical segments
			if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc2-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc2-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as4-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as4-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as4- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as4)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
					!dom(ib)%uoo(is4,jjj,ke2) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn3-cn5 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as4)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
					!dom(ib)%uoo(is4,jjj,ke2) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2	
					!dom(ib)%uoo(is4,jjj,ke2) = t2
				endif
			endif
		elseif ( (ndsx(9) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as4-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2	
					!dom(ib)%uoo(is4,jjj,ke2) = t2
				endif
			endif
		elseif ( (ndsx(11) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as4-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn5-cn9 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
						!dom(ib)%uoo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2	
					!dom(ib)%uoo(is4,jjj,ke2) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as4	but if is4 is pierced *\ 	ndsx(4)	< as4	-> 	fxq2 = 1
			! 2q *\						if is4 is pierced *\	ndsx(4)	< as4	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as4	but if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			! 4q \.						if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
					!dom(ib)%uoo(is4,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
					!dom(ib)%uoo(is4,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
					!dom(ib)%uoo(is4,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is4,jjj,ke2) = t2
					!dom(ib)%uoo(is4,jjj,ke2) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ???
				if( ( zc2 - ndsz(10) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ???
				if( ( ndsx(10) - as4 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				!!! check ???
				elseif( ( ndsx(12) - as4 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				!!! check ???
				elseif( ( zc2 - ndsz(12) )*fzq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				endif
				else
				!!! check ??? pass
				call setMirror_u(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis4hed Check of Face S4 ke2
		endif ! slanted flag
		endif	! checking for flagC / flagD
		endif!12345 
		!
		!
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!!! CHECKING FACE S2 ke4
		!!
		!12345 
		if(dom(ib)%mucx(is2,jjj,ke4).eq.0) then	! checking if this cell has already been flagged
		!if( (flagA.eq.1).or.(flagB.eq.1)) then
		!!if( (flagA.eq.2) ) then
		!!if(1) then	! checking if this cell has already been flagged
		!!!aaa
		slanted = 1
		if( abs(ndsx(8) - ndsx(5)) .lt. margin ) then			! Checking for vertical segments
		!if( abs(ndsx(8) - ndsx(9)) .lt. margin ) then			! Checking for vertical segments
			if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc4-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc4-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc4-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        !! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn3-cn
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn3-cn5 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2	
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif
			endif
		elseif ( (ndsx(9) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as2-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2	
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif
			endif
		elseif ( (ndsx(11) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as2-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn5-cn9 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
						!dom(ib)%uoo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2	
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif
			endif
		else ! Face S has not been pierces so far
		!!!!!!!!!!!! 
		! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
			! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2
					!dom(ib)%uoo(is2,jjj,ke4) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				if( ( zc4 - ndsz(14) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(14) - as2 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				elseif( ( ndsx(16) - as2 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				elseif( ( zc4 - ndsz(16) )*fzq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				endif
				else
				call setMirror_u(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				endif
				endif
				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke4) = t2	
				!dom(ib)%uoo(is2,jjj,ke4) = t2
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke4
		!!!endif ! flagA / flagB check
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!!! CHECKING FACE S2 ke5
		!!
		!12345 
		if(dom(ib)%mucx(is2,jjj,ke5).eq.0) then	! checking if this cell has already been flagged
		!if( (flagA.eq.1).or.(flagB.eq.1)) then
		if( (flagA.eq.2) ) then
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(10) - ndsx(7)) .lt. margin ) then			! Checking for vertical segments
		!if( abs(ndsx(10) - ndsx(11)) .lt. margin ) then
			if( (zc5-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc5-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc5-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc5-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc5-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn3-cn
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke5r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn3-cn5 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke5r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn5-cn7 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			endif
		elseif ( (ndsx(9) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as2-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn5-cn7 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			endif
		elseif ( (ndsx(11) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as2-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn5-cn9 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			endif
		elseif ( (ndsx(13) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(13)+(ndsz(11)-ndsz(13))*(as2-ndsx(13))/(ndsx(11)-ndsx(13))
			! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn5-cn9 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
						!dom(ib)%uoo(is2,jjj,ke5) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			endif
		else ! Face S has not been pierces so far
		!!!!!!!!!!!! 
		! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
			! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc5 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc5 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc5 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc5 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
					!dom(ib)%uoo(is2,jjj,ke5) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				if( ( zc5 - ndsz(14) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(14) - as2 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
				elseif( ( ndsx(16) - as2 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
				elseif( ( zc5 - ndsz(16) )*fzq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
				endif
				else
				call setMirror_u(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
				endif
				endif
				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
				!dom(ib)%uoo(is2,jjj,ke5) = t2
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke5
		endif ! flagA / flagB check
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke4 ! This may be unnecesary
		!
		!12345 
		if(dom(ib)%mucx(is3,jjj,ke4).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(10) - ndsx(7)) .lt. margin ) then			! Checking for vertical segments
		!if( abs(ndsx(10) - ndsx(11)) .lt. margin ) then
			if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc4-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as3-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc4-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as3-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as3-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as3-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc4-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn3-cn
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
					!dom(ib)%uoo(is3,jjj,ke4) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn3-cn5 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
					!dom(ib)%uoo(is3,jjj,ke4) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2	
					!dom(ib)%uoo(is3,jjj,ke4) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2	
					!dom(ib)%uoo(is3,jjj,ke4) = t2
				endif
			endif
		elseif ( (ndsx(11) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as3-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn5-cn9 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
						!dom(ib)%uoo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2	
					!dom(ib)%uoo(is3,jjj,ke4) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
					!dom(ib)%uoo(is3,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
					!dom(ib)%uoo(is3,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
					!dom(ib)%uoo(is3,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke4) = t2
					!dom(ib)%uoo(is3,jjj,ke4) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ??? 				if( ( zc4 - ndsz(14) )*fzq2 .lt. margin)then
				if( ( zc4 - ndsz(10) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ??? 				if( ( ndsx(14) - as3 )*fxq2 .lt. margin)then
				if( ( ndsx(10) - as3 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				!!! check ???				elseif( ( ndsx(16) - as3 )*fxq2 .lt. margin)then
				elseif( ( ndsx(12) - as3 )*fxq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				!!! check ??? 				elseif( ( zc4 - ndsz(16) )*fzq2 .lt. margin)then
				elseif( ( zc4 - ndsz(12) )*fzq2 .lt. margin)then
				call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				endif
				else
				call setMirror_u(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S2 ke4
		endif ! slaned flag
		endif!12345 
		!
		!
		!
		!
		!
		!
		endif
		!
		endif
!######################################################################
	END SUBROUTINE setQuadrant_u
!######################################################################	

!######################################################################
	SUBROUTINE setMirror_u(vec1,ndsx,ndsz,iq,kq,xq,zq,k)
!######################################################################

			    use imb
			    use mpi
			    use multidata
			    use vars
			    !
			    implicit none
				!
				! temporal variables
				DOUBLE PRECISION:: temp
				!
				! Input valriables
				INTEGER, INTENT(IN):: vec1(8) !vec1(9)
				DOUBLE PRECISION, INTENT(IN):: ndsx(19), ndsz(19)
				!
				! Location of cell face center of ghost cell 
				INTEGER, INTENT(IN):: iq, kq
				DOUBLE PRECISION, INTENT(IN):: xq, zq
				DOUBLE PRECISION:: yq

				! Output variables
				DOUBLE PRECISION, INTENT(OUT):: k

				! Intervace vector for Interpolation function
				INTEGER::vec2(8)
				DOUBLE PRECISION:: vec3(3) 
				DOUBLE PRECISION:: mirror_v,mirror_w

				! Interfaces
				INTEGER:: nn, ib, ll, iii, jjj, kkk
				! qF: quadrantFlag

				

				! Search loop index
				INTEGER:: dd, bb, cc

				! Location of the neares marker
				DOUBLE PRECISION:: mkx, mkz, mkx2, mkz2, mkx3, mkz3

				! Distances between ghost cell and markers
				DOUBLE PRECISION:: rad1, rad2, radAux

				! Angle of the closts markers to the ghost cell
				DOUBLE PRECISION:: cosTetha1, sinTetha1
				DOUBLE PRECISION:: cosAlpha1, cosAlpha2, tanBetha1
				DOUBLE PRECISION:: alpha1, alpha2, betha1, tetha1

				! Location of mirror point
				DOUBLE PRECISION:: mrx, mry, mrz

				! Indeces of mirror cell centre
				INTEGER:: id,jd, kd				
				
				DOUBLE PRECISION:: origin_x, origin_yc, origin_zc, dx_l, dy_l, dz_l

				! mirror velocities
				INTEGER:: ii, jj
				DOUBLE PRECISION:: mirror_u
				DOUBLE PRECISION:: nx(2),nz(2),uvec(4)
				DOUBLE PRECISION:: dx1, dx2, dz1, dz2
				DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
				DOUBLE PRECISION:: b1(4), b2(3), sol(3), ab(4,3)
				DOUBLE PRECISION:: x1, x2, z1, z2
				DOUBLE PRECISION:: q11, q21, q12, q22, qxz
				DOUBLE PRECISION:: factor1
				DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
				DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
				DOUBLE PRECISION:: bm1(4), bm2(4),sol2(4)

				! Flags
				INTEGER:: flag90, flag1, flag2, qF, M
				DOUBLE PRECISION:: fx, fz

				! safety variables
				DOUBLE PRECISION:: margin
				DOUBLE PRECISION:: maxAlpha

				! writing warnings
				integer:: debugF
				integer:: sn
				character*8 :: chb1
				character*35 :: gf ! file name
				integer:: St_k,mksPS,mksEL,nnFinish,nnStart 
				!
				! variables flor checking subdomain boundaries
				integer:: ius,iue,kps,kpe,i_n_cells,k_n_cells

			!	if (myrank.eq. master ) then ! The control is passed down to the master processor

				nn  = vec1(1)
				ib  = vec1(2)
				ll  = vec1(3)
				iii = vec1(4)
				jjj = vec1(5)
				kkk = vec1(6)
				qF  = vec1(7) ! this is defined in a function later on
				M   = vec1(8)
				!origin_x = vec1(8)
				!origin_y = vec1(9)
				!origin_zc = vec1(10)
				!
				! Initializing return value
				k = 0.0d00
				!
				if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN
					
					IF(imb_block_loc(nn).eq.dom_id(ib)) then

				! lets initialize the mirror velocity
				mirror_u = 0.0d00;

				! Filter for testing
			!	if(qF.eq.1) then
				! if( (qF.eq.1 ).and.(ll.lt.2) ) then
			!	if( (ll.lt.2).and.((qF.eq.1).or.(qF.eq.2)) ) then
			!	if( (ll.lt.2) ) then !.and.((qF.eq.1).or.(qF.eq.2)) ) then					
				if( (ll.lt.2).and.(qF.lt.5) ) then
			!	if( (nn.gt.0).and.(nn .lt. 1321) ) then

				flag90 = 0
				margin = 1.0e-5
				maxAlpha = 90.001

				!!! Search loop for closest markers to the velocity cell centre
				mkx = ndsx(1)
				mkz = ndsz(1)
				mkx2 = ndsx(2)
				mkz2 = ndsz(2)
				dd = 2
				bb = dd - 1
				cc = dd

				rad1 = (mkx-xq)**2 + (mkz-zq)**2
				rad2 = (mkx2-xq)**2 + (mkz2-zq)**2

				mkx3 = ndsx(3)
				mkz3 = ndsz(3)
				radAux = (mkx3-xq)**2 + (mkz3-zq)**2
				if (radAux .lt. rad2) then
					mkx2 = mkx
					mkz2 = mkz
					mkx  = mkx3
					mkz  = mkz3
					rad2 = rad1
					rad1 = radAux

					bb = dd + 1
					cc = dd - 1
				endif

				
				do dd = 4, 16, 2

					mkx3 = ndsx(dd)
					mkz3 = ndsz(dd)					
					radAux = (mkx3-xq)**2 + (mkz3-zq)**2

					if (radAux .lt. rad1) then
						mkx  = mkx2
						mkz  = mkz2
						mkx2 = mkx3
						mkz2 = mkz3						
						rad1 = rad2
						rad2 = radAux
						bb = dd - 2
						cc = dd
					else
						mkx3 = ndsx(dd+1)
						mkz3 = ndsz(dd+1)
						radAux = (mkx3-xq)**2 + (mkz3-zq)**2
						if (radAux .lt. rad2) then
							mkx2 = mkx
							mkz2 = mkz
							mkx  = mkx3
							mkz  = mkz3							
							rad2 = rad1
							rad1 = radAux
							bb = dd + 1
							cc = dd - 1
						endif
					endif
				enddo

				rad1 = sqrt(rad1)
				rad2 = sqrt(rad2)
				

				cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) ! alpha1: angle between U cell centre and segment mk1-mk2
				cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) ! alpha2: angle between U cell centre and segment mk2-mk1
				alpha1 = DACOS(cosAlpha1)*180/piNUm
				alpha2 = DACOS(cosAlpha2)*180/piNum
				! If there is a normal from the velocity cell centre to the surface (segment mk1-mk2) alpha1 < 90 and alpha2 < 90


				tanBetha1 = (mkz2-mkz)/(mkx2-mkx)
				betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets make betha1


				St_k = ibmSt(M) ! number of station of the inmmersed body
				mksPS = ibmStMkrs(M)	! Markers per station
				mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				nnStart = 1 + (int(St_k/2.0d00))*mksPS
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				if (alpha1 .gt. maxAlpha) then
					flag90 = 1
					write(6,*) "Warning in mirror_u subroutine!", nn, bb
					write(6,*) "alpha1 greater thant 90: ", alpha1
					write(6,*) "alpha2: ", alpha2
					Write(6,*) "xq, zq: ", xq, zq
					Write(6,*) "mkx, mkz: ", mkx, mkz
					Write(6,*) "mkx2, mkz2: ", mkx2, mkz2
					write(6,*) ""
					! Update bb and cc
					if (bb .eq. 2) then
						! bb = 2		cc = 4
						bb = bb - 1
						cc = cc - 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb - 2
						cc = cc - 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb + 2
						cc = cc + 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum
				
				elseif (alpha2 .gt. maxAlpha) then
					flag90 = 1
					write(6,*) "Warning in mirror_u subroutine!", nn, bb
					write(6,*) "Warning: alpha2 greater thant 90: ", alpha2
					write(6,*) "alpha1: ", alpha1
					Write(6,*) "xq, zq: ", xq, zq
					Write(6,*) "mkx, mkz: ", mkx, mkz
					Write(6,*) "mkx2, mkz2: ", mkx2, mkz2
					write(6,*) ""
					! Update bb and redefine the nodes
					if (bb .eq. 1) then
						! bb = 1		cc = 2
						bb = bb + 1
						cc = cc + 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb + 2
						cc = cc + 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb - 2
						cc = cc - 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNUm
				endif
				endif

				if (flag90) then
					write(chb1,'(i6)') nn
					sn=len(trim(adjustl(chb1)))
					gf='w_u_m_alpha'//repeat('0',(6-sn))//trim(adjustl(chb1))
					OPEN(unit = 906, access = "sequential", action = "write",
     &   status = "replace", file = gf, form = "formatted") 

					!	write(6,*) "*** Index, Qudarant ***"
						write(906,*) nn, qF
						write(906,*) ndsx
						write(906,*) ndsz
						write(906,*) iii, kkk, jjj	
						write(906,*) iq, kq
						write(906,*) alpha1, alpha2
						!write(6,*) betha1, tetha1
					! location of P pressure cell centre
						write(906,*) xq, zq
					! location of closest markers
						write(906,*) mkx, mkz
						write(906,*) mkx2, mkz2
						write(906,*) bb, cc		
						write(906,*) ndsx(bb), ndsz(bb)
						write(906,*) ndsx(cc), ndsz(cc)
						!write(6,*) mrx, mrz		
						write(906,*) id, kd
						write(906,*) "==="
						close(906)
						write(6,*) "new alpha1, alpha2: ", alpha1, alpha2
						Write(6,*) "xq, zq: ", xq, zq
						Write(6,*) "mkx, mkz: ", mkx, mkz
						Write(6,*) "mkx2, mkz2: ", mkx2, mkz2
						write(6,*) ""
						write(6,*) "---------------------------"
					endif

				! redefining quadrant of the neighbouring markers
				qF = quadrant(ndsx(bb), ndsz(bb),ndsx(cc), ndsz(cc),margin)
				!
				dx_l = dom(ib)%dx
				dy_l = dom(ib)%dy
				dz_l = dom(ib)%dz
				!
				origin_x = dom(ib)%x(1)
				origin_yc = dom(ib)%yc(1)
				origin_zc = dom(ib)%zc(1) 
				!
				!
			if (qF.eq.1) then

				tetha1 = alpha1 - betha1 
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point will always be forward of marker1
				mrx = mkx + rad1*cosTetha1
				! mry = ???
				! The mirror point may be above marker1 if betha1 > alpha1
				mrz = mkz - rad1*sinTetha1

			elseif(qF.eq.2) then

				tetha1 =   alpha1 - (90 - betha1) 
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point may be behind maker1 if alpha1 < (90 - betha1)
				mrx = mkx + rad1*sinTetha1

				! mry = ???
				
				! The mirror point will alpway be above marker1
				mrz = mkz + rad1*cosTetha1

			elseif(qF.eq.3) then

				tetha1 = betha1 - alpha1
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point will always be behind marker 1
				mrx = mkx - rad1*cosTetha1
				
				! mry = ???
				
				! The mirror point may be above marker 1 if alpha1 > betha1
				mrz = mkz - rad1*sinTetha1

			elseif(qF.eq.4) then

				tetha1 = 90 - betha1 - alpha1
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! mirror point may be behind or forward of marker 1 if alpha1 > (90 - betha1)
				mrx = mkx + rad1*sinTetha1
				
				! mry = ???

				! mirror point will alway be bellow marker 1
				mrz = mkz - rad1*cosTetha1

			endif
			!
			! Inidices of the mirror u cell
			id = int ( ( mrx - origin_x - margin) /dx_l) + 2 
			!jd = int ( ( mry - origin_yc - margin) /dy_l) + 2
			!if (jd.eq.jjj) then
			!else
			!	write(6,*) "Warning jd is not jjj"
			!endif
			!
			yq = dom(ib)%y(jjj) ! dom(ib)%yc(jjj)
			!
			kd = int ( ( mrz - origin_zc - margin) /dz_l) + 2
			!
			!
			! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
			ius=dom(ib)%isu; iue=dom(ib)%ieu 
			kps=dom(ib)%ksp; kpe=dom(ib)%kep
			!
			!!! Checking mirror point  proximity to the subdomain boundaries 
			!!uvec2(1) =  dom(ib)%ucpy(id-2,jjc,kd-2)
			!!uvec2(2) =  dom(ib)%ucpy(id-1,jjc,kd-2)
			!!uvec2(3) =  dom(ib)%ucpy(id+0,jjc,kd-2)
			!!uvec2(4) =  dom(ib)%ucpy(id+1,jjc,kd-2)
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!!uvec2(5) =  dom(ib)%ucpy(id-2,jjc,kd-1)
			!!uvec2(6) =  dom(ib)%ucpy(id-1,jjc,kd-1)
			!!uvec2(7) =  dom(ib)%ucpy(id+0,jjc,kd-1)
			!!uvec2(8) =  dom(ib)%ucpy(id+1,jjc,kd-1)
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!!uvec2(9) =  dom(ib)%ucpy(id-2,jjc,kd+0)
			!!uvec2(10) = dom(ib)%ucpy(id-1,jjc,kd+0)
			!!uvec2(11) = dom(ib)%ucpy(id+0,jjc,kd+0)
			!!uvec2(12) = dom(ib)%ucpy(id+1,jjc,kd+0)
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!!uvec2(13) =  dom(ib)%ucpy(id-2,jjc,kd+1)
			!!uvec2(14) =  dom(ib)%ucpy(id-1,jjc,kd+1)
			!!uvec2(15) =  dom(ib)%ucpy(id+0,jjc,kd+1)
			!!uvec2(16) =  dom(ib)%ucpy(id+1,jjc,kd+1)
			if((kd-2.ge.kps-3).and.(kd+1.le.kpe+3).and.
     & 		(id-2.ge.ius-3).and.(id+1.le.iue+3)
     & 		)then
			!!!		if((kd.gt.kps-3).and.(kd.lt.kpe+3).and.
    		!!! & 		(id.gt.ius-3).and.(id.lt.iue+3)
    		!!! & 		)then
			!if(nn.lt.8)then
			!	write(*,*) nn, kd, debugF
			!	write(*,*) iq, kq
			!	write(*,*) xq, zq
			!	write(*,*) id, kd
			!	write(*,*) mrx,mrz
			!	write(*,*) "============"
			!endif
			!
			!
			!
			! lets flag this cell as a body cell
			dom(ib)%mucx(iq,jjj,kq) = qF
			!
			! Lets add the necesary information
			dom(ib)%mucxnn(iq,jjj,kq) = nn  ! nn for u ghost cells
			dom(ib)%mucxib(iq,jjj,kq) = ib  ! ib for u ghost cells
			dom(ib)%mucxll(iq,jjj,kq) = ll  ! ll for u ghost cells
			dom(ib)%mucxi(iq,jjj,kq)  = iq  ! %x  id for u ghost cells
			dom(ib)%mucxj(iq,jjj,kq)  = jjj ! %yc id for u ghost cells
			dom(ib)%mucxk(iq,jjj,kq)  = kq  ! %z  id for u ghost cells
			dom(ib)%mucxx(iq,jjj,kq)  = xq  ! %x  for u ghost cells
			dom(ib)%mucxy(iq,jjj,kq)  = yq  ! %yc for u ghost cells
			dom(ib)%mucxz(iq,jjj,kq)  = zq  ! %z  for u ghost cells
			dom(ib)%mucxmi(iq,jjj,kq) = id  ! %x  id for u mirror cells
			dom(ib)%mucxmj(iq,jjj,kq) = jjj ! %yc id for u mirror cells
			dom(ib)%mucxmk(iq,jjj,kq) = kd  ! %z  id for u mirror cells
			dom(ib)%mucxmx(iq,jjj,kq) = mrx ! %x  for u mirror cells
			dom(ib)%mucxmy(iq,jjj,kq) = yq  ! %yc for u mirror cells
			dom(ib)%mucxmz(iq,jjj,kq) = mrz ! %z  for u mirror cells
			!
			!debug
			!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
			!	write(*,*) "mirror_u"
			!	write(6,*) vec2
			! write(6,*) vec3
			! write(6,*) yq,dom(ib)%mucxy(iq,jjj,kq)
			!	write(6,*) myrank
			!	endif
			!
			!
			!if (rott_loc(nn).eq.1) then
			!!!if(rotating(M).eq..FALSE.) then
			!!!	k = - mirror_u
			!!!	!k = -1.0d00	
			!!!!elseif (rott_loc(nn).eq.2) then
			!!!elseif(rotating(M).eq..TRUE.) then
			!!!	k = 2*U_p - mirror_u  ! moving body
			!!!	!k = -1.0d00
			!!!endif
			!debug
		!	if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!	!	write(6,*) nn, k ,rott_loc(nn)
		!		write(6,*) nn, k, M, dom(ib)%mucxold(iq,jjj,kq), "u"
		!	!write(6,*) qF, fieldF, fieldVal
		!	!write(6,*) vec2(1),vec2(2),vec2(3)
		!	!write(6,*) vec2(4),vec2(5),vec2(6)
		!	!write(6,*) vec2(7),vec2(8)
		!	!write(6,*) vec3(1),vec3(2),vec3(3)
		!	!write(6,*) "======================="
		!	endif
			!
			!
		! ! check mirror point for u	
		!	if ( (nn.gt.0).and.(nn.lt.127) ) then
		!		uz1 = abs(0.5d00 - sqrt( (18.00d00-xq)**2 + (10.50d00-zq)**2 ))
		!		uz2 = abs(sqrt( (18.0d00-mrx)**2 + (10.5d00-mrz)**2 ) - 0.5d00)
		!		uz1 = abs(uz1-uz2)
		!	!	write(6,*) nn, iq, kq
		!		write(6,*) nn, uz1
		!	!	write(6,*) alpha1, alpha2
		!	!	write(6,*) betha1, tetha1
		!	endif
			!
			else
				! debug
				St_k = ibmSt(M) ! number of station of the inmmersed body
				mksPS = ibmStMkrs(M)	! Markers per station
				mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				nnStart = 1 + (int(St_k/2.0d00))*mksPS
				!
				i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
				k_n_cells = dom(ib)%ttc_k
				!
				if(kd-2.lt.kps-3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iii,jjj,kkk,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with kd-2.lt.kps-3",kd,abs(kps-3)
				write(*,*) ib, k_n_cells
				write(*,*) kps,kpe
				endif
				kd = kps - 1
				endif
				if(kd+1.gt.kpe+3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iii,jjj,kkk,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with kd+1.gt.kpe+3",kd,abs(kpe+3)
				write(*,*) ib, k_n_cells
				write(*,*) kps,kpe
				endif
				kd = kpe+2
				endif
				if(id-2.lt.ius-3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iii,jjj,kkk,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with id-2.lt.ius-3 ",id,abs(ius-3)
				write(*,*) ib, i_n_cells
				write(*,*) ius,iue
				endif
				id = ius - 1
				endif
				if(id+1.gt.iue+3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iii,jjj,kkk,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with id+1.gt.iue+3 ",id,abs(iue+3)
				write(*,*) ib, i_n_cells
				write(*,*) ius,iue
				endif
				id = iue+2
				endif
				!
				! lets flag this cell as a body cell
				dom(ib)%mucx(iq,jjj,kq) = qF
				!
				! Lets add the necesary information
				dom(ib)%mucxnn(iq,jjj,kq) = nn  ! nn for u ghost cells
				dom(ib)%mucxib(iq,jjj,kq) = ib  ! ib for u ghost cells
				dom(ib)%mucxll(iq,jjj,kq) = ll  ! ll for u ghost cells
				dom(ib)%mucxi(iq,jjj,kq)  = iq  ! %x  id for u ghost cells
				dom(ib)%mucxj(iq,jjj,kq)  = jjj ! %yc id for u ghost cells
				dom(ib)%mucxk(iq,jjj,kq)  = kq  ! %z  id for u ghost cells
				dom(ib)%mucxx(iq,jjj,kq)  = xq  ! %x  for u ghost cells
				dom(ib)%mucxy(iq,jjj,kq)  = yq  ! %yc for u ghost cells
				dom(ib)%mucxz(iq,jjj,kq)  = zq  ! %z  for u ghost cells
				dom(ib)%mucxmi(iq,jjj,kq) = id  ! %x  id for u mirror cells
				dom(ib)%mucxmj(iq,jjj,kq) = jjj ! %yc id for u mirror cells
				dom(ib)%mucxmk(iq,jjj,kq) = kd  ! %z  id for u mirror cells
				dom(ib)%mucxmx(iq,jjj,kq) = mrx ! %x  for u mirror cells
				dom(ib)%mucxmy(iq,jjj,kq) = yq  ! %yc for u mirror cells
				dom(ib)%mucxmz(iq,jjj,kq) = mrz ! %z  for u mirror cells
				!
			endif ! flag id,id, kd for proximity to control volume boundaries
			!
			endif

			endif


			! End k-th processor handling sumbdomain ib??
			endif

			CONTAINS


			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_ux1, mirror_ux2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjj,kd)
			!	ux2 = dom(ib)%u(id+1,jjj,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = uvec(1)	!dom(ib)%u(id,jjj,kd)
			ux2 = uvec(2) 	!dom(ib)%u(id-1,jjj,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_ux1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjj,kd-1)
			!ux2 = dom(ib)%u(id+1,jjj,kd-1)

			! Alternative
			ux1 = uvec(3)	!dom(ib)%u(id,jjj,kd-1)
			ux2 = uvec(4)	!dom(ib)%u(id-1,jjj,kd-1)

			mirror_ux2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_ux1
			uz2 = mirror_ux2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)

			!######################################################################
			END FUNCTION l1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################






!######################################################################
			END SUBROUTINE setMirror_u
!######################################################################


!######################################################################			
	SUBROUTINE setQuadrant_w(vec0,ndsx,ndsz,fieldF)
!######################################################################		
		use imb
		use mpi
		use multidata

		implicit none

		! temporal variables
		DOUBLE PRECISION:: temp, t1, t2

		! Input valriables
		INTEGER, INTENT(IN):: vec0(8)
		INTEGER:: nn, ll, ib, iii,jjj,kkk, qF, M
		INTEGER, INTENT(IN):: fieldF
		DOUBLE PRECISION, INTENT(IN)::ndsx(19),ndsz(19)

		! safety variables
		DOUBLE PRECISION:: margin

		! Intersections
		DOUBLE PRECISION:: ys, ys2

		! Locations of faces
		DOUBLE PRECISION:: as4,as3,as2,as,ae,ae2,ae3
		DOUBLE PRECISION:: cs3,cs2,cs,ce,ce2,ce3
		DOUBLE PRECISION:: zc0, zc1, zc2, zc3, zc4

		! Indeces of faces
		INTEGER:: ie,ke,ke2,ke3,ke4,ke0
		INTEGER:: is, is2, is3, is4

		! Special variables for avoiding selecting cell outise the geometry in the 2nd and 4th quarters
		INTEGER:: isq, keq, ieq
		DOUBLE PRECISION:: asq, aeq
		INTEGER:: fxq1, fzq1, fxq2, fzq2, fxs3, fzs3, fxk3, fzk3
		!
		! Flags
		INTEGER:: flag1, flag2, flagA, flagB, flagC
		INTEGER:: slanted, debugF
		DOUBLE PRECISION:: fx, fz
		!
		! Interfaces
		INTEGER:: vec1(8)
		!
		nn  = vec0(1)
		ll  = vec0(2)
		ib  = vec0(3)
		iii = vec0(4)
		jjj = vec0(5)
		kkk = vec0(6)
		qF  = vec0(7)
		 M  = vec0(8)
		 !
		vec1(1) = nn
		vec1(2) = ib
		vec1(3) = ll
		vec1(4) = iii
		vec1(5) = jjj
		vec1(6) = kkk
		vec1(7) = qF
		vec1(8) = M
		!
		margin = 1.0e-5
		!
		!
		!
	!	if (myrank.eq. master ) then ! The control is passed down to the master processor
			if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
				IF(imb_block_loc(nn).eq.dom_id(ib)) then
		!
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 1st quadrant
		!	
		if (qF.eq.1) then
			!
            as = dom(ib)%xc(iii-1) 
            as2 = dom(ib)%xc(iii-2)	
            as3 = dom(ib)%xc(iii-3)
            as4 = as3 - abs(as3 - as2) !dom(ib)%xc(iii-4)
		    asq = as
			!
            ae = dom(ib)%xc(iii) 
            ! Warning, check this
			! aeq = ae
			aeq = as
            !
            ae2 = dom(ib)%xc(iii+1)
            ae3 = dom(ib)%xc(iii+2)
            !
            zc0 = dom(ib)%z(kkk-1)	! cell centre. We want to obtain the mirror value for this cell centre    
            zc1 = dom(ib)%z(kkk)	! cell centre. We want to obtain the mirror value for this cell centre
            zc2 = dom(ib)%z(kkk+1)	! cell centre. We want to obtain the mirror value for this cell centre
            zc3 = dom(ib)%z(kkk+2)	! cell centre. We want to obtain the mirror value for this cell centre
		    zc4 = dom(ib)%z(kkk+3)	! cell centre. We want to obtain the mirror value for this cell centre		
			!
			!
            ie = iii; ke0 = kkk-1;	ke = kkk
		    ke2 = kkk+1; ke3 = kkk+2; ke4 = kkk+3
			!
            is = iii-1 ; is2 = iii-2; is3 = iii - 3; is4 = iii - 4
            isq = is; keq = ke
            ieq = is	
    
            fx = 1.0d00
            fz = 1.0d00
            fxq1 = fx
            fzq1 = fz
            fxq2 = fx
			fzq2 = fz	
            fxs3 = fx
            fzs3 = fz
    
            endif
    
            ! bbbb
    
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Setting parameters for 2nd quadrant
    
            if (qF.eq.2) then
    
                ae3 = dom(ib)%xc(iii-3)
                ae2 = dom(ib)%xc(iii-2)	
                ae = dom(ib)%xc(iii-1) 
        
                as = dom(ib)%xc(iii) 
                asq = ae
                aeq = ae
    
                as2 = dom(ib)%xc(iii-2)
                as3 = dom(ib)%xc(iii-3)
                as4 = as3 - abs(as3 - as2) ! dom(ib)%xc(iii-4)
                
                zc0 = dom(ib)%z(kkk)	! cell centre. We want to obtain the mirror value for this cell centre    
                zc1 = dom(ib)%z(kkk-1)	! cell centre. We want to obtain the mirror value for this cell centre
                zc2 = dom(ib)%z(kkk-2)	! cell centre. We want to obtain the mirror value for this cell centre
                zc3 = dom(ib)%z(kkk-3)	! cell centre. We want to obtain the mirror value for this cell centre
                zc4 = zc3 - abs(zc3 - zc2) ! dom(ib)%z(kkk-4)	! cell centre. We want to obtain the mirror value for this cell centre				
                
        
                ie = iii-1; ke0 = kkk;	ke = kkk-1
                ke2 = kkk-2; ke3 = kkk-3; ke4 = kkk-4
        
                is = iii; is2 = iii-2; is3 = iii - 3; is4 = iii - 4
                isq = is; keq = kkk + 1
                ieq = ie
                    
                fx = -1.0d00
                fz = -1.0d00
                fxq1 = fx
                fzq1 = fz
                fxq2 = -fx
				fzq2 = -fz		
                fxs3 = -fx
                fzs3 = -fz

                endif
    
    
    
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Setting parameters for 3rd quadrant
                    
                if (qF.eq.3) then
    
                    ae3 = dom(ib)%xc(iii-3)
                    ae2 = dom(ib)%xc(iii-2)	
                    ae = dom(ib)%xc(iii-1) 
            
                    as = dom(ib)%xc(iii) 
                    asq = as
                    aeq = as
        
                    as2 = dom(ib)%xc(iii+1)
                    as3 = dom(ib)%xc(iii+2)
                    as4 = dom(ib)%xc(iii+3)
                    
                    zc0 = dom(ib)%z(kkk)	! cell centre. We want to obtain the mirror value for this cell centre    
                    zc1 = dom(ib)%z(kkk-1)	! cell centre. We want to obtain the mirror value for this cell centre
                    zc2 = dom(ib)%z(kkk-2)	! cell centre. We want to obtain the mirror value for this cell centre
                    zc3 = dom(ib)%z(kkk-3)	! cell centre. We want to obtain the mirror value for this cell centre
                    zc4 = zc3 - abs(zc3 - zc2) !dom(ib)%z(kkk-4)	! cell centre. We want to obtain the mirror value for this cell centre					
                
            
                    ie = iii-1; ke0 = kkk;	 ke = kkk-1
                    ke2 = kkk-2; ke3 = kkk-3; ke4 = kkk-4
            
                    is = iii; is2 = iii+1; is3 = iii+2; is4 = iii+3
                    isq = is; keq = ke		
                    ieq = is
                            
                !	is = iii; is2 = iii; is3 = iii + 1
    
                    fx = -1.0d00
                    fz = -1.0d00
                    fxq1 = -fx
                    fzq1 = -fz
                    fxq2 = fx
					fzq2 = fz
                    fxs3 = fx
                    fzs3 = fz
                

                    endif			
    
    
    
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Setting parameters for 4th quadrant
                    
                if (qF.eq.4) then
    
                    ae3 = dom(ib)%xc(iii+2)
                    ae2 = dom(ib)%xc(iii+1)	
                    ae = dom(ib)%xc(iii) 
                    
            
                    as = dom(ib)%xc(iii-1) 
                    asq = ae
                    aeq = ae
        
                    as2 = dom(ib)%xc(iii+1)
                    as3 = dom(ib)%xc(iii+2)
                    as4 = dom(ib)%xc(iii+3)

                    zc0 = dom(ib)%z(kkk-1)	! cell centre. We want to obtain the mirror value for this cell centre    
                    zc1 = dom(ib)%z(kkk)	! cell centre. We want to obtain the mirror value for this cell centre
                    zc2 = dom(ib)%z(kkk+1)	! cell centre. We want to obtain the mirror value for this cell centre
                    zc3 = dom(ib)%z(kkk+2)	! cell centre. We want to obtain the mirror value for this cell centre
                    zc4 = dom(ib)%z(kkk+3)	! cell centre. We want to obtain the mirror value for this cell centre					
    
            
                    ie = iii; ke0 = kkk-1;	ke = kkk
                    ke2 = kkk+1; ke3 = kkk+2; ke4 = kkk+3
            
                    is = iii-1; is2 = iii+1; is3 = iii+2; is4 = iii+3
                    isq = ie; keq = kkk - 1
                    ieq = ie
            
                    fx = 1.0d00
                    fz = 1.0d00
                    fxq1 = fx
                    fzq1 = fz
                    fxq2 = -fx
					fzq2 = -fz
                    fxs3 = -fx
                    fzs3 = -fz

                    endif
    
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Checking quadrants

		flag1 = 0
		flag2 = 0
		flagA = 0
		flagB = 0
		flagC = 0
		slanted = 1

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE E

		if ( ( ndsx(2) -  ae )*fx.gt. -margin ) then	! The East Face is pierced for the FIRTS TIME
			!
			ys = ndsz(1) + (ndsz(2) - ndsz(1))*(ae - ndsx(1))/(ndsx(2) - ndsx(1))
			!
			! case a.1.1.1	 Checking if w(ie,jjj,ke0) is above cn-cn2
			!12345 
			if(dom(ib)%mwcz(ie,jjj,ke0).eq.0) then	! checking if this cell has already been flagged
			!if(1)  then
			slanted = 1
			! Checking for vertical segments
			if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then
				!if( (zc0-ndsz(1))*fzq2 .gt. -margin)then 	! horizontal lower bound
				!if( (zc0-ndsz(2))*fzq2 .lt. margin)then	! horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east	bound
				call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				else
					flagC = 1
				!endif
				!endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(4) - ndsz(2)) .lt. margin ) ) then ! checking corners 1-2q and 3-4q
				if( (zc0-ndsz(2))*fzq2 .lt. margin)then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				else
				!call setMirror_w(vec1,ndsx,ndsz,is,ke0,as,zc0,t2)
				!slanted = 0
				endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(3)).lt.margin).and.
     & 			(abs(ndsz(2) - ndsz(1)) .lt. margin ) ) then ! checking corners 2-1q and 4-3q
				if( (as-ndsx(1))*fxq2 .lt. margin)then
				if( (zc0-ndsz(2))*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				!2else
				!2call setMirror_w(vec1,ndsx,ndsz,ie,ke02,ae,zc2,t2)
				!2slanted = 0
				endif
				!else
				!	if( (zc0-ndsz(2))*fzq2 .lt. margin)then
				!	call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				!	slanted = 0
				!	!2else
				!	!2call setMirror_w(vec1,ndsx,ndsz,ie,ke02,ae,zc2,t2)
				!	!2slanted = 0
				!	endif
				endif
			endif
			if((abs(ndsx(4)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(2)) .lt. margin ) ) then ! checking corners 2-3q and 4-1q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc0-ndsz(1))*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				!2else
				!2call setMirror_w(vec1,ndsx,ndsz,ie,ke02,ae,zc2,t2)
				!2slanted = 0
				endif
				else
			!		if( (zc0-ndsz(1))*fzq2 .lt. margin)then
			!		call setMirror_w(vec1,ndsx,ndsz,is,ke0,as,zc0,t2)
			!		slanted = 0
			!		!2else
			!		!2call setMirror_w(vec1,ndsx,ndsz,ie,ke02,ae,zc2,t2)
			!		!2slanted = 0
			!		endif
				endif
			endif
			if((abs(ndsx(2)-ndsx(1)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(3)) .lt. margin ) ) then ! checking corners 3-2q and 1-4q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc0-ndsz(1))*fzq2 .gt. -margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				endif
				endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then
				if( (zc0-ndsz(1))*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				else
				flagA = 2
				slanted = 0
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc0 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
                        !!if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
                        !!if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
                        !!if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
                    !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
				endif		
			!endif
			! case a.1.1.2	 Checking if w(ie,jjj,ke0) is above cn-cn2
			else
				!flag2 = 1
				flagA = 1
		
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
			! case a.1.1.1	 Checking if w(ie,jjj,ke) is above cn-cn2
			!12345 
			if(dom(ib)%mwcz(ie,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			slanted = 1
			! Checking for vertical segments
			if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then
				!if( (zc1-ndsz(1))*fzq2 .gt. -margin)then 	! horizontal lower bound
				!if( (zc1-ndsz(2))*fzq2 .lt. margin)then	! horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east	bound
				call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				else
					flagC = 1
				!endif
				!endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(4) - ndsz(2)) .lt. margin ) ) then ! checking corners 1-2q and 3-4q
				if( (zc1-ndsz(2))*fzq2 .lt. margin)then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				else
				!call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
				!slanted = 0
				endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(3)).lt.margin).and.
     & 			(abs(ndsz(2) - ndsz(1)) .lt. margin ) ) then ! checking corners 2-1q and 4-3q
				if( (as-ndsx(1))*fxq2 .lt. margin)then
				if( (zc1-ndsz(2))*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				!2else
				!2call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				!2slanted = 0
				endif
				!else
				!	if( (zc1-ndsz(2))*fzq2 .lt. margin)then
				!	call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				!	slanted = 0
				!	!2else
				!	!2call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				!	!2slanted = 0
				!	endif
				endif
			endif
			if((abs(ndsx(4)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(2)) .lt. margin ) ) then ! checking corners 2-3q and 4-1q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc1-ndsz(1))*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				!2else
				!2call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				!2slanted = 0
				endif
				else
			!		if( (zc1-ndsz(1))*fzq2 .lt. margin)then
			!		call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
			!		slanted = 0
			!		!2else
			!		!2call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
			!		!2slanted = 0
			!		endif
				endif
			endif
			if((abs(ndsx(2)-ndsx(1)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(3)) .lt. margin ) ) then ! checking corners 3-2q and 1-4q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc1-ndsz(1))*fzq2 .gt. -margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				endif
				endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then
				if( (zc1-ndsz(1))*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				else
				flagA = 2
				slanted = 0
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc1 - ys)*fz .gt. -margin ) then	
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        !!if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
		! There  may be an issue
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                    !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
				endif	
				!flagA = 1
			else
				!flag2 = 1
				flagA = 1	
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
			!
		! case a.1.1.2	 Checking if w(ie,jjj,ke2) is above cn-cn2
			!12345 
			if(dom(ib)%mwcz(ie,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			slanted = 1
			if( abs(ndsx(4) - ndsx(1)) .lt. margin ) then	! Checking for vertical segments
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then	!	horizontal lower bound
				if( (zc2-ndsz(4))*fzq2 .lt. margin)then		!	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical outer bound
				call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				slanted = 0
				else
					flagC = 1
				endif
				endif
				!endif
			elseif( abs(ndsx(2) - ndsx(1)) .lt. margin ) then	! Checking for vertical segments
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then	!	horizontal lower bound
				if( (zc2-ndsz(2))*fzq2 .lt. margin)then		!	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical west bound
				call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				slanted = 0
				else
					flagC = 1
				endif
				endif
				!endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then		!	vertical west bound
				if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
				call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				slanted = 0
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc2 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        !!if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                    !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
				endif
				!flagA = 1
			else
				!flagA = 1
				!flagC = 1
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
			!
			! case a.1.1.2	 Checking if w(ie,jjj,ke3) is above cn-cn2
			!12345 
			if(dom(ib)%mwcz(ie,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			slanted = 1
			if( abs(ndsx(6) - ndsx(1)) .lt. margin ) then	! Checking for vertical segments
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then 	!	horizontal lower bound
				if( (zc3-ndsz(6))*fzq2 .lt. margin)then		!	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
				call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
				slanted = 0
				else
					flagC = 1
				endif
				!endif
				endif
			elseif( abs(ndsx(4) - ndsx(1)) .lt. margin ) then 	! Checking for vertical segments
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then		!	horizontal lower bound 
				if( (zc3-ndsz(4))*fzq2 .lt. margin)then 		! 	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then			!	vertical east	bound
				call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
				slanted = 0
				else
					flagC = 1
				endif
				!endif
				endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(3)) .lt. margin ) then
				if( (ae-ndsx(3))*fxq2 .lt. margin)then			!	vertical east	bound
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then			!	vertical west	bound
				if( (zc3-ndsz(1))*fzq2 .lt. margin)then			! 	horizontal upper bound
				call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
				slanted = 0
					!if((flagA.eq.1).and.(ke4.gt.8))then
			! warning
					if(flagA.eq.2)then
					call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
					slanted = 0
					endif
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc3 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                    !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
				endif		
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
		elseif ( ( ndsx(4) - ae )*fx .gt. -margin ) then	! The East face is pierced for the FIRST TIME
			!
		ys = ndsz(2) + (ndsz(4)-ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
		!
			! case a.1.1.1	 Checking if w(ie,jjj,ke0) is above cn2-cn4
	!		!12345 if(dom(ib)%mwcz(ie,jjj,ke0).eq.0) then	! checking if this cell has already been flagged
	!		!if(1) then
	!		if( ( zc0 - ys)*fz .gt. -margin ) then
	!			if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
	!				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
	!				if( ( zc0 - ys2)*fz .lt. margin) then
	!					call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !					!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
    !					!if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
	!				endif
	!			elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
	!				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
	!				if( ( zc0 - ys2)*fz .lt. margin) then
	!					call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !					!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
    !                   !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
	!				endif
	!			elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
	!				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))				
	!				if ( ( zc0 - ys2)*fz .lt. margin) then
	!					call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !					!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
    !                   !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
	!				endif
	!	! There  may be an issue			
	!			else
	!				call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !				!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
    !               !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
	!			endif		
	!		!endif
	!		! case a.1.1.2	 Checking if w(ie,jjj,ke0) is above cn2-cn4
	!		!else
	!			!flag2 = 1
	!	
	!		endif
	!		endif!12345 
		!
		!
			! case a.2.1.1	Checking if w(ie,jjj,ke) is above cn2-cn4
			!12345 
			if(dom(ib)%mwcz(ie,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                    !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
				endif
				!flagB = 1
			else
			!	flag2 = 1
				flagB = 1 ! firts layer not included within the nds4-nds1 segment
			endif
			endif!12345 
			!
			!
			!
			! case a.2.1.2  Checking if w(ie,jjj,ke2) is above cn2-cn4 
			!12345 
			if(dom(ib)%mwcz(ie,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke2) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
		! There  may be an issue
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                    !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
				endif
				!flagB = 1
			else
				!flagB = 1
			endif
			endif!12345 
			!
		! case a.1.1.2	 Checking if w(ie,jjj,ke3) is above cn-cn2
			!12345 
			if(dom(ib)%mwcz(ie,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke3) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                    !if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
				endif		
			endif
			endif!12345 
			!
		else			
			!elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too

	!			! case a.2.1.1	Checking if w(ieq,jjj,ke0) is above cn4-cn6
	!		if(dom(ib)%mwcz(ieq,jjj,ke0).eq.0) then	! checking if this cell has already been flagged
	!		!if(1) then
	!		if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
	!			ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
	!			if( ( zc0 - ys2)*fzq1 .lt. margin) then
	!				call setMirror_w(vec1,ndsx,ndsz,ieq,ke0,aeq,zc0,t2)
    !				!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke0) = t2
    !           !if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke0) = t2
	!			endif
	!		elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
	!			ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
	!			if( ( zc0 - ys2)*fzq1 .lt. margin) then
	!				call setMirror_w(vec1,ndsx,ndsz,ieq,ke0,aeq,zc0,t2)
    !				!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke0) = t2
    !           !if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke0) = t2
	!			endif
	!	! There  may be an issue			
	!		else
	!			call setMirror_w(vec1,ndsx,ndsz,ieq,ke0,aeq,zc0,t2)
    !			!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke0) = t2
    !           !if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke0) = t2
	!		endif
	!		!endif!12345 
			!
			!
			!
			! case a.2.1.1	Checking if w(ieq,jjj,ke) is above cn4-cn6
			!12345 
			if(dom(ib)%mwcz(ieq,jjj,ke).eq.0) then	! checking if this cell has already been flagged
				!if(1) then
				slanted = 1
				if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
					slanted = 0
				!if( (zc1-ndsz(3))*fzq2 .gt. -margin)then			!	horizontal lower bound
				if( (zc1-ndsz(2))*fzq2 .lt. margin)then				!	horizontal upper bound
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then			!	vertical east bound
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					endif
				endif
				!endif
				endif
				if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
					slanted = 0
					if( (aeq-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
					if( (aeq-ndsx(2))*fxq2 .gt. -margin)then	!	vertical west bound
					if( (zc1-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					endif
					endif
					endif
				endif
			!	! Checking for slanted segments
				if(slanted.eq.1)then
				if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc1 - ys2)*fzq1 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fzq1 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke) = t2
					endif
			! There  may be an issue			
				else
					! WARNING	WARNING	WARNING
					if( ( zc1 - ndsz(4) )*fzq1 .gt. -margin)then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke) = t2
					endif
				endif
				endif ! slanted flag
				endif!12345 
				!
				!
				!
		!	! case a.2.1.2  Checking if w(ieq,jjj,ke2) is above cn4-cn6 
				!12345 
				if(dom(ib)%mwcz(ieq,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
				!if(1) then
				if( abs(ndsx(4) - ndsx(1)) .lt. margin ) then			! Checking for vertical segments
					slanted = 0
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc2-ndsz(4))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					endif
				endif
				!endif
				elseif( abs(ndsx(2) - ndsx(1)) .lt. margin ) then		! Checking for vertical segments
					slanted = 0
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc2-ndsz(2))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					endif
				endif
				!endif
				endif
				if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
					slanted = 0
					if( (aeq-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
					if( (aeq-ndsx(2))*fxq2 .gt. -margin)then	!	vertical west bound
					if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					endif
					endif
					endif
				endif
				! Checking for slanted segments
				if(slanted.eq.1)then
				if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc2 - ys2)*fzq1 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq1 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke2) = t2
						!if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke2) = t2
					endif
				!WARNING	WARNING	WARNING
				elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq1 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke2) = t2
					endif
				else
					if( ( zc2 - ndsz(6) )*fzq1 .gt. -margin)then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke2) = t2
					endif
				endif
				endif ! slanted flag
				endif!12345 
				!
				!
				!
				!
				!
				! case a.1.1.2	 Checking if w(ieq,jjj,ke3) is above cn4-cn6
				!12345 
				if(dom(ib)%mwcz(ieq,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
				!if(1) then
				if( abs(ndsx(6) - ndsx(1)) .lt. margin ) then			! Checking for vertical segments
					slanted = 0
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc3-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then
						call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					endif
				endif
				!endif
				elseif( abs(ndsx(4) - ndsx(1)) .lt. margin ) then		! Checking for vertical segments
					slanted = 0
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc3-ndsz(4))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
						call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					endif
				endif
				!endif
				endif
				if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
					slanted = 0
					if( (aeq-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
					if( (aeq-ndsx(2))*fxq2 .gt. -margin)then	!	vertical west bound
					if( (zc3-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
				! warning
						if(flagA.eq.2)then
						call setMirror_w(vec1,ndsx,ndsz,ieq,ke4,aeq,zc4,t2)
						endif
					endif
					endif
					endif
				endif
				! Checking for slanted segments
				if(slanted.eq.1)then
				if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc3 - ys2)*fzq1 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc3 - ys2)*fzq1 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke3) = t2
					endif
				! WARNING	WARNING	WARNING
				elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc3 - ys2)*fzq1 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke3) = t2
				   !if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke3) = t2
					endif
				else
					if( ( zc3 - ndsz(4) )*fzq1 .gt. -margin)then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke3) = t2
					endif
				endif
				endif ! slanted flag
				endif!12345 
		! WARNING A	
		!else	! The East face has not been pierced 
			flag1 = 1
			!
			flagC = 1 ! first layer not included
			flagA = 2		! Horizontal Segment not included
		endif !!! FINISHED CHECKING FACE E
		!
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S
		!
		!12345 
		if(dom(ib)%mwcz(is,jjj,ke).eq.0) then	! checking if this cell has already been flagged
        !if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
			!if( (zc1-ndsz(3))*fzq2 .gt. -margin)then		! Horizontal lower bound
			if( (zc1-ndsz(2))*fzq2 .lt. margin)then			! Horizontal upper bound
			if( (as-ndsx(1))*fx .lt. margin)then			! Vertical west bound
				! 1q	> 0			> 0		pierced
				! 2q	> 0			> 0		pierced
				! 3q	< 0			> 0		pierced 
				! 4q	< 0			> 0		pierced
				call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
				slanted = 0
			endif
			endif
			endif
		if( abs(ndsz(2) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as-ndsx(3))*fxq2 .lt. margin)then		! Vertical west bound
			if( (as-ndsx(2))*fxq2 .gt. -margin)then		! Vertical east bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then		! Horizontal lower bound
			call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
			slanted = 0
			!else
			!call setMirror_w(vec1,ndsx,ndsz,is,ke2,as,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
		if(slanted.eq.1)then
		! Checking for slanted segments
		if ( (ndsx(3) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
			! 1q	if pierced  ./	ndsx(3) < as	fx > 0	pass
			! 2q		||		.\	ndsx(3) > as	fx < 0	pass
			! 3q		||		/*	ndsx(3) > as	fx < 0	pass
			! 4q		||		\*	ndsx(3) < as	fx > 0	pass
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is,jjj,ke) is bellow cn3-cn
			if( ( zc1 - ys)*fz .gt. -margin ) then
				! 1q	if inside   ./	zc1 > ys	fz > 0	pass
				! 2q		||  	.\	zc1 < ys	fz < 0	pass
				! 3q		||	    /*	zc1 < ys	fz < 0	pass
				! 4q		||	    \*	zc1 > ys	fz > 0	pass
				if ( ( ndsx(5) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					! 1q	if pierced  twice	/*	ndsx(5) > as	fx > 0	pass
					! 2q		||				\*	ndsx(5) < as	fx < 0	pass
					! 3q		||				./	ndsx(5) < as	fx < 0	pass
					! 4q		||				.\	ndsx(5) > as	fx > 0	pass
					if( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if inside   /*	zc1 < ys2	fz > 0	pass
						! 2q		||	   	\*	zc1 > ys2	fz < 0	pass
						! 3q		||	   	./	zc1 > ys2	fz < 0	pass
						! 4q		||	   	.\	zc1 < ys2	fz > 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q	    always      	\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q	    always      	_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  again	*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*\	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 /
					!
					! 2q	 |.
					!		 /
					!
					!		/
					! 3q	|*
					!
					!		/
                    ! 4q   *|
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                    !dom(ib)%woo(is,jjj,ke) = t2
                    !endif
				endif		
			endif
			!				
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is,jjj,ke) is bellow cn3-cn5 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(7) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
                    if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
            	        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
            	        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
            	        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
            	        !dom(ib)%woo(is,jjj,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	    !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                    !dom(ib)%woo(is,jjj,ke) = t2
                    !endif
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is,jjj,ke) is bellow cn5-cn7 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(9) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(as-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
						!dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
                    if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2	
                    !dom(ib)%woo(is,jjj,ke) = t2
                    !endif
				endif
			endif ! zc1
        else ! Face S has not been pierces so far
				!	1q	*|      is = iii-1
				!	2q	 |*     is = iii
				!	3q	 |.     is = iii
				!	4q	.|      is = iii-1
				if ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q		always  		\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q		always  		_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q	
                        ! debug
                        write(*,*)  "ndsx2"
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*/	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
                    endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	 |.
					!		 |
					!
					!		 |
					! 3q	 |*
					!
					!		 |
                    ! 4q	*|
					!Warning	Warning	Warning	!Check removing Check of Face S1 ke
					if( ( zc1 - ndsz(6) )*fzq2 .lt. margin)then
					if((qf.eq.2).or.(qf.eq.4))then
				!	if( ( ndsx(6) - as )*fxq2 .gt. -margin)then
				!	call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2	
                    !dom(ib)%woo(is,jjj,ke) = t2
				!	endif
					else ! Warning: lets apply this only in qf = 1, 4
					call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2	
                    !dom(ib)%woo(is,jjj,ke) = t2
                    endif
					endif
				endif
		endif	 ! ndsx(3)! Finished Check of Face S1 ke
		endif ! slanted flag
		endif!12345
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2
		!
		!12345 
	if(dom(ib)%mwcz(is2,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then	! Checking for vertical segments
			if( (zc1-ndsz(3))*fzq2 .gt. -margin)then	! Horizontal lower bound
			!if( (zc1-ndsz(2))*fzq2 .lt. margin)then	! Horizontal upper bound
			if( (as2-ndsx(1))*fx .lt. margin)then		! Vertical east bound
				! 1q	> 0			> 0		pierced
				! 2q	> 0			> 0		pierced
				! 3q	< 0			> 0		pierced 
				! 4q	< 0			> 0		pierced
				call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
				slanted = 0
			endif
			!endif
			endif
		endif
		if( abs(ndsz(4) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(4))*fxq2 .lt. margin)then		! Vertical west bound
		!	if( (as2-ndsx(1))*fxq2 .gt. -margin)then	! Vertical east bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then
			call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
			slanted = 0
			endif
		!	endif
			endif
		endif
		! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		! 1q	if pierced  ./	ndsx(3) < as2	fxq2 > 0	pass
		! 2q		||		./	ndsx(3) < as2	fxq2 > 0	pass
		! 3q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
		! 4q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
		ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
		! case b.1.1.1  Checking if u(is2,jjj,ke) is2 bellow cn3-cn
		if( ( zc1 - ys)*fzq2 .gt. -margin ) then
			! 1q	if inside   ./	zc1 > ys	fzq2 > 0	pass
			! 2q		||  	./	zc1 > ys	fzq2 > 0	pass
			! 3q		||	    /*	zc1 < ys	fzq2 < 0	pass
			! 4q		||	    /*	zc1 < ys	fzq2 < 0	pass
			if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
				! 1q	if pierced  twice	/*	ndsx(5) > as2	fxq2 > 0	pass
				! 2q		||				/*	ndsx(5) > as2	fxq2 > 0	pass
				! 3q		||				./	ndsx(5) < as2	fxq2 < 0	pass
				! 4q		||				./	ndsx(5) < as2	fxq2 < 0	pass
				if( ( zc1 - ys2)*fzq2 .lt. margin) then
					! 1q	if inside   /*	zc1 < ys2	fzq2 > 0	pass
					! 2q		||	   	/*	zc1 < ys2	fzq2 > 0	pass
					! 3q		||	   	./	zc1 > ys2	fzq2 < 0	pass
					! 4q		||	   	./	zc1 > ys2	fzq2 < 0	pass
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
					!dom(ib)%woo(is2,jjj,ke) = t2
				endif
			elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
				! 2q	if pierced  again	*\	ndsx(2) < as2	fxq2 > 0	pass
				! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
				! 4q	if pierced  again	\.	ndsx(2) > as2	fxq2 < 0	pass
				ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					! 1q
					! 2q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
					! 3q
					! 4q	if pierced  again	\.	zc1 > ys2	fzq2 < 0	pass
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
					!dom(ib)%woo(is2,jjj,ke) = t2
				endif
			elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				! 1q	if pierced  again	*\	ndsx(4) < as2	fxq2 > 0	pass
				! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
				! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
				! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
					! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
					! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
					! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
					!dom(ib)%woo(is2,jjj,ke) = t2
				endif
			elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
					!dom(ib)%woo(is2,jjj,ke) = t2
				endif
			else	! Face S has not been pierces so far BUT is inside the inmersed body
				! 1q	.|
				!		 /
				!
				! 2q	.|
				!		 /
				!
				!		/
				! 3q	|*
				!
				!		/
				! 4q	|*
				call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
				!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
				!dom(ib)%woo(is2,jjj,ke) = t2
			endif		
		endif
		!				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjj,ke) is2 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
					!dom(ib)%woo(is2,jjj,ke) = t2
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke) is2 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2	
					!dom(ib)%woo(is2,jjj,ke) = t2
				endif				
			endif ! zc1
		else ! Face S has not been pierces so far
				!	1q	*|
				!	2q	*|
				!	3q	|.
				!	4q	|.
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
					! 2q	if pierced  		*\	ndsx(2) < as2	fxq2 > 0	pass
					! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
					! 4q	if pierced  		\.	ndsx(2) > as2	fxq2 < 0	pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q
						! 2q	if pierced  	*\	zc1 < ys2	fzq2 > 0	pass
						! 3q
						! 4q	if pierced  	\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as2	fxq2 > 0	pass
					! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
					! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
						! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
						! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
						!dom(ib)%woo(is2,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	.|
					!		 |
					!
					!		|
					! 3q	|*
					!
					!		|
					! 4q	|*
				!
				!!! circle-square difference
				!
				if( ( zc1 - ndsz(6) )*fzq2 .lt. margin)then
					if((qf.eq.2).or.(qf.eq.4))then
					if( ( ndsx(6) - as2 )*fxq2 .lt. margin)then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					elseif( ( ndsx(8) - as2 )*fxq2 .lt. margin )then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					elseif( ( zc1 - ndsz(8) )*fzq2 .lt. margin )then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					endif
					else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					endif
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2	
					!dom(ib)%woo(is2,jjj,ke) = t2
				endif
				endif
		endif	 ! ndsx(3)! Finis2hed Check of Face S2 ke
		endif ! slanted
		endif!12345 
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2 ke2
		!
		!12345 
		if(dom(ib)%mwcz(is2,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(4) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			!if( (zc2-ndsz(3))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc2-ndsz(4))*fzq2 .lt. margin)then					!	horizontal upper bound 
    			if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound	
				call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
				slanted = 0
				endif
			endif
			!endif
		elseif( abs(ndsx(2) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		!if( (zc2-ndsz(3))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc2-ndsz(2))*fzq2 .lt. margin)then					!	horizontal upper bound 
    		if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
			slanted = 0
			endif
		endif
		!endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
		! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME	
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
					!dom(ib)%woo(is2,jjj,ke2) = t2
				endif		
				endif
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
				! case b.2.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn3-cn5 
				if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
					!dom(ib)%woo(is2,jjj,ke2) = t2
				endif	
				endif
			! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn5-cn7 
				if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2	
					!dom(ib)%woo(is2,jjj,ke2) = t2
				endif
				endif
		else ! Face S has not been pierces so far
				!!!!!!!!!!!! 
				! fxq2	 1 1	-1 1	-1-1	-1-1
				! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
				! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
				! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				!
				!
				! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
						!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				else
					!
				!!! circle-square difference
					!
					if( ( zc2 - ndsz(6) )*fzq2 .lt. margin)then
					if((qf.eq.2).or.(qf.eq.4))then
					if( ( ndsx(6) - as2 )*fxq2 .lt. margin)then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2	
					!dom(ib)%woo(is2,jjj,ke2) = t2
					elseif( ( ndsx(8) - as2 )*fxq2 .lt. margin)then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					elseif( ( zc2 - ndsz(8) )*fzq2 .lt. margin)then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					endif
					else ! Warning: lets apply this only in qf = 1, 4
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2	
					!dom(ib)%woo(is2,jjj,ke2) = t2
					endif
					endif
				endif
				!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke2
		endif ! slanted flag
		endif!12345 
		!
		!
		!
	!	!
	!	!
	!	!
	!	!
	!	!!!!!!!!!!!!!!!!!!
	!	!!! CHECKING FACE S2 ke3
	!	!
	!	!12345 
		if(dom(ib)%mwcz(is2,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
		slanted = 1 !!!aaa
		!!!bbb
	!	!if(1) then	! checking if this cell has already been flagged
	! 	if(slanted.eq.0)then
	! 	if( abs(ndsx(8) - ndsx(7)) .lt. margin ) then			! Checking for vertical segments
	! 		if( (zc3-ndsz(7))*fzq2 .gt. -margin)then				!	horizontal lower bound 
	! 		if( (zc3-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
	! 			if( (as2-ndsx(1))*fxq2 .lt. margin)then
	! 			call setMirror_w(vec1,ndsx,ndsz,is3,ke3,as2,zc3,t2)
	! 			!slanted = 0
	! 			endif
	! 		endif
	! 		endif
	! 	elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
	! 	if( (zc3-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
	! 	if( (zc3-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
	! 		if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
	! 		call setMirror_w(vec1,ndsx,ndsz,is3,ke3,as2,zc3,t2)
	! 		!slanted = 0
	! 		endif
	! 	endif
	! 	endif
	! 	endif
	! 	if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
	! 		if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
	! 		if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
	! 		if( (zc3-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
	! 		call setMirror_w(vec1,ndsx,ndsz,is3,ke3,as2,zc3,t2)
	! 		!lanted = 0
	! 		if(flagA.eq.1)then
	! 			call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as2,zc4,t2)
	! 			slanted = 0
	! 		endif
	! 		endif
	! 		endif
	! 		endif
	! 	endif
	! 	endif
	 	!Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME	
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			 ! case b.1.1.1  Checking if u(is2,jjj,ke3) is2 bellow cn3-cn
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke3r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					 if( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 else
					 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
					 !dom(ib)%woo(is2,jjj,ke3) = t2
				 endif		
			 endif				
		 ! The the West face has not yet been pierced	
		 elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			 ! case b.2.1.1  Checking if u(is2,jjj,ke3) is2 bellow cn3-cn5 
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke3r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					 if( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 else
					 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
					 !dom(ib)%woo(is2,jjj,ke3) = t2
				 endif		
			 endif
		 ! The Face S has not been pierced so far	
		 elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			 ! case b.2.1.1  Checking if u(is2,jjj,ke3) is2 bellow cn5-cn7 
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 else
					 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2	
					 !dom(ib)%woo(is2,jjj,ke3) = t2
				 endif
			 endif
		 elseif ( (ndsx(9) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as2-ndsx(9))/(ndsx(7)-ndsx(9))
			 ! case b.2.1.1  Checking if u(is2,jjj,ke3) is2 bellow cn5-cn7 
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
						 !dom(ib)%woo(is2,jjj,ke3) = t2
					 endif
				 else
					 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2	
					 !dom(ib)%woo(is2,jjj,ke3) = t2
				 endif
			 endif
		 else ! Face S has not been pierces so far
			 !!!!!!!!!!!! 
			 ! fxq2	 1 1	-1 1	-1-1	-1-1
			 ! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
			 ! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
			 ! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			 ! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			 !
			 !
			 ! 1q 	if pierced *\		 ys2 	> zc3 -	-> 	fzq2 = 1
			 ! 2q 	if pierced *\		 ys2 	> zc3 -	-> 	fzq2 = 1
			 ! 3q 	if pierced \. 		 ys2 	< zc3 -	-> 	fzq2 = -1
			 ! 4q 	if pierced \. 		 ys2 	< zc3 -	-> 	fzq2 = -1
			 if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
					 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
					 !dom(ib)%woo(is2,jjj,ke3) = t2
				 endif
			 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
					 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
					 !dom(ib)%woo(is2,jjj,ke3) = t2
				 endif
			 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
				 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
					 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke3) = t2
					 !dom(ib)%woo(is2,jjj,ke3) = t2
				 endif
			 else
				!
				!!! circle-square difference
				!
				 if( ( zc3 - ndsz(8) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(8) - as2 )*fxq2 .lt. margin)then		
				 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				elseif( ( ndsx(10) - as2 )*fxq2 .lt. margin)then		
				 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				 elseif( ( zc3 - ndsz(10) )*fzq2 .lt. margin)then
				 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				endif
				else
				 call setMirror_w(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				endif
				 endif
			 endif
			 !!!!!!!!!!!!
		 endif	! ndsx(3) ! Finis2hed Check of Face S2 ke3
		 endif ! slanted flag
		 endif!12345 
		!
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke
		!
		!12345
		!!!if(flagC.eq.1)then 
	 	if(dom(ib)%mwcz(is3,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(6) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc1-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
    			if( (as3-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				slanted = 0
				endif
			endif
			endif
		elseif( abs(ndsx(4) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc1-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
    		if( (as3-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as3-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as3-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
			slanted = 0
			endif
			endif
			endif
		endif
		! Checking for slanted segments
		if(slanted.eq.1)then 
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME	
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			 ! case b.1.1.1  Checking if u(is3,jjj,ke) is3 bellow cn3-cn
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					 if( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 else
					 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
					 !dom(ib)%woo(is3,jjj,ke) = t2
				 endif		
			 endif				
		 ! The the West face has not yet been pierced	
		 elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			 ! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn3-cn5 
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					 if( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 else
					 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
					 !dom(ib)%woo(is3,jjj,ke) = t2
				 endif		
			 endif
		 ! The Face S has not been pierced so far	
		 elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			 ! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn5-cn7 
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 else
					 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2	
					 !dom(ib)%woo(is3,jjj,ke) = t2
				 endif
			 endif
		 elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			 ! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn5-cn7 
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
						 !dom(ib)%woo(is3,jjj,ke) = t2
					 endif
				 else
					 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2	
					 !dom(ib)%woo(is3,jjj,ke) = t2
				 endif
			 endif
		 else ! Face S has not been pierces so far
			 !!!!!!!!!!!! 
			 ! fxq2	 1 1	-1 1	-1-1	-1-1
			 ! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			 ! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			 ! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			 ! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			 !
			 !
			 ! 1q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			 ! 2q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			 ! 3q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			 ! 4q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
					 !dom(ib)%woo(is3,jjj,ke) = t2
				 endif
			 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
					 !dom(ib)%woo(is3,jjj,ke) = t2
				 endif
			 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
					 !dom(ib)%woo(is3,jjj,ke) = t2
				 endif
			 else
				!
				!!! circle-square difference
				!
				!!! check ???					if( ( zc1 - ndsz(8) )*fzq2 .lt. margin)then
				if( ( zc1 - ndsz(6) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(8) - as3 )*fxq2 .lt. margin)then
				 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				elseif( ( ndsx(10) - as3 )*fxq2 .lt. margin)then
				 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				!!! check ???				 elseif( ( ndsx(10) - as3 )*fxq2 .lt. margin)then
				 elseif( ( zc1 - ndsz(8) )*fzq2 .lt. margin)then
				 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				endif
				else
				 call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				endif
				endif
				 !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2	
				 !dom(ib)%woo(is3,jjj,ke) = t2
			 endif
			 !!!!!!!!!!!!
		 endif	! ndsx(3) ! Finis3hed Check of Face S3 ke
		 endif ! slanted flag
		 endif!12345 
		!!!endif!flagC
		!
		!
        !
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke2
		!12345 
		!!!if(flagC.eq.1)then
		if(dom(ib)%mwcz(is3,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(6) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc2-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
				if( (as3-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				slanted = 0
				endif
			endif
			endif
		elseif( abs(ndsx(4) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc2-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as3-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as3-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as3-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
					!dom(ib)%woo(is3,jjj,ke2) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn3-cn5 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
					!dom(ib)%woo(is3,jjj,ke2) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2	
					!dom(ib)%woo(is3,jjj,ke2) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
						!dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2	
					!dom(ib)%woo(is3,jjj,ke2) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
					!dom(ib)%woo(is3,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
					!dom(ib)%woo(is3,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
					!dom(ib)%woo(is3,jjj,ke2) = t2
				endif
			else
		 		if( ( zc2 - ndsz(8) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(8) - as3 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				elseif( ( ndsx(10) - as3 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				elseif( ( zc2 - ndsz(10) )*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				endif
				else
				call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S3 ke2
		endif ! slanted flag
		endif!12345 
		!!!endif!flagC
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S4 ke
		!
		!12345 
		if(dom(ib)%mwcz(is4,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if( (flagC.eq.1) ) then
		slanted = 1
		if( abs(ndsx(6) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc1-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(4) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc1-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as4-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as4-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as4- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is4,jjj,ke) is4 bellow cn3-cn
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as4)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
					!dom(ib)%woo(is4,jjj,ke) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is4,jjj,ke) is4 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as4)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
					!dom(ib)%woo(is4,jjj,ke) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is4,jjj,ke) is4 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2	
					!dom(ib)%woo(is4,jjj,ke) = t2
				endif
			endif
		elseif ( (ndsx(9) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as4-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is4,jjj,ke) is4 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2	
					!dom(ib)%woo(is4,jjj,ke) = t2
				endif
			endif
		elseif ( (ndsx(11) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as4-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is4,jjj,ke) is4 bellow cn5-cn9 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
						!dom(ib)%woo(is4,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2	
					!dom(ib)%woo(is4,jjj,ke) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as4	but if is4 is pierced *\ 	ndsx(4)	< as4	-> 	fxq2 = 1
			! 2q *\						if is4 is pierced *\	ndsx(4)	< as4	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as4	but if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			! 4q \.						if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
					!dom(ib)%woo(is4,jjj,ke) = t2
				endif
			elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
					!dom(ib)%woo(is4,jjj,ke) = t2
				endif
			elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
					!dom(ib)%woo(is4,jjj,ke) = t2
				endif
			elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke) = t2
					!dom(ib)%woo(is4,jjj,ke) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ??? if( ( zc1 - ndsz(10) )*fzq2 .lt. margin)then
				if( ( zc1 - ndsz(12) )*fzq2 .lt. margin)then
				!!! check ??? if( ( zc1 - ndsz(14) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ??? if( ( ndsx(10) - as4 )*fxq2 .lt. margin)then
				if( ( ndsx(12) - as4 )*fxq2 .lt. margin)then
				!!! check ??? if( ( ndsx(14) - as4 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				!!! check ??? elseif( ( ndsx(12) - as4 )*fxq2 .lt. margin)then
				elseif( ( ndsx(14) - as4 )*fxq2 .lt. margin)then
				!!! check ??? elseif( ( ndsx(16) - as4 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				!!! check ??? elseif( ( zc1 - ndsz(10) )*fzq2 .lt. margin)then
				elseif( ( zc1 - ndsz(14) )*fzq2 .lt. margin)then
				!!! check ??? elseif( ( zc1 - ndsz(16) )*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				endif
				else
				call setMirror_w(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis4hed Check of Face S4 ke
		endif ! checking for flagC
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S4 ke2
		!
		!12345 
		if(dom(ib)%mwcz(is4,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		!if( (flagC.eq.1).or.(flagD.eq.1)) then
		if( (flagC.eq.1) ) then
		slanted = 1
		if( abs(ndsx(8) - ndsx(5)) .lt. margin ) then			! Checking for vertical segments
			if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc2-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc2-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as4-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as4-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as4- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as4)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
					!dom(ib)%woo(is4,jjj,ke2) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn3-cn5 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as4)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
					!dom(ib)%woo(is4,jjj,ke2) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2	
					!dom(ib)%woo(is4,jjj,ke2) = t2
				endif
			endif
		elseif ( (ndsx(9) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as4-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2	
					!dom(ib)%woo(is4,jjj,ke2) = t2
				endif
			endif
		elseif ( (ndsx(11) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as4-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is4,jjj,ke2) is4 bellow cn5-cn9 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
						!dom(ib)%woo(is4,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2	
					!dom(ib)%woo(is4,jjj,ke2) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as4	but if is4 is pierced *\ 	ndsx(4)	< as4	-> 	fxq2 = 1
			! 2q *\						if is4 is pierced *\	ndsx(4)	< as4	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as4	but if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			! 4q \.						if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
					!dom(ib)%woo(is4,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
					!dom(ib)%woo(is4,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
					!dom(ib)%woo(is4,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is4,jjj,ke2) = t2
					!dom(ib)%woo(is4,jjj,ke2) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ???
				if( ( zc2 - ndsz(10) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ???
				if( ( ndsx(10) - as4 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				!!! check ???
				elseif( ( ndsx(12) - as4 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				!!! check ???
				elseif( ( zc2 - ndsz(12) )*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				endif
				else
				!!! check ??? pass
				call setMirror_w(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis4hed Check of Face S4 ke2
		endif ! slanted flag
		endif	! checking for flagC / flagD
		endif!12345
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2 ke4
		!
		!12345 
		if(dom(ib)%mwcz(is2,jjj,ke4).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if( (flagA.eq.1).or.(flagA.eq.2).or.(flagB.eq.1)) then
		!slanted = 1
		if( abs(ndsx(8) - ndsx(5)) .lt. margin ) then			! Checking for vertical segments
		!if( abs(ndsx(8) - ndsx(9)) .lt. margin ) then			! Checking for vertical segments
			if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc4-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc4-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc4-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        !! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn3-cn
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
					!dom(ib)%woo(is2,jjj,ke4) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn3-cn5 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
					!dom(ib)%woo(is2,jjj,ke4) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2	
					!dom(ib)%woo(is2,jjj,ke4) = t2
				endif
			endif
		elseif ( (ndsx(9) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as2-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2	
					!dom(ib)%woo(is2,jjj,ke4) = t2
				endif
			endif
		elseif ( (ndsx(11) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as2-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is2,jjj,ke4) is2 bellow cn5-cn9 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
						!dom(ib)%woo(is2,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2	
					!dom(ib)%woo(is2,jjj,ke4) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
			! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
					!dom(ib)%woo(is2,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
					!dom(ib)%woo(is2,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
					!dom(ib)%woo(is2,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke4) = t2
					!dom(ib)%woo(is2,jjj,ke4) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ??? if( ( zc4 - ndsz(10) )*fzq2 .lt. margin)then
				if( ( zc4 - ndsz(14) )*fzq2 .lt. margin)then
				!!! check ??? if( ( zc4 - ndsz(16) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ??? if( ( ndsx(10) - as2 )*fxq2 .lt. margin)then
				if( ( ndsx(14) - as2 )*fxq2 .lt. margin)then
				!!! check ??? if( ( ndsx(16) - as2 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				!!! check ??? elseif( ( ndsx(12) - as2 )*fxq2 .lt. margin)then
				elseif( ( ndsx(16) - as2 )*fxq2 .lt. margin)then
				!!! check ??? elseif( ( ndsx(18) - as2 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				!!! check ??? elseif( ( zc4 - ndsz(12) )*fzq2 .lt. margin)then
				elseif( ( zc4 - ndsz(16) )*fzq2 .lt. margin)then
				!!! check ??? elseif( ( zc4 - ndsz(18) )*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				endif
				else
				call setMirror_w(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke4
		endif	! Checking for flagA / flagB
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!
		!!!!!! CHECKING FACE S2 ke5 ! If we take this into account it adds an exyra layer ant the bottom of the cylinder (RE100,13.8,3.975)
		!!!!
		!!!12345 
		!!if(dom(ib)%mwcz(is2,jjj,ke5).eq.0) then	! checking if this cell has already been flagged
		!!!if( (flagA.eq.1).or.(flagB.eq.1)) then
		!!if( (flagA.eq.2) ) then
		!!!if(1) then	! checking if this cell has already been flagged
		!!slanted = 1
		!!if( abs(ndsx(10) - ndsx(7)) .lt. margin ) then			! Checking for vertical segments
		!!!if( abs(ndsx(10) - ndsx(11)) .lt. margin ) then
		!!	if( (zc5-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		!!	if( (zc5-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
		!!	if( (as2-ndsx(1))*fxq2 .lt. margin)then
		!!	call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!	slanted = 0
		!!	endif
		!!	endif
		!!	endif
		!!elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		!!if( (zc5-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		!!if( (zc5-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
		!!	if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
		!!	call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!	slanted = 0
		!!	endif
		!!endif
		!!endif
		!!endif
		!!if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
		!!	if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
		!!	if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
		!!	if( (zc5-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
		!!	call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!	slanted = 0
		!!	endif
		!!	endif
		!!	endif
		!!endif
        !!! Checking for slanted segments
		!!if(slanted.eq.1)then
		!!if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		!!	ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
		!!	! case b.1.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn3-cn
		!!	if( ( zc5 - ys)*fzq2 .gt. -margin ) then
		!!		if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke5r cn3 pierces the West face too
		!!			ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
		!!			if( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
		!!			ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!			ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		else
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif		
		!!	endif				
		!!! The the West face has not yet been pierced	
		!!elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
		!!	ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
		!!	! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn3-cn5 
		!!	if( ( zc5 - ys)*fzq2 .gt. -margin ) then
		!!		if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke5r cn3 pierces the West face too
		!!			ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
		!!			if( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
		!!			ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!			ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		else
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif		
		!!	endif
		!!! The Face S has not been pierced so far	
		!!elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		!!	ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
		!!	! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn5-cn7 
		!!	if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
		!!		if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
		!!			ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!		ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!		ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		else
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	endif
		!!elseif ( (ndsx(9) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		!!	ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as2-ndsx(9))/(ndsx(7)-ndsx(9))
		!!	! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn5-cn7 
		!!	if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
		!!		if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
		!!			ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!		ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		else
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	endif
		!!elseif ( (ndsx(11) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		!!	ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as2-ndsx(11))/(ndsx(9)-ndsx(11))
		!!	! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn5-cn9 
		!!	if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
		!!		if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
		!!			ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!			ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		else
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	endif
		!!elseif ( (ndsx(13) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		!!	ys=ndsz(13)+(ndsz(11)-ndsz(13))*(as2-ndsx(13))/(ndsx(11)-ndsx(13))
		!!	! case b.2.1.1  Checking if u(is2,jjj,ke5) is2 bellow cn5-cn9 
		!!	if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
		!!		if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
		!!			ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!		ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!		ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
		!!			if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!				call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!				!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!			endif
		!!		else
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	endif
		!!else ! Face S has not been pierces so far
		!!!!!!!!!!!!!! 
		!!! fxq2	 1 1	-1 1	-1-1	-1-1
		!!	! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
		!!	! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
		!!	! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
		!!	! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
		!!	!
		!!	!
		!!	! 1q 	if pierced *\		 ys2 	> zc5 -	-> 	fzq2 = 1
		!!	! 2q 	if pierced *\		 ys2 	> zc5 -	-> 	fzq2 = 1
		!!	! 3q 	if pierced \. 		 ys2 	< zc5 -	-> 	fzq2 = -1
		!!	! 4q 	if pierced \. 		 ys2 	< zc5 -	-> 	fzq2 = -1
		!!	if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
		!!		ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
		!!		if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!		ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
		!!		if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
		!!		ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
		!!		if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
		!!		if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
		!!		if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
		!!	ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
		!!		if ( ( zc5 - ys2)*fzq2 .lt. margin) then
		!!			call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!			!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2
		!!			!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!		endif
		!!	else
		!!		!
		! !		!!! circle-square difference
		!!		!
		!!		if( ( zc5 - ndsz(14) )*fzq2 .lt. margin)then
		!!		if((qf.eq.2).or.(qf.eq.4))then
		!!		if( ( ndsx(14) - as2 )*fxq2 .lt. margin)then
		!!		call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!		elseif( ( ndsx(14) - as2 )*fxq2 .lt. margin)then
		!!		call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!		elseif( ( zc5 - ndsz(14) )*fzq2 .lt. margin)then
		!!		call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!		endif
		!!		else
		!!		call setMirror_w(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
		!!		endif
		!!		endif
		!!		!if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke5) = t2	
		!!		!dom(ib)%uoo(is2,jjj,ke5) = t2
		!!	endif
		!!	!!!!!!!!!!!!
		!!endif	! ndsx(3) ! Finis2hed Check of Face S2 ke5
		!!endif ! flagA / flagB check
		!!endif ! slanted flag
		!!endif!12345 
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke4
		!
		!12345 
		if(dom(ib)%mwcz(is3,jjj,ke4).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if( (flagA.eq.1).or.(flagA.eq.2).or.(flagB.eq.1)) then
		slanted = 1
		if( abs(ndsx(10) - ndsx(7)) .lt. margin ) then			! Checking for vertical segments
		!if( abs(ndsx(10) - ndsx(11)) .lt. margin ) then
			if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc4-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as3-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc4-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as3-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as3-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as3-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc4-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn3-cn
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
					!dom(ib)%woo(is3,jjj,ke4) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn3-cn5 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
					!dom(ib)%woo(is3,jjj,ke4) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2	
					!dom(ib)%woo(is3,jjj,ke4) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2	
					!dom(ib)%woo(is3,jjj,ke4) = t2
				endif
			endif
		elseif ( (ndsx(11) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as3-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is3,jjj,ke4) is3 bellow cn5-cn9 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
						!dom(ib)%woo(is3,jjj,ke4) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2	
					!dom(ib)%woo(is3,jjj,ke4) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
					!dom(ib)%woo(is3,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
					!dom(ib)%woo(is3,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
					!dom(ib)%woo(is3,jjj,ke4) = t2
				endif
			elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke4) = t2
					!dom(ib)%woo(is3,jjj,ke4) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ??? 				if( ( zc4 - ndsz(14) )*fzq2 .lt. margin)then
				if( ( zc4 - ndsz(10) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ??? 				if( ( ndsx(14) - as3 )*fxq2 .lt. margin)then
				if( ( ndsx(10) - as3 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				!!! check ??? elseif( ( ndsx(16) - as3 )*fxq2 .lt. margin)then
				elseif( ( ndsx(12) - as3 )*fxq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				!!! check ??? 				elseif( ( zc4 - ndsz(16) )*fzq2 .lt. margin)then
				elseif( ( zc4 - ndsz(12) )*fzq2 .lt. margin)then
				call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				endif
				else
				call setMirror_w(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S2 ke4
		endif	! Checking for flagA / flagB
		endif ! slanted flag
		endif!12345 
		!
		!
		endif
		!
		endif

!######################################################################
	END SUBROUTINE setQuadrant_w
!######################################################################
			

!######################################################################
	SUBROUTINE setMirror_w(vec1,ndsx,ndsz,iq,kq,xq,zq,k)
!######################################################################
				!
		    	use imb
		    	use mpi
		        use multidata
		        use vars
		    	!
		    	implicit none
		    	!
		    	! temporal variables
		    	DOUBLE PRECISION:: temp
		    	!
		    	! Input valriables
		    	INTEGER, INTENT(IN):: vec1(8) !vec1(9)
				DOUBLE PRECISION, INTENT(IN):: ndsx(19), ndsz(19)
		    	!
		    	! Location of cell face center of ghost cell 
		    	INTEGER, INTENT(IN):: iq, kq
		        DOUBLE PRECISION, INTENT(IN):: xq, zq
		        DOUBLE PRECISION:: yq
		    	!
		    	! Output variables
		    	DOUBLE PRECISION, INTENT(OUT):: k
		    	!
		    	! Interfaces
		    	INTEGER:: nn, ib, ll, iii, jjj, kkk
		    	INTEGER::  qF, M
		    	! qF: quadrantFlag
		    	!
		    	! Search loop index
		    	INTEGER:: dd, bb, cc
		    	!
		    	! Location of the neares marker
		    	DOUBLE PRECISION:: mkx, mkz, mkx2, mkz2, mkx3, mkz3
		    	!
		    	! Distances between ghost cell and markers
		    	DOUBLE PRECISION:: rad1, rad2, radAux
		    	!
		    	! Angle of the closts markers to the ghost cell
		    	DOUBLE PRECISION:: cosTetha1, sinTetha1
		    	DOUBLE PRECISION:: cosAlpha1, cosAlpha2, tanBetha1
		    	DOUBLE PRECISION:: alpha1, alpha2, betha1, tetha1
		    	!
		    	! Location of mirror point
		    	DOUBLE PRECISION:: mrx, mry, mrz
		    	!
		    	! Indeces of mirror cell centre
		    	INTEGER:: id,jd, kd
		    	!
			    DOUBLE PRECISION:: origin_xc, origin_yc, origin_z
			    DOUBLE PRECISION::dx_l, dy_l, dz_l
		    	!
		    	! mirror velocities
		    	Integer:: ii, jj
		    	DOUBLE PRECISION:: mirror_w
		    	DOUBLE PRECISION:: nx(2),nz(2),wvec(4)
		    	INTEGER:: vec2(8)
		    	DOUBLE PRECISION:: vec3(3)
		    	!
		    	! Flags
		    	INTEGER:: flag90, flag1, flag2
		    	DOUBLE PRECISION:: fx, fz
		    	!
		    	! safety variables
		    	DOUBLE PRECISION:: margin
			DOUBLE PRECISION:: maxAlpha
				!
				! writing warnings
				integer:: sn
				character*8 :: chb1
				character*35 :: gf ! file name
				integer:: St_k,mksPS,mksEL,nnFinish,nnStart 
				!
				! variables flor checking subdomain boundaries
				integer:: ips,ipe,kws,kwe,i_n_cells,k_n_cells
				!
				!
				!if (myrank.eq. master ) then ! The control is passed down to the master processor
		        nn  = vec1(1)
		        ib  = vec1(2)
		        ll  = vec1(3)
		        iii = vec1(4)
		        jjj = vec1(5)
		        kkk = vec1(6)
		        qF  = vec1(7) ! this is defined in a finction later
		        M   =  vec1(8)
				!
				! Initializing return value
				k = 0.0d00
		        !
		    if(imbinblock_loc(dom_id(ib)+1).NE.0) then	! Filtering out procesors that do not 
															! have accesss to the domain where the 
			    if(imb_block_loc(nn).eq.dom_id(ib)) then
				!
				!origin_xc = vec1(8)
				!origin_y = vec1(9)
				!origin_z = vec1(10)
				!
				! Filter for testing
				! if( (qF.eq.1 ).and.(ll.lt.2) ) then
				!if( (ll.lt.2).and.((qF.eq.1).or.(qF.eq.2)) ) then
			    if( (ll.lt.2) ) then !.and.((qF.eq.1).or.(qF.eq.2)) ) then					
				!
				flag90 = 0
				margin = 1.0e-5
				maxAlpha = 90.001
				!
				!!! Search loop for closest markers to the velocity cell centre
				mkx = ndsx(1)
				mkz = ndsz(1)
				mkx2 = ndsx(2)
				mkz2 = ndsz(2)
				dd = 2
				bb = dd - 1
				cc = dd

				rad1 = (mkx-xq)**2 + (mkz-zq)**2
				rad2 = (mkx2-xq)**2 + (mkz2-zq)**2

				mkx3 = ndsx(3)
				mkz3 = ndsz(3)
				radAux = (mkx3-xq)**2 + (mkz3-zq)**2
				if (radAux .lt. rad2) then
					mkx2 = mkx
					mkz2 = mkz
					mkx  = mkx3
					mkz  = mkz3
					rad2 = rad1
					rad1 = radAux

					bb = dd + 1
					cc = dd - 1
				endif
				!
				do dd = 4, 14, 2

					mkx3 = ndsx(dd)
					mkz3 = ndsz(dd)					
					radAux = (mkx3-xq)**2 + (mkz3-zq)**2

					if (radAux .lt. rad1) then
						mkx  = mkx2
						mkz  = mkz2
						mkx2 = mkx3
						mkz2 = mkz3	
						rad1 = rad2
						rad2 = radAux
						bb = dd - 2
						cc = dd
					else
						mkx3 = ndsx(dd+1)
						mkz3 = ndsz(dd+1)
						radAux = (mkx3-xq)**2 + (mkz3-zq)**2
						if (radAux .lt. rad2) then
							mkx2 = mkx
							mkz2 = mkz
							mkx  = mkx3
							mkz  = mkz3	
							rad2 = rad1
							rad1 = radAux
							bb = dd + 1
							cc = dd - 1
						endif
					endif
				enddo

				rad1 = sqrt(rad1)
				rad2 = sqrt(rad2)
				

				cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) ! alpha1: angle between U cell centre and segment mk1-mk2
				cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) ! alpha2: angle between U cell centre and segment mk2-mk1
				alpha1 = DACOS(cosAlpha1)*180/piNUm
				alpha2 = DACOS(cosAlpha2)*180/piNum
				! If there is a normal from the velocity cell centre to the surface (segment mk1-mk2) alpha1 < 90 and alpha2 < 90


				St_k = ibmSt(M) ! number of station of the inmmersed body
				mksPS = ibmStMkrs(M)	! Markers per station
				mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				nnStart = 1 + (int(St_k/2.0d00))*mksPS
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				if (alpha1 .gt. maxAlpha) then
					flag90 = 1
					write(6,*) "Warning in mirror_w subroutine!", nn, bb
					write(6,*) "alpha1 greater thant 90: ", alpha1
					write(6,*) "alpha2: ", alpha2
					Write(6,*) "xq, zq: ", xq, zq
					Write(6,*) "mkx, mkz: ", mkx, mkz
					Write(6,*) "mkx2, mkz2: ", mkx2, mkz2
					write(6,*) ""

					! Update bb and cc
					if (bb .eq. 2) then
						! bb = 2		cc = 4
						bb = bb - 1
						cc = cc - 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb - 2
						cc = cc - 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb + 2
						cc = cc + 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum

				
				elseif (alpha2 .gt. maxAlpha) then
					flag90 = 1
					write(6,*) "Warning in mirror_w subroutine!", nn, bb
					write(6,*) "Warning: alpha2 greater thant 90: ", alpha2
					write(6,*) "alpha1: ", alpha1
					Write(6,*) "xq, zq: ", xq, zq
					Write(6,*) "mkx, mkz: ", mkx, mkz
					Write(6,*) "mkx2, mkz2: ", mkx2, mkz2
					write(6,*) ""
					! Update bb and redefine the nodes
					if (bb .eq. 1) then
						! bb = 1		cc = 2
						bb = bb + 1
						cc = cc + 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb + 2
						cc = cc + 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb - 2
						cc = cc - 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum				
				endif
				endif

				if (flag90) then
					write(chb1,'(i6)') nn
					sn=len(trim(adjustl(chb1)))
					gf='w_w_m_alpha'//repeat('0',(6-sn))//trim(adjustl(chb1))
					OPEN(unit = 906, access = "sequential", action = "write",
     &   status = "replace", file = gf, form = "formatted") 

					!	write(6,*) "*** Index, Qudarant ***"
						write(906,*) nn, qF
						write(906,*) ndsx
						write(906,*) ndsz
						write(906,*) iii, kkk, jjj	
						write(906,*) iq, kq
						write(906,*) alpha1, alpha2
						!write(6,*) betha1, tetha1
					! location of P pressure cell centre
						write(906,*) xq, zq
					! location of closest markers
						write(906,*) mkx, mkz
						write(906,*) mkx2, mkz2
						write(906,*) bb, cc		
						write(906,*) ndsx(bb), ndsz(bb)
						write(906,*) ndsx(cc), ndsz(cc)
						!write(6,*) mrx, mrz		
						write(906,*) id, kd
						write(906,*) "==="
						close(906)
						write(6,*) "new alpha1, alpha2: ", alpha1, alpha2
						Write(6,*) "xq, zq: ", xq, zq
						Write(6,*) "mkx, mkz: ", mkx, mkz
						Write(6,*) "mkx2, mkz2: ", mkx2, mkz2
						write(6,*) ""
						write(6,*) "---------------------------"
					endif

				! redefining quadrant of the neighbouring markers
				qF = quadrant(ndsx(bb), ndsz(bb),ndsx(cc), ndsz(cc),margin)
				!
				!
				dx_l = dom(ib)%dx
				dy_l = dom(ib)%dy
				dz_l = dom(ib)%dz
				!
				origin_xc = dom(ib)%xc(1)
				origin_yc = dom(ib)%yc(1)
				origin_z = dom(ib)%z(1)
				!
				!
				!
		    	if (qF.eq.1) then
		    		!
		    		tetha1 = alpha1 - betha1 
		    		cosTetha1 = DCOS(tetha1*piNUm/180)
		    		sinTetha1 = DSIN(tetha1*piNUm/180)
		    		! The mirror point will always be forward of marker1
		    		mrx = mkx + rad1*cosTetha1
		    		! mry = ???
		    		! The mirror point may be above marker1 if betha1 > alpha1
		    		mrz = mkz - rad1*sinTetha1
		    	elseif(qF.eq.2) then
		    		tetha1 =   alpha1 - (90 - betha1) 
		    		cosTetha1 = DCOS(tetha1*piNUm/180)
		    		sinTetha1 = DSIN(tetha1*piNUm/180)
		    		! The mirror point may be behind maker1 if alpha1 < (90 - betha1)
		    		mrx = mkx + rad1*sinTetha1
		    		! mry = ???
		    		! The mirror point will alpway be above marker1
		    		mrz = mkz + rad1*cosTetha1
		    	elseif(qF.eq.3) then
		    		tetha1 = betha1 - alpha1
		    		cosTetha1 = DCOS(tetha1*piNUm/180)
		    		sinTetha1 = DSIN(tetha1*piNUm/180)
		    		! The mirror point will always be behind marker 1
		    		mrx = mkx - rad1*cosTetha1
		    		! mry = ???
		    		! The mirror point may be above marker 1 if alpha1 > betha1
		    		mrz = mkz - rad1*sinTetha1
		    		!
		    	elseif(qF.eq.4) then
		    		!
		    		tetha1 = 90 - betha1 - alpha1
		    		cosTetha1 = DCOS(tetha1*piNUm/180)
		    		sinTetha1 = DSIN(tetha1*piNUm/180)
		    		!
		    		! mirror point may be behind or forward of marker 1 if alpha1 > (90 - betha1)
		    		mrx = mkx + rad1*sinTetha1
		    		! mry = ???
		    		! mirror point will alway be bellow marker 1
		    		mrz = mkz - rad1*cosTetha1
		    		!
		    	endif
		    	!
			! Indices of the mirror W cell
			id = int ( ( mrx - origin_xc - margin) /dx_l) + 2 
			!jd = int ( ( mry - origin_yc - margin) /dy_l) + 2
			!
			yq = dom(ib)%y(jjj) ! dom(ib)%yc(jjj)
			!
			kd = int ( ( mrz - origin_z - margin) /dz_l) + 2
			!
			! Bounds for w velocity component (NOT INCLUDING GHOST LAYERS)
			ips=dom(ib)%isp; ipe=dom(ib)%iep 
			kws=dom(ib)%ksw; kwe=dom(ib)%kew
			!
			! Checking mirror point  proximity to the subdomain boundaries 
			if((kd-2.ge.kws-3).and.(kd+1.le.kwe+3).and.
     & 		(id-2.ge.ips-3).and.(id+1.le.ipe+3)
     & 		)then
			!			if((kd.gt.kws-3).and.(kd.lt.kwe+3).and.
			!     & 		(id.gt.ips-3).and.(id.lt.ipe+3)
			!     & 		)then
			!
			! lets flag this cell as a body cell
			dom(ib)%mwcz(iq,jjj,kq) = qF
			!
			! Lets add the necesary information
			dom(ib)%mwcznn(iq,jjj,kq) = nn  ! nn for w ghost cells
			dom(ib)%mwczib(iq,jjj,kq) = ib  ! ib for w ghost cells
			dom(ib)%mwczll(iq,jjj,kq) = ll  ! ll for w ghost cells
			dom(ib)%mwczi(iq,jjj,kq)  = iq  ! %x  id for w ghost cells
			dom(ib)%mwczj(iq,jjj,kq)  = jjj ! %yc id for w ghost cells
			dom(ib)%mwczk(iq,jjj,kq)  = kq  ! %z  id for w ghost cells
			dom(ib)%mwczx(iq,jjj,kq)  = xq  ! %x  for w ghost cells
			dom(ib)%mwczy(iq,jjj,kq)  = yq  ! %yc for w ghost cells
			dom(ib)%mwczz(iq,jjj,kq)  = zq  ! %z  for w ghost cells
			dom(ib)%mwczmi(iq,jjj,kq) = id  ! %x  id for w mirror cells
			dom(ib)%mwczmj(iq,jjj,kq) = jjj ! %yc id for w mirror cells
			dom(ib)%mwczmk(iq,jjj,kq) = kd  ! %z  id for w mirror cells
			dom(ib)%mwczmx(iq,jjj,kq) = mrx ! %x  for w mirror cells
			dom(ib)%mwczmy(iq,jjj,kq) = yq  ! %yc for w mirror cells
			dom(ib)%mwczmz(iq,jjj,kq) = mrz ! %z  for w mirror cells
			!
			!
			else
				! debug
				St_k = ibmSt(M) ! number of station of the inmmersed body
				mksPS = ibmStMkrs(M)	! Markers per station
				mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				nnStart = 1 + (int(St_k/2.0d00))*mksPS
				!
				i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
				k_n_cells = dom(ib)%ttc_k
				!
				if(kd-2.lt.kws-3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iii,jjj,kkk,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with kd-2.lt.kws-3",kd,abs(kws-3)
				write(*,*) ib, k_n_cells
				write(*,*) kws,kwe
				endif
				kd = kws - 1
				endif
				if(kd+1.gt.kwe+3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iii,jjj,kkk,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with kd+1.gt.kwe+3",kd,abs(kwe+3)
				write(*,*) ib, k_n_cells
				write(*,*) kws,kwe
				endif
				kd = kwe + 2
				endif
				if(id-2.lt.ips-3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iii,jjj,kkk,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with id-2.lt.ips-3 ",id,abs(ips-3)
				write(*,*) ib, i_n_cells
				write(*,*) ips,ipe
				endif
				id = ips - 1
				endif
				if(id+1.gt.ipe+3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iii,jjj,kkk,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with id+1.gt.ipe+3 ",id,abs(ipe+3)
				write(*,*) ib, i_n_cells
				write(*,*) ips,ipe
				endif
				id = ips + 2
				endif
				!
				! lets flag this cell as a body cell
				dom(ib)%mwcz(iq,jjj,kq) = qF
				!
				! Lets add the necesary information
				dom(ib)%mwcznn(iq,jjj,kq) = nn  ! nn for w ghost cells
				dom(ib)%mwczib(iq,jjj,kq) = ib  ! ib for w ghost cells
				dom(ib)%mwczll(iq,jjj,kq) = ll  ! ll for w ghost cells
				dom(ib)%mwczi(iq,jjj,kq)  = iq  ! %x  id for w ghost cells
				dom(ib)%mwczj(iq,jjj,kq)  = jjj ! %yc id for w ghost cells
				dom(ib)%mwczk(iq,jjj,kq)  = kq  ! %z  id for w ghost cells
				dom(ib)%mwczx(iq,jjj,kq)  = xq  ! %x  for w ghost cells
				dom(ib)%mwczy(iq,jjj,kq)  = yq  ! %yc for w ghost cells
				dom(ib)%mwczz(iq,jjj,kq)  = zq  ! %z  for w ghost cells
				dom(ib)%mwczmi(iq,jjj,kq) = id  ! %x  id for w mirror cells
				dom(ib)%mwczmj(iq,jjj,kq) = jjj ! %yc id for w mirror cells
				dom(ib)%mwczmk(iq,jjj,kq) = kd  ! %z  id for w mirror cells
				dom(ib)%mwczmx(iq,jjj,kq) = mrx ! %x  for w mirror cells
				dom(ib)%mwczmy(iq,jjj,kq) = yq  ! %yc for w mirror cells
				dom(ib)%mwczmz(iq,jjj,kq) = mrz ! %z  for w mirror cells
				!
			endif ! flag id, kd for proximity to control volume boundaries
			!
		    endif
			!
			!!! END PROCESOR HANDLING subdomain ib
		    endif
			!
	       endif


			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!!!!!!!!       FUNCTION DECLARATION       !!!!!!!!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			CONTAINS

			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Second order Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_ux1, mirror_ux2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjj,kd)
			!	ux2 = dom(ib)%u(id+1,jjj,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = uvec(1)	!dom(ib)%u(id,jjj,kd)
			ux2 = uvec(2) 	!dom(ib)%u(id-1,jjj,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_ux1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjj,kd-1)
			!ux2 = dom(ib)%u(id+1,jjj,kd-1)

			! Alternative
			ux1 = uvec(3)	!dom(ib)%u(id,jjj,kd-1)
			ux2 = uvec(4)	!dom(ib)%u(id-1,jjj,kd-1)

			mirror_ux2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_ux1
			uz2 = mirror_ux2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)


			!######################################################################
			END FUNCTION l1
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################


!######################################################################		
			END SUBROUTINE setMirror_w
!######################################################################


!######################################################################			
	SUBROUTINE setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkc,qF)
!######################################################################		
		use imb
		use mpi
		use multidata

		implicit none

		! temporal variables
		DOUBLE PRECISION:: temp, t1, t2

		! Input valriables
		INTEGER, INTENT(IN):: nn, ll, ib, iic,jjc,kkc
		INTEGER, INTENT(IN):: qF
		DOUBLE PRECISION, INTENT(IN)::ndsx(19),ndsz(19)

		! safety variables
		DOUBLE PRECISION:: margin

		! Intersections
		DOUBLE PRECISION:: ys, ys2

		! Locations of faces
		DOUBLE PRECISION:: as4,as3,as2,as,ae,ae2,ae3

		DOUBLE PRECISION:: cs3,cs2,cs,ce,ce2,ce3

		DOUBLE PRECISION:: zc0, zc1, zc2, zc3, zc4,zc5

		! Indeces of faces
		INTEGER:: ke0,ke,ke2,ke3,ke4,ke5
		INTEGER:: ie, is, is2, is3,is4

		! Special variables for avoiding selecting cell outise the geometry in the 2nd and 4th quarters
		INTEGER:: isq, keq, ieq
		DOUBLE PRECISION:: asq, aeq
		INTEGER:: fxq1, fzq1, fxq2, fzq2, fxs3, fzs3, fxk3, fzk3

		
		! Flags
		INTEGER:: flag1, flag2, flagA, flagB, flagC
		INTEGER:: slanted, debugF
		DOUBLE PRECISION:: fx, fz

		! Interfaces
		INTEGER:: vec1(7)

		vec1(1) = nn
		vec1(2) = ib
		vec1(3) = ll
		vec1(4) = iic
		vec1(5) = jjc
		vec1(6) = kkc
		vec1(7) = qF

		margin = 1.0e-5

		!if (myrank.eq. master ) then ! The control is passed down to the master processor
		if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
			IF(imb_block_loc(nn).eq.dom_id(ib)) then

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 1st quadrant

		if (qF.eq.1) then
	
		as = dom(ib)%xc(iic-1) 
		as2 = dom(ib)%xc(iic-2)
		as3 = dom(ib)%xc(iic-3)
		as4 = as3 - abs(as3 - as2) ! dom(ib)%xc(iic-4)
		asq = as

		ae = dom(ib)%xc(iic) 
		aeq = as !ae
		
		ae2 = dom(ib)%xc(iic+1)
		ae3 = dom(ib)%xc(iic+2)
		
		cs3 = dom(ib)%z(kkc-3)
		cs2 = dom(ib)%z(kkc-2)
		cs = dom(ib)%z(kkc-1)

		ce = dom(ib)%z(kkc) 
		ce2 = dom(ib)%z(kkc+1)
		ce3 = dom(ib)%z(kkc+2)	

		zc0 = dom(ib)%zc(kkc-1)	! cell centre. We want to obtain the mirror value for this cell centre
		zc1 = dom(ib)%zc(kkc)	! cell centre. We want to obtain the mirror value for this cell centre
		zc2 = dom(ib)%zc(kkc+1)	! cell centre. We want to obtain the mirror value for this cell centre
		zc3 = dom(ib)%zc(kkc+2)	! cell centre. We want to obtain the mirror value for this cell centre
		zc4 = dom(ib)%zc(kkc+3)	! cell centre. We want to obtain the mirror value for this cell centre
		zc5 = zc4 + abs(zc4-zc3) ! dom(ib)%zc(kkc+4)	! cell centre. We want to obtain the mirror value for this cell centre
		!
		ie = iic; ke = kkc; ke0 = kkc-1
		ke2 = kkc+1; ke3 = kkc+2; ke4 = kkc+3; ke5 = kkc+4

		is = iic-1 ; is2 = iic-2; is3 = iic - 3; is4 = iic - 4
		isq = is; keq = ke
		ieq = is	

		fx = 1.0d00
		fz = 1.0d00
		fxq1 = fx
		fzq1 = fz
		fxq2 = fx
		fzq2 = fz
		fxs3 = fx
		fzs3 = fz

		endif

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 2nd quadrant

		if (qF.eq.2) then

			ae3 = dom(ib)%xc(iic-3)
			ae2 = dom(ib)%xc(iic-2)	
			ae = dom(ib)%xc(iic-1) 
	
			as = dom(ib)%xc(iic) 
			asq = ae
			aeq = ae

			as2 = dom(ib)%xc(iic-2)
			as3 = dom(ib)%xc(iic-3)
			as4 = as3 - abs(as3 - as2) ! dom(ib)%xc(iic-4)

			cs3 = dom(ib)%z(kkc-3)
			cs2 = dom(ib)%z(kkc-2)
			cs = dom(ib)%z(kkc-1)
	
			ce = dom(ib)%z(kkc) 
			ce2 = dom(ib)%z(kkc+1)
			ce3 = dom(ib)%z(kkc+2)

			zc0 = dom(ib)%zc(kkc+1)	! cell centre. We want to obtain the mirror value for this cell centre
			zc1 = dom(ib)%zc(kkc)	! cell centre. We want to obtain the mirror value for this cell centre
			zc2 = dom(ib)%zc(kkc-1)	! cell centre. We want to obtain the mirror value for this cell centre
			zc3 = dom(ib)%zc(kkc-2)	! cell centre. We want to obtain the mirror value for this cell centre
			zc4 = dom(ib)%zc(kkc-3)	! cell centre. We want to obtain the mirror value for this cell centre
			zc5 = zc4 - abs(zc4 - zc3) ! dom(ib)%zc(kkc-4)	! cell centre. We want to obtain the mirror value for this cell centre
	
			ie = iic-1; ke = kkc; ke0 = kkc+1
			ke2 = kkc-1; ke3 = kkc-2; ke4 = kkc-3; ke5 = kkc - 4
	
			is = iic; is2 = iic-2; is3 = iic - 3; is4 = iic - 4
			isq = is; keq = kkc + 1
			ieq = ie
				
			fx = -1.0d00
			fz = -1.0d00
			fxq1 = fx
			fzq1 = fz
			fxq2 = -fx
			fzq2 = -fz		
			fxs3 = -fx
			fzs3 = -fz

			endif



		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 3rd quadrant
				
			if (qF.eq.3) then

				ae3 = dom(ib)%xc(iic-3)
				ae2 = dom(ib)%xc(iic-2)	
				ae = dom(ib)%xc(iic-1) 
		
				as = dom(ib)%xc(iic) 
				asq = as
				aeq = as
	
				as2 = dom(ib)%xc(iic+1)
				as3 = dom(ib)%xc(iic+2)
				as4 = dom(ib)%xc(iic+3)
				
	
				cs3 = dom(ib)%z(kkc-3)
				cs2 = dom(ib)%z(kkc-2)
				cs = dom(ib)%z(kkc-1)
		
				ce = dom(ib)%z(kkc) 
				ce2 = dom(ib)%z(kkc+1)
				ce3 = dom(ib)%z(kkc+2)	

				zc0 = dom(ib)%zc(kkc+1)	! cell centre. We want to obtain the mirror value for this cell centre
				zc1 = dom(ib)%zc(kkc)	! cell centre. We want to obtain the mirror value for this cell centre
				zc2 = dom(ib)%zc(kkc-1)	! cell centre. We want to obtain the mirror value for this cell centre
				zc3 = dom(ib)%zc(kkc-2)	! cell centre. We want to obtain the mirror value for this cell centre
				zc4 = dom(ib)%zc(kkc-3)	! cell centre. We want to obtain the mirror value for this cell centre
				zc5 = zc4 - abs(zc4 - zc3) ! dom(ib)%zc(kkc-4)	! cell centre. We want to obtain the mirror value for this cell centre
				!
				ie = iic-1; ke = kkc; ke0 = kkc+1
				ke2 = kkc-1; ke3 = kkc-2; ke4 = kkc-3; ke5 = kkc - 4
		
				is = iic; is2 = iic+1; is3 = iic+2; is4 = iic+3
				isq = is; keq = ke		
				ieq = is
						
			!	is = iic; is2 = iic; is3 = iic + 1

				fx = -1.0d00
				fz = -1.0d00
				fxq1 = -fx
				fzq1 = -fz
				fxq2 = fx
				fzq2 = fz
				fxs3 = fx
				fzs3 = fz


				endif



		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 4th quadrant
				
			if (qF.eq.4) then

				ae3 = dom(ib)%xc(iic+2)
				ae2 = dom(ib)%xc(iic+1)	
				ae = dom(ib)%xc(iic) 
				
		
				as = dom(ib)%xc(iic-1) 
				asq = ae
				aeq = ae
	
				as2 = dom(ib)%xc(iic+1)
				as3 = dom(ib)%xc(iic+2)
				as4 = dom(ib)%xc(iic+3)
				
				cs3 = dom(ib)%z(kkc-3)
				cs2 = dom(ib)%z(kkc-2)
				cs = dom(ib)%z(kkc-1)
		
				ce = dom(ib)%z(kkc) 
				ce2 = dom(ib)%z(kkc+1)
				ce3 = dom(ib)%z(kkc+2)	

				zc0 = dom(ib)%zc(kkc-1)	! cell centre. We want to obtain the mirror value for this cell centre
				zc1 = dom(ib)%zc(kkc)	! cell centre. We want to obtain the mirror value for this cell centre
				zc2 = dom(ib)%zc(kkc+1)	! cell centre. We want to obtain the mirror value for this cell centre
				zc3 = dom(ib)%zc(kkc+2)	! cell centre. We want to obtain the mirror value for this cell centre
				zc4 = dom(ib)%zc(kkc+3)	! cell centre. We want to obtain the mirror value for this cell centre
				zc5 = zc4 + abs(zc4 - zc3) ! dom(ib)%zc(kkc+4)	! cell centre. We want to obtain the mirror value for this cell centre
				!
				ie = iic; ke = kkc; ke0 = kkc-1
				ke2 = kkc+1; ke3 = kkc+2; ke4 = kkc+3; ke5 = kkc + 4
				!
				is = iic-1; is2 = iic+1; is3 = iic+2; is4 = iic+3
				isq = ie; keq = kkc - 1
				ieq = ie
		
				fx = 1.0d00
				fz = 1.0d00
				fxq1 = fx
				fzq1 = fz
				fxq2 = -fx
				fzq2 = -fz
				fxs3 = -fx
				fzs3 = -fz
				!
				endif
				!!!!! Checking quadrants
		!
		!
		flag1 = 0
		flag2 = 0
		flagA = 0
		flagB = 0
		flagC = 0

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE E

		if ( ( ndsx(2) -  ae )*fx.gt. -margin ) then	! The East Face is pierced for the FIRTS TIME
			!
			ys = ndsz(1) + (ndsz(2) - ndsz(1))*(ae - ndsx(1))/(ndsx(2) - ndsx(1))
			!
			! case a.1.1.1	 Checking if w(ie,jjc,ke0) is above cn-cn2
			!12345 
			if(dom(ib)%mpc(ie,jjc,ke0).eq.0) then	! checking if this cell has already been flagged
			!if(1)  then
			slanted = 1
			! Checking for vertical segments
			if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then
				!if( (zc0-ndsz(1))*fzq2 .gt. -margin)then 	! horizontal lower bound
				!if( (zc0-ndsz(2))*fzq2 .lt. margin)then	! horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east	bound
				call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				else
					flagC = 1
				!endif
				!endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(4) - ndsz(2)) .lt. margin ) ) then ! checking corners 1-2q and 3-4q
				if( (zc0-ndsz(2))*fzq2 .lt. margin)then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				else
				!call setMirror_p(vec1,ndsx,ndsz,is,ke0,as,zc0,t2)
				!slanted = 0
				endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(3)).lt.margin).and.
     & 			(abs(ndsz(2) - ndsz(1)) .lt. margin ) ) then ! checking corners 2-1q and 4-3q
				if( (as-ndsx(1))*fxq2 .lt. margin)then
				if( (zc0-ndsz(2))*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				!2else
				!2call setMirror_p(vec1,ndsx,ndsz,ie,ke02,ae,zc2,t2)
				!2slanted = 0
				endif
				!else
				!	if( (zc0-ndsz(2))*fzq2 .lt. margin)then
				!	call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				!	slanted = 0
				!	!2else
				!	!2call setMirror_p(vec1,ndsx,ndsz,ie,ke02,ae,zc2,t2)
				!	!2slanted = 0
				!	endif
				endif
			endif
			if((abs(ndsx(4)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(2)) .lt. margin ) ) then ! checking corners 2-3q and 4-1q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc0-ndsz(1))*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				!2else
				!2call setMirror_p(vec1,ndsx,ndsz,ie,ke02,ae,zc2,t2)
				!2slanted = 0
				endif
				else
			!		if( (zc0-ndsz(1))*fzq2 .lt. margin)then
			!		call setMirror_p(vec1,ndsx,ndsz,is,ke0,as,zc0,t2)
			!		slanted = 0
			!		!2else
			!		!2call setMirror_p(vec1,ndsx,ndsz,ie,ke02,ae,zc2,t2)
			!		!2slanted = 0
			!		endif
				endif
			endif
			if((abs(ndsx(2)-ndsx(1)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(3)) .lt. margin ) ) then ! checking corners 3-2q and 1-4q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc0-ndsz(1))*fzq2 .gt. -margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				endif
				endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then
				if( (zc0-ndsz(1))*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
				slanted = 0
				else
				flagA = 1
				slanted = 0
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc0 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke0) = t2
                        !!if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke0) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke0) = t2
                        !!if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke0) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke0) = t2
                        !!if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke0) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke0) = t2
                    !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke0) = t2
				endif		
			!endif
			! case a.1.1.2	 Checking if w(ie,jjc,ke0) is above cn-cn2
			else
				!flag2 = 1
				flagA = 1
		
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
			! case a.1.1.1	 Checking if w(ie,jjc,ke) is above cn-cn2
			!12345 
			if(dom(ib)%mpc(ie,jjc,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			slanted = 1
			! Checking for vertical segments
			if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then
				!if( (zc1-ndsz(1))*fzq2 .gt. -margin)then 	! horizontal lower bound
				!if( (zc1-ndsz(2))*fzq2 .lt. margin)then	! horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east	bound
				call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				else
					flagC = 1
				!endif
				!endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(4) - ndsz(2)) .lt. margin ) ) then ! checking corners 1-2q and 3-4q
				if( (zc1-ndsz(2))*fzq2 .lt. margin)then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				else
				!call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
				!slanted = 0
				endif
				endif
			endif
			if((abs(ndsx(1)-ndsx(3)).lt.margin).and.
     & 			(abs(ndsz(2) - ndsz(1)) .lt. margin ) ) then ! checking corners 2-1q and 4-3q
				if( (as-ndsx(1))*fxq2 .lt. margin)then
				if( (zc1-ndsz(2))*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				!2else
				!2call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				!2slanted = 0
				endif
				!else
				!	if( (zc1-ndsz(2))*fzq2 .lt. margin)then
				!	call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				!	slanted = 0
				!	!2else
				!	!2call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				!	!2slanted = 0
				!	endif
				endif
			endif
			if((abs(ndsx(4)-ndsx(2)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(2)) .lt. margin ) ) then ! checking corners 2-3q and 4-1q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc1-ndsz(1))*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				!2else
				!2call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				!2slanted = 0
				endif
				else
			!		if( (zc1-ndsz(1))*fzq2 .lt. margin)then
			!		call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
			!		slanted = 0
			!		!2else
			!		!2call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
			!		!2slanted = 0
			!		endif
				endif
			endif
			if((abs(ndsx(2)-ndsx(1)).lt.margin).and.
     & 			(abs(ndsz(1) - ndsz(3)) .lt. margin ) ) then ! checking corners 3-2q and 1-4q
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (zc1-ndsz(1))*fzq2 .gt. -margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				endif
				endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then
				if( (zc1-ndsz(1))*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
				slanted = 0
				else
				flagA = 2
				slanted = 0
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc1 - ys)*fz .gt. -margin ) then	
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke) = t2
                        !!if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke) = t2
					endif
		! There  may be an issue
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke) = t2
                    !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke) = t2
				endif	
				!flagA = 1
			else
				!flag2 = 1
				flagA = 2	
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
			!
		! case a.1.1.2	 Checking if w(ie,jjc,ke2) is above cn-cn2
			!12345 
			if(dom(ib)%mpc(ie,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			slanted = 1
			if( abs(ndsx(4) - ndsx(1)) .lt. margin ) then	! Checking for vertical segments
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then	!	horizontal lower bound
				if( (zc2-ndsz(4))*fzq2 .lt. margin)then		!	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical outer bound
				call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				slanted = 0
				else
					flagC = 1
				endif
				endif
				!endif
			elseif( abs(ndsx(2) - ndsx(1)) .lt. margin ) then	! Checking for vertical segments
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then	!	horizontal lower bound
				if( (zc2-ndsz(2))*fzq2 .lt. margin)then		!	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical west bound
				call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				slanted = 0
				else
					flagC = 1
				endif
				endif
				!endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then
				if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then		!	vertical west bound
				if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
				call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
				slanted = 0
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc2 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke2) = t2
                        !!if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke2) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke2) = t2
                    !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke2) = t2
				endif
				!flagA = 1
			else
				!flagA = 1
				!flagC = 1
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
			!
			! case a.1.1.2	 Checking if w(ie,jjc,ke3) is above cn-cn2
			!12345 
			if(dom(ib)%mpc(ie,jjc,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			slanted = 1
			if( abs(ndsx(6) - ndsx(1)) .lt. margin ) then	! Checking for vertical segments
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then 	!	horizontal lower bound
				if( (zc3-ndsz(6))*fzq2 .lt. margin)then		!	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
				call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
				slanted = 0
				else
					flagC = 1
				endif
				!endif
				endif
			elseif( abs(ndsx(4) - ndsx(1)) .lt. margin ) then 	! Checking for vertical segments
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then		!	horizontal lower bound 
				if( (zc3-ndsz(4))*fzq2 .lt. margin)then 		! 	horizontal upper bound
    			if( (ae-ndsx(1))*fxq2 .lt. margin)then			!	vertical east	bound
				call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
				slanted = 0
				else
					flagC = 1
				endif
				!endif
				endif
			endif
			! Checking for horizontal segments
			if( abs(ndsz(2) - ndsz(3)) .lt. margin ) then
				if( (ae-ndsx(3))*fxq2 .lt. margin)then			!	vertical east	bound
				if( (ae-ndsx(2))*fxq2 .gt. -margin)then			!	vertical west	bound
				if( (zc3-ndsz(1))*fzq2 .lt. margin)then			! 	horizontal upper bound
				call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
				slanted = 0
					!if((flagA.eq.1).and.(ke4.gt.8))then
			! warning
					if(flagA.eq.2)then
					call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
					slanted = 0
					endif
				endif
				endif
				endif
			endif
			! Checking for slanted segments
			if(slanted.eq.1)then
			if( ( zc3 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke3) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke3) = t2
                    !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke3) = t2
				endif		
			endif
			endif ! slanted flag
			endif!12345 
			!
			!
		elseif ( ( ndsx(4) - ae )*fx .gt. -margin ) then	! The East face is pierced for the FIRST TIME
			!
		ys = ndsz(2) + (ndsz(4)-ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
		!
			! case a.1.1.1	 Checking if w(ie,jjc,ke0) is above cn2-cn4
	!		!12345 if(dom(ib)%mpc(ie,jjc,ke0).eq.0) then	! checking if this cell has already been flagged
	!		!if(1) then
	!		if( ( zc0 - ys)*fz .gt. -margin ) then
	!			if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
	!				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
	!				if( ( zc0 - ys2)*fz .lt. margin) then
	!					call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !					!if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke0) = t2
    !					!if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke0) = t2
	!				endif
	!			elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
	!				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
	!				if( ( zc0 - ys2)*fz .lt. margin) then
	!					call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !					!if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke0) = t2
    !                   !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke0) = t2
	!				endif
	!			elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
	!				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))				
	!				if ( ( zc0 - ys2)*fz .lt. margin) then
	!					call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !					!if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke0) = t2
    !                   !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke0) = t2
	!				endif
	!	! There  may be an issue			
	!			else
	!				call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !				!if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke0) = t2
    !               !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke0) = t2
	!			endif		
	!		!endif
	!		! case a.1.1.2	 Checking if w(ie,jjc,ke0) is above cn2-cn4
	!		!else
	!			!flag2 = 1
	!	
	!		endif
	!		endif!12345 
		!
		!
			! case a.2.1.1	Checking if w(ie,jjc,ke) is above cn2-cn4
			!12345 
			if(dom(ib)%mpc(ie,jjc,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke) = t2
                    !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke) = t2
				endif
				!flagB = 1
			else
			!	flag2 = 1
				flagB = 1 ! firts layer not included within the nds4-nds1 segment
			endif
			endif!12345 
			!
			!
			!
			! case a.2.1.2  Checking if w(ie,jjc,ke2) is above cn2-cn4 
			!12345 
			if(dom(ib)%mpc(ie,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke2) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke2) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke2) = t2
					endif
		! There  may be an issue
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke2) = t2
                    !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke2) = t2
				endif
				!flagB = 1
			else
				!flagB = 1
			endif
			endif!12345 
			!
		! case a.1.1.2	 Checking if w(ie,jjc,ke3) is above cn-cn2
			!12345 
			if(dom(ib)%mpc(ie,jjc,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke3) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke3) = t2
                        !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke3) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(ie,jjc,ke3) = t2
                    !if(fieldF.eq.2) dom(ib)%poo(ie,jjc,ke3) = t2
				endif		
			endif
			endif!12345 
			!
		else			
			!elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too

	!			! case a.2.1.1	Checking if w(ieq,jjc,ke0) is above cn4-cn6
	!		if(dom(ib)%mpc(ieq,jjc,ke0).eq.0) then	! checking if this cell has already been flagged
	!		!if(1) then
	!		if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
	!			ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
	!			if( ( zc0 - ys2)*fzq1 .lt. margin) then
	!				call setMirror_p(vec1,ndsx,ndsz,ieq,ke0,aeq,zc0,t2)
    !				!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke0) = t2
    !           !if(fieldF.eq.2) dom(ib)%poo(ieq,jjc,ke0) = t2
	!			endif
	!		elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
	!			ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
	!			if( ( zc0 - ys2)*fzq1 .lt. margin) then
	!				call setMirror_p(vec1,ndsx,ndsz,ieq,ke0,aeq,zc0,t2)
    !				!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke0) = t2
    !           !if(fieldF.eq.2) dom(ib)%poo(ieq,jjc,ke0) = t2
	!			endif
	!	! There  may be an issue			
	!		else
	!			call setMirror_p(vec1,ndsx,ndsz,ieq,ke0,aeq,zc0,t2)
    !			!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke0) = t2
    !           !if(fieldF.eq.2) dom(ib)%poo(ieq,jjc,ke0) = t2
	!		endif
	!		!endif!12345 
			!
			!
			!
			! case a.2.1.1	Checking if w(ieq,jjc,ke) is above cn4-cn6
			!12345 
			if(dom(ib)%mpc(ieq,jjc,ke).eq.0) then	! checking if this cell has already been flagged
				!if(1) then
				slanted = 1
				if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
					slanted = 0
				!if( (zc1-ndsz(3))*fzq2 .gt. -margin)then			!	horizontal lower bound
				if( (zc1-ndsz(2))*fzq2 .lt. margin)then				!	horizontal upper bound
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then			!	vertical east bound
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					endif
				endif
				!endif
				endif
				if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
					slanted = 0
					if( (aeq-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
					if( (aeq-ndsx(2))*fxq2 .gt. -margin)then	!	vertical west bound
					if( (zc1-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					else
						flagA = 2
					endif
					endif
					endif
				endif
			!	! Checking for slanted segments
				if(slanted.eq.1)then
				if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc1 - ys2)*fzq1 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke) = t2
					endif
				elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fzq1 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke) = t2
					endif
			! There  may be an issue			
				else
					! WARNING	WARNING	WARNING
					if( ( zc1 - ndsz(4) )*fzq1 .gt. -margin)then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke) = t2
					endif
				endif
				endif ! slanted flag
				endif!12345 
				!
				!
				!
		!	! case a.2.1.2  Checking if w(ieq,jjc,ke2) is above cn4-cn6 
				!12345 
				if(dom(ib)%mpc(ieq,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
				!if(1) then
				if( abs(ndsx(4) - ndsx(1)) .lt. margin ) then			! Checking for vertical segments
					slanted = 0
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc2-ndsz(4))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					endif
				endif
				!endif
				elseif( abs(ndsx(2) - ndsx(1)) .lt. margin ) then		! Checking for vertical segments
					slanted = 0
				!if( (zc2-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc2-ndsz(2))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					endif
				endif
				!endif
				endif
				if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
					slanted = 0
					if( (aeq-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
					if( (aeq-ndsx(2))*fxq2 .gt. -margin)then	!	vertical west bound
					if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					endif
					endif
					endif
				endif
				! Checking for slanted segments
				if(slanted.eq.1)then
				if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc2 - ys2)*fzq1 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq1 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke2) = t2
						!if(fieldF.eq.2) dom(ib)%poo(ieq,jjc,ke2) = t2
					endif
				!WARNING	WARNING	WARNING
				elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq1 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke2) = t2
					endif
				else
					if( ( zc2 - ndsz(6) )*fzq1 .gt. -margin)then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke2) = t2
					endif
				endif
				endif ! slanted flag
				endif!12345 
				!
				!
				!
				!
				!
				! case a.1.1.2	 Checking if w(ieq,jjc,ke3) is above cn4-cn6
				!12345 
				if(dom(ib)%mpc(ieq,jjc,ke3).eq.0) then	! checking if this cell has already been flagged
				!if(1) then
				if( abs(ndsx(6) - ndsx(1)) .lt. margin ) then			! Checking for vertical segments
					slanted = 0
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc3-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then
						call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					endif
				endif
				!endif
				elseif( abs(ndsx(4) - ndsx(1)) .lt. margin ) then		! Checking for vertical segments
					slanted = 0
				!if( (zc3-ndsz(1))*fzq2 .gt. -margin)then				!	horizontal lower bound 
				if( (zc3-ndsz(4))*fzq2 .lt. margin)then					!	horizontal upper bound 
    				if( (aeq-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
						call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					endif
				endif
				!endif
				endif
				if( abs(ndsz(2) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
					slanted = 0
					if( (aeq-ndsx(1))*fxq2 .lt. margin)then		!	vertical east bound
					if( (aeq-ndsx(2))*fxq2 .gt. -margin)then	!	vertical west bound
					if( (zc3-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
				! warning
						if(flagA.eq.2)then
						call setMirror_p(vec1,ndsx,ndsz,ieq,ke4,aeq,zc4,t2)
						endif
					endif
					endif
					endif
				endif
				! Checking for slanted segments
				if(slanted.eq.1)then
				if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc3 - ys2)*fzq1 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc3 - ys2)*fzq1 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke3) = t2
					endif
				! WARNING	WARNING	WARNING
				elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc3 - ys2)*fzq1 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke3) = t2
				   !if(fieldF.eq.2) dom(ib)%poo(ieq,jjc,ke3) = t2
					endif
				else
					if( ( zc3 - ndsz(4) )*fzq1 .gt. -margin)then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(ieq,jjc,ke3) = t2
					endif
				endif
				endif ! slanted flag
				endif!12345 
		! WARNING A	
		!else	! The East face has not been pierced 
			flag1 = 1
			!
			flagC = 1 ! first layer not included
			!!flagA = 2		! Horizontal Segment not included
		endif !!! FINISHED CHECKING FACE E
		!
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S
		!
		!12345 
		if(dom(ib)%mpc(is,jjc,ke).eq.0) then	! checking if this cell has already been flagged
        !if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
			!if( (zc1-ndsz(3))*fzq2 .gt. -margin)then		! Horizontal lower bound
			if( (zc1-ndsz(2))*fzq2 .lt. margin)then			! Horizontal upper bound
			if( (as-ndsx(1))*fx .lt. margin)then			! Vertical west bound
				! 1q	> 0			> 0		pierced
				! 2q	> 0			> 0		pierced
				! 3q	< 0			> 0		pierced 
				! 4q	< 0			> 0		pierced
				call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
				slanted = 0
			endif
			endif
			endif
		if( abs(ndsz(2) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as-ndsx(3))*fxq2 .lt. margin)then		! Vertical west bound
			if( (as-ndsx(2))*fxq2 .gt. -margin)then		! Vertical east bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then		! Horizontal lower bound
			call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
			slanted = 0
			!else
			!call setMirror_p(vec1,ndsx,ndsz,is,ke2,as,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
		if(slanted.eq.1)then
		! Checking for slanted segments
		if ( (ndsx(3) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
			! 1q	if pierced  ./	ndsx(3) < as	fx > 0	pass
			! 2q		||		.\	ndsx(3) > as	fx < 0	pass
			! 3q		||		/*	ndsx(3) > as	fx < 0	pass
			! 4q		||		\*	ndsx(3) < as	fx > 0	pass
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is,jjc,ke) is bellow cn3-cn
			if( ( zc1 - ys)*fz .gt. -margin ) then
				! 1q	if inside   ./	zc1 > ys	fz > 0	pass
				! 2q		||  	.\	zc1 < ys	fz < 0	pass
				! 3q		||	    /*	zc1 < ys	fz < 0	pass
				! 4q		||	    \*	zc1 > ys	fz > 0	pass
				if ( ( ndsx(5) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					! 1q	if pierced  twice	/*	ndsx(5) > as	fx > 0	pass
					! 2q		||				\*	ndsx(5) < as	fx < 0	pass
					! 3q		||				./	ndsx(5) < as	fx < 0	pass
					! 4q		||				.\	ndsx(5) > as	fx > 0	pass
					if( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if inside   /*	zc1 < ys2	fz > 0	pass
						! 2q		||	   	\*	zc1 > ys2	fz < 0	pass
						! 3q		||	   	./	zc1 > ys2	fz < 0	pass
						! 4q		||	   	.\	zc1 < ys2	fz > 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q	    always      	\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q	    always      	_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  again	*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*\	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 /
					!
					! 2q	 |.
					!		 /
					!
					!		/
					! 3q	|*
					!
					!		/
                    ! 4q   *|
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                    !dom(ib)%poo(is,jjc,ke) = t2
                    !endif
				endif		
			endif
			!				
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is,jjc,ke) is bellow cn3-cn5 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(7) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
                    if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
            	        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
            	        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
            	        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
            	        !dom(ib)%poo(is,jjc,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	    !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                    !dom(ib)%poo(is,jjc,ke) = t2
                    !endif
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is,jjc,ke) is bellow cn5-cn7 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(9) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(as-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
						!dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
                    if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2	
                    !dom(ib)%poo(is,jjc,ke) = t2
                    !endif
				endif
			endif ! zc1
        else ! Face S has not been pierces so far
				!	1q	*|      is = iii-1
				!	2q	 |*     is = iii
				!	3q	 |.     is = iii
				!	4q	.|      is = iii-1
				if ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q		always  		\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q		always  		_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q	
                        ! debug
                        write(*,*)  "ndsx2"
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*/	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
                    endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2
                        !dom(ib)%poo(is,jjc,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	 |.
					!		 |
					!
					!		 |
					! 3q	 |*
					!
					!		 |
                    ! 4q	*|
					!Warning	Warning	Warning	!Check removing Check of Face S1 ke
					if( ( zc1 - ndsz(6) )*fzq2 .lt. margin)then
					if((qf.eq.2).or.(qf.eq.4))then
				!	if( ( ndsx(6) - as )*fxq2 .gt. -margin)then
				!	call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2	
                    !dom(ib)%poo(is,jjc,ke) = t2
				!	endif
					else ! Warning: lets apply this only in qf = 1, 4
					call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%pstar(is,jjc,ke) = t2	
                    !dom(ib)%poo(is,jjc,ke) = t2
                    endif
					endif
				endif
		endif	 ! ndsx(3)! Finished Check of Face S1 ke
		endif ! slanted flag
		endif!12345
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2
		!
		!12345 
	if(dom(ib)%mpc(is2,jjc,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(2) - ndsx(3)) .lt. margin ) then	! Checking for vertical segments
			if( (zc1-ndsz(3))*fzq2 .gt. -margin)then	! Horizontal lower bound
			!if( (zc1-ndsz(2))*fzq2 .lt. margin)then	! Horizontal upper bound
			if( (as2-ndsx(1))*fx .lt. margin)then		! Vertical east bound
				! 1q	> 0			> 0		pierced
				! 2q	> 0			> 0		pierced
				! 3q	< 0			> 0		pierced 
				! 4q	< 0			> 0		pierced
				call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
				slanted = 0
			endif
			!endif
			endif
		endif
		if( abs(ndsz(4) - ndsz(1)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(4))*fxq2 .lt. margin)then		! Vertical west bound
		!	if( (as2-ndsx(1))*fxq2 .gt. -margin)then	! Vertical east bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then
			call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
			slanted = 0
			endif
		!	endif
			endif
		endif
		! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		! 1q	if pierced  ./	ndsx(3) < as2	fxq2 > 0	pass
		! 2q		||		./	ndsx(3) < as2	fxq2 > 0	pass
		! 3q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
		! 4q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
		ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
		! case b.1.1.1  Checking if u(is2,jjc,ke) is2 bellow cn3-cn
		if( ( zc1 - ys)*fzq2 .gt. -margin ) then
			! 1q	if inside   ./	zc1 > ys	fzq2 > 0	pass
			! 2q		||  	./	zc1 > ys	fzq2 > 0	pass
			! 3q		||	    /*	zc1 < ys	fzq2 < 0	pass
			! 4q		||	    /*	zc1 < ys	fzq2 < 0	pass
			if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
				! 1q	if pierced  twice	/*	ndsx(5) > as2	fxq2 > 0	pass
				! 2q		||				/*	ndsx(5) > as2	fxq2 > 0	pass
				! 3q		||				./	ndsx(5) < as2	fxq2 < 0	pass
				! 4q		||				./	ndsx(5) < as2	fxq2 < 0	pass
				if( ( zc1 - ys2)*fzq2 .lt. margin) then
					! 1q	if inside   /*	zc1 < ys2	fzq2 > 0	pass
					! 2q		||	   	/*	zc1 < ys2	fzq2 > 0	pass
					! 3q		||	   	./	zc1 > ys2	fzq2 < 0	pass
					! 4q		||	   	./	zc1 > ys2	fzq2 < 0	pass
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
					!dom(ib)%poo(is2,jjc,ke) = t2
				endif
			elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
				! 2q	if pierced  again	*\	ndsx(2) < as2	fxq2 > 0	pass
				! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
				! 4q	if pierced  again	\.	ndsx(2) > as2	fxq2 < 0	pass
				ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					! 1q
					! 2q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
					! 3q
					! 4q	if pierced  again	\.	zc1 > ys2	fzq2 < 0	pass
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
					!dom(ib)%poo(is2,jjc,ke) = t2
				endif
			elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				! 1q	if pierced  again	*\	ndsx(4) < as2	fxq2 > 0	pass
				! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
				! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
				! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
					! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
					! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
					! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
					!dom(ib)%poo(is2,jjc,ke) = t2
				endif
			elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
					!dom(ib)%poo(is2,jjc,ke) = t2
				endif
			else	! Face S has not been pierces so far BUT is inside the inmersed body
				! 1q	.|
				!		 /
				!
				! 2q	.|
				!		 /
				!
				!		/
				! 3q	|*
				!
				!		/
				! 4q	|*
				call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
				!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
				!dom(ib)%poo(is2,jjc,ke) = t2
			endif		
		endif
		!				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjc,ke) is2 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
					!dom(ib)%poo(is2,jjc,ke) = t2
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjc,ke) is2 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2	
					!dom(ib)%poo(is2,jjc,ke) = t2
				endif				
			endif ! zc1
		else ! Face S has not been pierces so far
				!	1q	*|
				!	2q	*|
				!	3q	|.
				!	4q	|.
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
					! 2q	if pierced  		*\	ndsx(2) < as2	fxq2 > 0	pass
					! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
					! 4q	if pierced  		\.	ndsx(2) > as2	fxq2 < 0	pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q
						! 2q	if pierced  	*\	zc1 < ys2	fzq2 > 0	pass
						! 3q
						! 4q	if pierced  	\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as2	fxq2 > 0	pass
					! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
					! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
						! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
						! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2
						!dom(ib)%poo(is2,jjc,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	.|
					!		 |
					!
					!		|
					! 3q	|*
					!
					!		|
					! 4q	|*
					!
					!!! circle-square difference
					!
					if( ( zc1 - ndsz(6) )*fzq2 .lt. margin)then

					if((qf.eq.2).or.(qf.eq.4))then
					if( ( ndsx(6) - as2 )*fxq2 .lt. margin)then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					elseif( ( ndsx(8) - as2 )*fxq2 .lt. margin)then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					elseif( ( zc1 - ndsz(8) )*fzq2 .lt. margin)then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					endif
					else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
					endif
					endif
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke) = t2	
					!dom(ib)%poo(is2,jjc,ke) = t2
				endif
		endif	 ! ndsx(3)! Finis2hed Check of Face S2 ke
		endif ! slanted
		endif!12345 
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2 ke2
		!
		!12345 
		if(dom(ib)%mpc(is2,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(4) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			!if( (zc2-ndsz(3))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc2-ndsz(4))*fzq2 .lt. margin)then					!	horizontal upper bound 
    			if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound	
				call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
				slanted = 0
				endif
			endif
			!endif
		elseif( abs(ndsx(2) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		!if( (zc2-ndsz(3))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc2-ndsz(2))*fzq2 .lt. margin)then					!	horizontal upper bound 
    		if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
			slanted = 0
			endif
		endif
		!endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
		! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME	
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjc,ke2) is2 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
					!dom(ib)%poo(is2,jjc,ke2) = t2
				endif		
				endif
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
				! case b.2.1.1  Checking if u(is2,jjc,ke2) is2 bellow cn3-cn5 
				if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
					!dom(ib)%poo(is2,jjc,ke2) = t2
				endif	
				endif
			! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjc,ke2) is2 bellow cn5-cn7 
				if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2	
					!dom(ib)%poo(is2,jjc,ke2) = t2
				endif
				endif
		else ! Face S has not been pierces so far
				!!!!!!!!!!!! 
				! fxq2	 1 1	-1 1	-1-1	-1-1
				! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
				! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
				! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				!
				!
				! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2
						!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
				else
					!
					!!! circle-square difference
					!
					if( ( zc2 - ndsz(6) )*fzq2 .lt. margin)then
					if((qf.eq.2).or.(qf.eq.4))then
					if( ( ndsx(6) - as2 )*fxq2 .lt. margin)then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					elseif( ( ndsx(8) - as2 )*fxq2 .lt. margin)then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					elseif( ( zc2 - ndsz(8) )*fzq2 .lt. margin)then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2	
					!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
					else ! Warning: lets apply this only in qf = 1, 4
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke2) = t2	
					!dom(ib)%poo(is2,jjc,ke2) = t2
					endif
					endif
				endif
				!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke2
		endif ! slanted flag
		endif!12345 
		!
		!
		!
	!	!
	!	!
	!	!
	!	!
	!	!!!!!!!!!!!!!!!!!!
	!	!!! CHECKING FACE S2 ke3
	!	!
	!	!12345 
		if(dom(ib)%mpc(is2,jjc,ke3).eq.0) then	! checking if this cell has already been flagged
		slanted = 1 !!!aaa
		!!!bbb
	!	!if(1) then	! checking if this cell has already been flagged
	! 	if(slanted.eq.0)then
	! 	if( abs(ndsx(8) - ndsx(7)) .lt. margin ) then			! Checking for vertical segments
	! 		if( (zc3-ndsz(7))*fzq2 .gt. -margin)then				!	horizontal lower bound 
	! 		if( (zc3-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
	! 			if( (as2-ndsx(1))*fxq2 .lt. margin)then
	! 			call setMirror_p(vec1,ndsx,ndsz,is3,ke3,as2,zc3,t2)
	! 			!slanted = 0
	! 			endif
	! 		endif
	! 		endif
	! 	elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
	! 	if( (zc3-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
	! 	if( (zc3-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
	! 		if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
	! 		call setMirror_p(vec1,ndsx,ndsz,is3,ke3,as2,zc3,t2)
	! 		!slanted = 0
	! 		endif
	! 	endif
	! 	endif
	! 	endif
	! 	if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
	! 		if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
	! 		if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
	! 		if( (zc3-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
	! 		call setMirror_p(vec1,ndsx,ndsz,is3,ke3,as2,zc3,t2)
	! 		!lanted = 0
	! 		if(flagA.eq.1)then
	! 			call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as2,zc4,t2)
	! 			slanted = 0
	! 		endif
	! 		endif
	! 		endif
	! 		endif
	! 	endif
	! 	endif
	 	!Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME	
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			 ! case b.1.1.1  Checking if u(is2,jjc,ke3) is2 bellow cn3-cn
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke3r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					 if( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 else
					 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
					 !dom(ib)%poo(is2,jjc,ke3) = t2
				 endif		
			 endif				
		 ! The the West face has not yet been pierced	
		 elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			 ! case b.2.1.1  Checking if u(is2,jjc,ke3) is2 bellow cn3-cn5 
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke3r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					 if( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 else
					 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
					 !dom(ib)%poo(is2,jjc,ke3) = t2
				 endif		
			 endif
		 ! The Face S has not been pierced so far	
		 elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			 ! case b.2.1.1  Checking if u(is2,jjc,ke3) is2 bellow cn5-cn7 
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 else
					 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2	
					 !dom(ib)%poo(is2,jjc,ke3) = t2
				 endif
			 endif
		 elseif ( (ndsx(9) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as2-ndsx(9))/(ndsx(7)-ndsx(9))
			 ! case b.2.1.1  Checking if u(is2,jjc,ke3) is2 bellow cn5-cn7 
			 if( ( zc3 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
						 !dom(ib)%poo(is2,jjc,ke3) = t2
					 endif
				 else
					 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2	
					 !dom(ib)%poo(is2,jjc,ke3) = t2
				 endif
			 endif
		 else ! Face S has not been pierces so far
			 !!!!!!!!!!!! 
			 ! fxq2	 1 1	-1 1	-1-1	-1-1
			 ! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
			 ! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
			 ! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			 ! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			 !
			 !
			 ! 1q 	if pierced *\		 ys2 	> zc3 -	-> 	fzq2 = 1
			 ! 2q 	if pierced *\		 ys2 	> zc3 -	-> 	fzq2 = 1
			 ! 3q 	if pierced \. 		 ys2 	< zc3 -	-> 	fzq2 = -1
			 ! 4q 	if pierced \. 		 ys2 	< zc3 -	-> 	fzq2 = -1
			 if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
					 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
					 !dom(ib)%poo(is2,jjc,ke3) = t2
				 endif
			 elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
					 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
					 !dom(ib)%poo(is2,jjc,ke3) = t2
				 endif
			 elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
				 if ( ( zc3 - ys2)*fzq2 .lt. margin) then
					 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke3) = t2
					 !dom(ib)%poo(is2,jjc,ke3) = t2
				 endif
			 else
				!
				!!! circle-square difference
				!
				 if( ( zc3 - ndsz(8) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(8) - as2 )*fxq2 .lt. margin)then		
				 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				elseif( ( ndsx(10) - as2 )*fxq2 .lt. margin)then		
				 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				 elseif( ( zc3 - ndsz(10) )*fzq2 .lt. margin)then
				 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				endif
				else
				 call setMirror_p(vec1,ndsx,ndsz,is2,ke3,as2,zc3,t2)
				endif
				 endif
			 endif
			 !!!!!!!!!!!!
		 endif	! ndsx(3) ! Finis2hed Check of Face S2 ke3
		 endif ! slanted flag
		 endif!12345 
		!
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke
		!
		!12345
		!!!if(flagC.eq.1)then 
	 	if(dom(ib)%mpc(is3,jjc,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(6) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc1-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
    			if( (as3-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				slanted = 0
				endif
			endif
			endif
		elseif( abs(ndsx(4) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc1-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
    		if( (as3-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as3-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as3-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
			slanted = 0
			endif
			endif
			endif
		endif
		! Checking for slanted segments
		if(slanted.eq.1)then 
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME	
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			 ! case b.1.1.1  Checking if u(is3,jjc,ke) is3 bellow cn3-cn
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					 if( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 else
					 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
					 !dom(ib)%poo(is3,jjc,ke) = t2
				 endif		
			 endif				
		 ! The the West face has not yet been pierced	
		 elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			 ! case b.2.1.1  Checking if u(is3,jjc,ke) is3 bellow cn3-cn5 
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					 if( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 else
					 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
					 !dom(ib)%poo(is3,jjc,ke) = t2
				 endif		
			 endif
		 ! The Face S has not been pierced so far	
		 elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			 ! case b.2.1.1  Checking if u(is3,jjc,ke) is3 bellow cn5-cn7 
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 else
					 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2	
					 !dom(ib)%poo(is3,jjc,ke) = t2
				 endif
			 endif
		 elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			 ! case b.2.1.1  Checking if u(is3,jjc,ke) is3 bellow cn5-cn7 
			 if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
						 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
						 !dom(ib)%poo(is3,jjc,ke) = t2
					 endif
				 else
					 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2	
					 !dom(ib)%poo(is3,jjc,ke) = t2
				 endif
			 endif
		 else ! Face S has not been pierces so far
			 !!!!!!!!!!!! 
			 ! fxq2	 1 1	-1 1	-1-1	-1-1
			 ! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			 ! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			 ! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			 ! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			 !
			 !
			 ! 1q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			 ! 2q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			 ! 3q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			 ! 4q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
					 !dom(ib)%poo(is3,jjc,ke) = t2
				 endif
			 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
					 !dom(ib)%poo(is3,jjc,ke) = t2
				 endif
			 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				 if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
					 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2
					 !dom(ib)%poo(is3,jjc,ke) = t2
				 endif
			 else
				!
				!!! circle-square difference
				!
				if( ( zc1 - ndsz(8) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(8) - as3 )*fxq2 .lt. margin)then
				 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				elseif( ( ndsx(10) - as3 )*fxq2 .lt. margin)then
				 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				elseif( ( zc1 - ndsz(10) )*fzq2 .lt. margin)then
				 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				endif
				else
				 call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
				endif
				endif
				 !if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke) = t2	
				 !dom(ib)%poo(is3,jjc,ke) = t2
			 endif
			 !!!!!!!!!!!!
		 endif	! ndsx(3) ! Finis3hed Check of Face S3 ke
		 endif ! slanted flag
		 endif!12345 
		!!!endif!flagC
		!
		!
        !
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke2
		!12345 
		!!!if(flagC.eq.1)then
		if(dom(ib)%mpc(is3,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(6) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc2-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
				if( (as3-ndsx(1))*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				slanted = 0
				endif
			endif
			endif
		elseif( abs(ndsx(4) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc2-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as3-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as3-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as3-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjc,ke2) is3 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
					!dom(ib)%poo(is3,jjc,ke2) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjc,ke2) is3 bellow cn3-cn5 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
					!dom(ib)%poo(is3,jjc,ke2) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjc,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2	
					!dom(ib)%poo(is3,jjc,ke2) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjc,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
						!dom(ib)%poo(is3,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2	
					!dom(ib)%poo(is3,jjc,ke2) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
					!dom(ib)%poo(is3,jjc,ke2) = t2
				endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
					!dom(ib)%poo(is3,jjc,ke2) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke2) = t2
					!dom(ib)%poo(is3,jjc,ke2) = t2
				endif
			else
				!
				!!! circle-square difference
				!
		 		if( ( zc2 - ndsz(8) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(8) - as3 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				elseif( ( ndsx(10) - as3 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				elseif( ( zc2 - ndsz(10) )*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				endif
				else
				call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S3 ke2
		endif ! slanted flag
		endif!12345 
		!!!endif!flagC
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S4 ke
		!
		!12345 
		if(dom(ib)%mpc(is4,jjc,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if( (flagC.eq.1) ) then
		slanted = 1
		if( abs(ndsx(6) - ndsx(3)) .lt. margin ) then			! Checking for vertical segments
			if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc1-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(4) - ndsx(3)) .lt. margin ) then		! Checking for vertical segments
		if( (zc1-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc1-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(4) - ndsz(3)) .lt. margin ) then	! Checking for horizontal segments
			if( (as4-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as4-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc1-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as4- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is4,jjc,ke) is4 bellow cn3-cn
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as4)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
					!dom(ib)%poo(is4,jjc,ke) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is4,jjc,ke) is4 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as4)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
					!dom(ib)%poo(is4,jjc,ke) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is4,jjc,ke) is4 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2	
					!dom(ib)%poo(is4,jjc,ke) = t2
				endif
			endif
		elseif ( (ndsx(9) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as4-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is4,jjc,ke) is4 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2	
					!dom(ib)%poo(is4,jjc,ke) = t2
				endif
			endif
		elseif ( (ndsx(11) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as4-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is4,jjc,ke) is4 bellow cn5-cn9 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
						!dom(ib)%poo(is4,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2	
					!dom(ib)%poo(is4,jjc,ke) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as4	but if is4 is pierced *\ 	ndsx(4)	< as4	-> 	fxq2 = 1
			! 2q *\						if is4 is pierced *\	ndsx(4)	< as4	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as4	but if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			! 4q \.						if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
					!dom(ib)%poo(is4,jjc,ke) = t2
				endif
			elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
					!dom(ib)%poo(is4,jjc,ke) = t2
				endif
			elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
					!dom(ib)%poo(is4,jjc,ke) = t2
				endif
			elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke) = t2
					!dom(ib)%poo(is4,jjc,ke) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ??? if( ( zc1 - ndsz(12) )*fzq2 .lt. margin)then
				if( ( zc1 - ndsz(14) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ??? if( ( ndsx(12) - as4 )*fxq2 .lt. margin)then
				if( ( ndsx(14) - as4 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				!!! check ??? elseif( ( ndsx(14) - as4 )*fxq2 .lt. margin)then
				elseif( ( ndsx(16) - as4 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				!!! check ??? elseif( ( zc1 - ndsz(14) )*fzq2 .lt. margin)then
				elseif( ( zc1 - ndsz(16) )*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				endif
				else
				call setMirror_p(vec1,ndsx,ndsz,is4,ke,as4,zc1,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis4hed Check of Face S4 ke
		endif ! checking for flagC
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S4 ke2
		!
		!12345
		if(dom(ib)%mpc(is4,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		!if( (flagC.eq.1).or.(flagD.eq.1)) then
		if( (flagC.eq.1) ) then
		slanted = 1
		if( abs(ndsx(8) - ndsx(5)) .lt. margin ) then			! Checking for vertical segments
			if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc2-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc2-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc2-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as4-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as4-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as4-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc2-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as4- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is4,jjc,ke2) is4 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as4)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
					!dom(ib)%poo(is4,jjc,ke2) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as4-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is4,jjc,ke2) is4 bellow cn3-cn5 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as4)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
					!dom(ib)%poo(is4,jjc,ke2) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as4-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is4,jjc,ke2) is4 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2	
					!dom(ib)%poo(is4,jjc,ke2) = t2
				endif
			endif
		elseif ( (ndsx(9) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as4-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is4,jjc,ke2) is4 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2	
					!dom(ib)%poo(is4,jjc,ke2) = t2
				endif
			endif
		elseif ( (ndsx(11) - as4)*fxq2 .lt. margin) then	! The West face is4 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as4-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is4,jjc,ke2) is4 bellow cn5-cn9 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
						!dom(ib)%poo(is4,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2	
					!dom(ib)%poo(is4,jjc,ke2) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as4	but if is4 is pierced *\ 	ndsx(4)	< as4	-> 	fxq2 = 1
			! 2q *\						if is4 is pierced *\	ndsx(4)	< as4	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as4	but if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			! 4q \.						if is4 is pierced \.	ndsx(4)	> as4	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as4)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as4-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
					!dom(ib)%poo(is4,jjc,ke2) = t2
				endif
			elseif ( ( ndsx(6) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as4-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
					!dom(ib)%poo(is4,jjc,ke2) = t2
				endif
			elseif ( ( ndsx(8) - as4)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as4-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
					!dom(ib)%poo(is4,jjc,ke2) = t2
				endif
			elseif ( ( ndsx(10) - as4)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as4-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is4,jjc,ke2) = t2
					!dom(ib)%poo(is4,jjc,ke2) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ???
				if( ( zc2 - ndsz(10) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ???
				if( ( ndsx(10) - as4 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				!!! check ???
				elseif( ( ndsx(12) - as4 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				!!! check ???
				elseif( ( zc2 - ndsz(12) )*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				endif
				else
				!!! check ??? pass
				call setMirror_p(vec1,ndsx,ndsz,is4,ke2,as4,zc2,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis4hed Check of Face S4 ke2
		endif ! slanted flag
		endif	! checking for flagC / flagD
		endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2 ke4
		!
		!12345 
		if(dom(ib)%mpc(is2,jjc,ke4).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if( (flagA.eq.1).or.(flagA.eq.2).or.(flagB.eq.1)) then
		!slanted = 1
		if( abs(ndsx(8) - ndsx(5)) .lt. margin ) then			! Checking for vertical segments
		!if( abs(ndsx(8) - ndsx(9)) .lt. margin ) then			! Checking for vertical segments
			if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc4-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc4-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc4-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        !! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjc,ke4) is2 bellow cn3-cn
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
					!dom(ib)%poo(is2,jjc,ke4) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjc,ke4) is2 bellow cn3-cn5 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
					!dom(ib)%poo(is2,jjc,ke4) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjc,ke4) is2 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2	
					!dom(ib)%poo(is2,jjc,ke4) = t2
				endif
			endif
		elseif ( (ndsx(9) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as2-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is2,jjc,ke4) is2 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2	
					!dom(ib)%poo(is2,jjc,ke4) = t2
				endif
			endif
		elseif ( (ndsx(11) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as2-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is2,jjc,ke4) is2 bellow cn5-cn9 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
						!dom(ib)%poo(is2,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2	
					!dom(ib)%poo(is2,jjc,ke4) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
			! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
					!dom(ib)%poo(is2,jjc,ke4) = t2
				endif
			elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
					!dom(ib)%poo(is2,jjc,ke4) = t2
				endif
			elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
					!dom(ib)%poo(is2,jjc,ke4) = t2
				endif
			elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is2,jjc,ke4) = t2
					!dom(ib)%poo(is2,jjc,ke4) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ???
				if( ( zc4 - ndsz(14) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ???
				if( ( ndsx(14) - as2 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				!!! check ???
				elseif( ( ndsx(16) - as2 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				!!! check ???
				elseif( ( zc4 - ndsz(16) )*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				endif
				else
				call setMirror_p(vec1,ndsx,ndsz,is2,ke4,as2,zc4,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke4
		endif	! Checking for flagA / flagB
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!
		!!!!!! CHECKING FACE S2 ke5 ! If we take this into account it adds an exyra layer ant the bottom of the cylinder (RE100,13.8,3.975)
		!!!!
		!12345 
		if(dom(ib)%mpc(is2,jjc,ke5).eq.0) then	! checking if this cell has already been flagged
		!if( (flagA.eq.1).or.(flagB.eq.1)) then
		if( (flagA.eq.2) ) then
		!if(1) then	! checking if this cell has already been flagged
		slanted = 1
		if( abs(ndsx(10) - ndsx(7)) .lt. margin ) then			! Checking for vertical segments
		!if( abs(ndsx(10) - ndsx(11)) .lt. margin ) then
			if( (zc5-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc5-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc5-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc5-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as2-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as2-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as2-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc5-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjc,ke5) is2 bellow cn3-cn
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke5r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjc,ke5) is2 bellow cn3-cn5 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke5r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjc,ke5) is2 bellow cn5-cn7 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2	
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			endif
		elseif ( (ndsx(9) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as2-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is2,jjc,ke5) is2 bellow cn5-cn7 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2	
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			endif
		elseif ( (ndsx(11) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as2-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is2,jjc,ke5) is2 bellow cn5-cn9 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2	
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			endif
		elseif ( (ndsx(13) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(13)+(ndsz(11)-ndsz(13))*(as2-ndsx(13))/(ndsx(11)-ndsx(13))
			! case b.2.1.1  Checking if u(is2,jjc,ke5) is2 bellow cn5-cn9 
			if( ( zc5 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
					if ( ( zc5 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
						!dom(ib)%uoo(is2,jjc,ke5) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2	
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			endif
		else ! Face S has not been pierces so far
		!!!!!!!!!!!! 
		! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
			! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc5 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc5 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc5 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc5 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			elseif ( ( ndsx(8) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as2-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			elseif ( ( ndsx(10) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as2-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			elseif ( ( ndsx(12) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(10)+(ndsz(12) - ndsz(10))*(as2-ndsx(10))/(ndsx(12)-ndsx(10))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			elseif ( ( ndsx(14) - as2)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2=ndsz(12)+(ndsz(14) - ndsz(12))*(as2-ndsx(12))/(ndsx(14)-ndsx(12))
				if ( ( zc5 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2
					!dom(ib)%uoo(is2,jjc,ke5) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				if( ( zc5 - ndsz(14) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				if( ( ndsx(14) - as2 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
				elseif( ( ndsx(16) - as2 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
				elseif( ( zc5 - ndsz(16) )*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
				endif
				else
				call setMirror_p(vec1,ndsx,ndsz,is2,ke5,as2,zc5,t2)
				endif
				endif
				!if(fieldF.eq.1) dom(ib)%ustar(is2,jjc,ke5) = t2	
				!dom(ib)%uoo(is2,jjc,ke5) = t2
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke5
		endif ! flagA / flagB check
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke4
		!
		!12345 
		if(dom(ib)%mpc(is3,jjc,ke4).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if( (flagA.eq.1).or.(flagA.eq.2).or.(flagB.eq.1)) then
		slanted = 1
		if( abs(ndsx(10) - ndsx(7)) .lt. margin ) then			! Checking for vertical segments
		!if( abs(ndsx(10) - ndsx(11)) .lt. margin ) then
			if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
			if( (zc4-ndsz(8))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as3-ndsx(1))*fxq2 .lt. margin)then
			call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		elseif( abs(ndsx(6) - ndsx(5)) .lt. margin ) then		! Checking for vertical segments
		if( (zc4-ndsz(5))*fzq2 .gt. -margin)then				!	horizontal lower bound 
		if( (zc4-ndsz(6))*fzq2 .lt. margin)then					!	horizontal upper bound 
			if( (as3-ndsx(1))*fxq2 .lt. margin)then				!	vertical east bound
			call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
			slanted = 0
			endif
		endif
		endif
		endif
		if( abs(ndsz(6) - ndsz(5)) .lt. margin ) then	! Checking for horizontal segments
			if( (as3-ndsx(3))*fxq2 .lt. margin)then		!	vertical east bound
			if( (as3-ndsx(4))*fxq2 .gt. -margin)then	!	vertical west bound
			if( (zc4-ndsz(1))*fzq2 .lt. margin)then		!	horizontal upper bound 
			call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
			slanted = 0
			endif
			endif
			endif
		endif
        ! Checking for slanted segments
		if(slanted.eq.1)then
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjc,ke4) is3 bellow cn3-cn
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
					!dom(ib)%poo(is3,jjc,ke4) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjc,ke4) is3 bellow cn3-cn5 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke4r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
					!dom(ib)%poo(is3,jjc,ke4) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjc,ke4) is3 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2	
					!dom(ib)%poo(is3,jjc,ke4) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjc,ke4) is3 bellow cn5-cn7 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2	
					!dom(ib)%poo(is3,jjc,ke4) = t2
				endif
			endif
		elseif ( (ndsx(11) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(11)+(ndsz(9)-ndsz(11))*(as3-ndsx(11))/(ndsx(9)-ndsx(11))
			! case b.2.1.1  Checking if u(is3,jjc,ke4) is3 bellow cn5-cn9 
			if( ( zc4 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
				ys2=ndsz(8)+(ndsz(10)-ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
					if ( ( zc4 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
						!dom(ib)%poo(is3,jjc,ke4) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2	
					!dom(ib)%poo(is3,jjc,ke4) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc4 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc4 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
					!dom(ib)%poo(is3,jjc,ke4) = t2
				endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
					!dom(ib)%poo(is3,jjc,ke4) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
					!dom(ib)%poo(is3,jjc,ke4) = t2
				endif
			elseif ( ( ndsx(10) - as3)*fxq2 .lt. margin) then	! safety check  in case cn8 pierced the West face too
			ys2 = ndsz(8) + (ndsz(10) - ndsz(8))*(as3-ndsx(8))/(ndsx(10)-ndsx(8))
				if ( ( zc4 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%pstar(is3,jjc,ke4) = t2
					!dom(ib)%poo(is3,jjc,ke4) = t2
				endif
			else
				!
				!!! circle-square difference
				!
				!!! check ??? 				if( ( zc4 - ndsz(14) )*fzq2 .lt. margin)then
				if( ( zc4 - ndsz(10) )*fzq2 .lt. margin)then
				if((qf.eq.2).or.(qf.eq.4))then
				!!! check ???				if( ( ndsx(14) - as3 )*fxq2 .lt. margin)then
				if( ( ndsx(10) - as3 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				!!! check ???				elseif( ( ndsx(16) - as3 )*fxq2 .lt. margin)then
				elseif( ( ndsx(12) - as3 )*fxq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				!!! check ???				elseif( ( zc4 - ndsz(16) )*fzq2 .lt. margin)then
				elseif( ( zc4 - ndsz(12) )*fzq2 .lt. margin)then
				call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				endif
				else
				call setMirror_p(vec1,ndsx,ndsz,is3,ke4,as3,zc4,t2)
				endif
				endif
			endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S2 ke4
		endif	! Checking for flagA / flagB
		endif ! slanted flag
		endif!12345 
		!
		!
		!
		endif
		!
		endif

!######################################################################
	END SUBROUTINE setQuadrant_p
!######################################################################	 

!######################################################################
	SUBROUTINE setMirror_p(vec1,ndsx,ndsz,iq,kq,xq,zq,k)
!######################################################################

				use imb
				use mpi
				use multidata
				use vars

				implicit none

				! temporal variables
				DOUBLE PRECISION:: temp

				! Input valriables
				INTEGER, INTENT(IN):: vec1(7) !vec1(9)
				DOUBLE PRECISION, INTENT(IN):: ndsx(19), ndsz(19)
				! Location of cell face center of ghost cell 
				INTEGER, INTENT(IN):: iq, kq
				DOUBLE PRECISION, INTENT(IN):: xq, zq
				DOUBLE PRECISION:: yq
				! Output variables
				DOUBLE PRECISION, INTENT(OUT):: k

				! Interfaces
				INTEGER:: nn, ib, ll, iic, jjc, kkc, qF, M
				DOUBLE PRECISION:: origin_x, origin_y, origin_z
				DOUBLE PRECISION:: origin_xc, origin_yc, origin_zc
				DOUBLE PRECISION:: dx_l, dy_l, dz_l
				! Search loop index
				INTEGER:: dd, bb, cc
				! Location of the nearest marker
				DOUBLE PRECISION:: mkx, mkz, mkx2, mkz2, mkx3, mkz3
				! Distances between ghost cell and markers
				DOUBLE PRECISION:: rad1, rad2, radAux
				! Angle of the closts markers to the ghost cell
				DOUBLE PRECISION:: cosTetha1, sinTetha1
				DOUBLE PRECISION:: cosAlpha1, cosAlpha2, tanBetha1
				DOUBLE PRECISION:: alpha1, alpha2, betha1, tetha1
				! Location of mirror point
				DOUBLE PRECISION:: mrx, mry, mrz
				! Indeces of mirror cell centre
				INTEGER:: id,jd, kd
				! mirror pressure
				INTEGER:: ii, jj
				DOUBLE PRECISION:: mirror_p
				DOUBLE PRECISION:: nx(2),nz(2),pvec(4)
				DOUBLE PRECISION:: dx1, dx2, dz1, dz2
				DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
				DOUBLE PRECISION:: b1(4), b2(3), sol(3), ab(4,3)
				DOUBLE PRECISION:: x1, x2, z1, z2
				DOUBLE PRECISION:: q11, q21, q12, q22, qxz

				! Flags
				INTEGER:: flag90, flag1, flag2

				! safety variables
				DOUBLE PRECISION:: margin
				DOUBLE  PRECISION:: maxAlpha


				! writing warnings
				integer:: sn
				character*8 :: chb1
				character*35 :: gf ! file name
				integer:: St_k,mksPS,mksEL,nnFinish,nnStart 
				!
				! variables flor checking subdomain boundaries
				integer:: ips,ipe,kps,kpe,i_n_cells,k_n_cells
				!
				!		if (myrank.eq. master ) then ! The control is passed down to the master processor
				!
				nn = vec1(1)
				ib = vec1(2)
				ll = vec1(3)
				iic = vec1(4)
				jjc = vec1(5)
				kkc = vec1(6)
				qF = vec1(7) ! this is defined in a finction later
				!
				! Initializing return value
				k = 0.0d00
				!
				if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
					IF(imb_block_loc(nn).eq.dom_id(ib)) then

				!origin_xc = vec1(8)
				!origin_yc = vec1(9)
				!origin_zc = vec1(10)

				mirror_p = 0.0d00;
				origin_x = 0.0d00; origin_y = 0.0d00; origin_z = 0.0d00
				origin_xc = 0.0d00; origin_yc = 0.0d00; origin_zc = 0.0d00

				! Filter for testing
			!	if(qF.eq.1) then
				! if( (qF.eq.1 ).and.(ll.lt.2) ) then
			!	if( (ll.lt.2).and.((qF.eq.1).or.(qF.eq.2)) ) then
			!	if( (ll.lt.2) ) then !.and.((qF.eq.1).or.(qF.eq.2)) ) then
				if( (ll.lt.2).and.(qF.lt.5) ) then
			!	if( (nn.gt.0).and.(nn .lt. 1321) ) then

				flag90 = 0
				margin = 1.0e-5
				maxAlpha = 90.001

				!!! Search loop for closest markers to the velocity cell centre
				mkx = ndsx(1)
				mkz = ndsz(1)
				mkx2 = ndsx(2)
				mkz2 = ndsz(2)
				dd = 2
				bb = dd - 1
				cc = dd

				rad1 = (mkx-xq)**2 + (mkz-zq)**2
				rad2 = (mkx2-xq)**2 + (mkz2-zq)**2

				mkx3 = ndsx(3)
				mkz3 = ndsz(3)
				radAux = (mkx3-xq)**2 + (mkz3-zq)**2
				if (radAux .lt. rad2) then
					mkx2 = mkx
					mkz2 = mkz
					mkx  = mkx3
					mkz  = mkz3
					rad2 = rad1
					rad1 = radAux

					bb = dd + 1
					cc = dd - 1
				endif

				
				do dd = 4, 14, 2

					mkx3 = ndsx(dd)
					mkz3 = ndsz(dd)					
					radAux = (mkx3-xq)**2 + (mkz3-zq)**2										

					if (radAux .lt. rad1) then
						mkx  = mkx2
						mkz  = mkz2
						mkx2 = mkx3
						mkz2 = mkz3						
						rad1 = rad2
						rad2 = radAux
						bb = dd - 2
						cc = dd
					else
						mkx3 = ndsx(dd+1)
						mkz3 = ndsz(dd+1)
						radAux = (mkx3-xq)**2 + (mkz3-zq)**2
						if (radAux .lt. rad2) then
							mkx2 = mkx
							mkz2 = mkz
							mkx  = mkx3
							mkz  = mkz3							
							rad2 = rad1
							rad1 = radAux
							bb = dd + 1
							cc = dd - 1
						endif
					endif
				enddo

				rad1 = sqrt(rad1)
				rad2 = sqrt(rad2)
				

				cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) ! alpha1: angle between U cell centre and segment mk1-mk2
				cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) ! alpha2: angle between U cell centre and segment mk2-mk1
				alpha1 = DACOS(cosAlpha1)*180/piNUm
				alpha2 = DACOS(cosAlpha2)*180/piNum
				! If there is a normal from the velocity cell centre to the surface (segment mk1-mk2) alpha1 < 90 and alpha2 < 90


				tanBetha1 = (mkz2-mkz)/(mkx2-mkx)
				betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets make betha1


				! debug
				M = lag_bod_loc(nn)
				St_k = ibmSt(M) ! number of station of the inmmersed body
				mksPS = ibmStMkrs(M)	! Markers per station
				mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				nnStart = 1 + (int(St_k/2.0d00))*mksPS
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				if (alpha1 .gt. maxAlpha) then
					flag90 = 1
					write(6,*) "Warning in mirror_p subroutine!", nn, bb
					write(6,*) "alpha1 greater thant 90: ", alpha1
					write(6,*) "alpha2: ", alpha2
					Write(6,*) "xq, zq: ", xq, zq
					Write(6,*) "mkx, mkz: ", mkx, mkz
					Write(6,*) "mkx2, mkz2: ", mkx2, mkz2
					write(6,*) ""
					! Update bb and cc
					if (bb .eq. 2) then
						! bb = 2		cc = 4
						bb = bb - 1
						cc = cc - 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb - 2
						cc = cc - 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb + 2
						cc = cc + 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum

				
				elseif (alpha2 .gt. maxAlpha) then
					flag90 = 1
					write(6,*) "Warning in mirror_p subroutine!", nn, bb
					write(6,*) "Warning: alpha2 greater thant 90: ", alpha2
					write(6,*) "alpha1: ", alpha1
					Write(6,*) "xq, zq: ", xq, zq
					Write(6,*) "mkx, mkz: ", mkx, mkz
					Write(6,*) "mkx2, mkz2: ", mkx2, mkz2
					write(6,*) ""
					! Update bb and redefine the nodes
					if (bb .eq. 1) then
						! bb = 1		cc = 2
						bb = bb + 1
						cc = cc + 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb + 2
						cc = cc + 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb - 2
						cc = cc - 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum				
				endif
				endif

				if (flag90) then
					write(chb1,'(i6)') nn
					sn=len(trim(adjustl(chb1)))
					gf='w_p_m_alpha'//repeat('0',(6-sn))//trim(adjustl(chb1))
					OPEN(unit = 906, access = "sequential", action = "write",
     &   status = "replace", file = gf, form = "formatted") 

					!	write(6,*) "*** Index, Qudarant ***"
						write(906,*) nn, qF
						write(906,*) ndsx
						write(906,*) ndsz
						write(906,*) iic, kkc, jjc	
						write(906,*) iq, kq
						write(906,*) alpha1, alpha2
						!write(6,*) betha1, tetha1
					! location of P pressure cell centre
						write(906,*) xq, zq
					! location of closest markers
						write(906,*) mkx, mkz
						write(906,*) mkx2, mkz2
						write(906,*) bb, cc		
						write(906,*) ndsx(bb), ndsz(bb)
						write(906,*) ndsx(cc), ndsz(cc)
						!write(6,*) mrx, mrz		
						write(906,*) id, kd
						write(906,*) "==="
						close(906)
						write(6,*) "new alpha1, alpha2: ", alpha1, alpha2
						Write(6,*) "xq, zq: ", xq, zq
						Write(6,*) "mkx, mkz: ", mkx, mkz
						Write(6,*) "mkx2, mkz2: ", mkx2, mkz2
						write(6,*) ""
						write(6,*) "---------------------------"
					endif
					!
					!
				! redefining quadrant of the neighbouring markers
				qF = quadrant(ndsx(bb), ndsz(bb),ndsx(cc), ndsz(cc),margin)
				!
				!
				dx_l = dom(ib)%dx
				dy_l = dom(ib)%dy
				dz_l = dom(ib)%dz
				!
				origin_xc = dom(ib)%xc(1)
				origin_yc = dom(ib)%yc(1)
				origin_zc = dom(ib)%zc(1) 
				!
				!
				!
			if (qF.eq.1) then
				!
				tetha1 = alpha1 - betha1 
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point will always be forward of marker1
				mrx = mkx + rad1*cosTetha1
				! mry = ???
				! The mirror point may be above marker1 if betha1 > alpha1
				mrz = mkz - rad1*sinTetha1

			elseif(qF.eq.2) then

				tetha1 =   alpha1 - (90 - betha1) 
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point may be behind maker1 if alpha1 < (90 - betha1)
				mrx = mkx + rad1*sinTetha1

				! mry = ???
				
				! The mirror point will alpway be above marker1
				mrz = mkz + rad1*cosTetha1

			elseif(qF.eq.3) then

				tetha1 = betha1 - alpha1
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point will always be behind marker 1
				mrx = mkx - rad1*cosTetha1
				
				! mry = ???
				
				! The mirror point may be above marker 1 if alpha1 > betha1
				mrz = mkz - rad1*sinTetha1

			elseif(qF.eq.4) then

				tetha1 = 90 - betha1 - alpha1
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! mirror point may be behind or forward of marker 1 if alpha1 > (90 - betha1)
				mrx = mkx + rad1*sinTetha1
				
				! mry = ???

				! mirror point will alway be bellow marker 1
				mrz = mkz - rad1*cosTetha1

			endif

			! Inidices of the mirror u cell
			id = int ( ( mrx - origin_xc - margin) /dx_l) + 2 
			!jd = int ( ( mry - origin_yc - margin) /dy_l) + 2
			!if (jd.eq.jjc) then
			!else
			!	write(6,*) "Warning jd is not jjc"
			!endif
			!
			yq = dom(ib)%yc(jjc) ! dom(ib)%yc(jjj)
			!
			kd = int ( ( mrz - origin_zc - margin) /dz_l) + 2
			!
			! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
			ips=dom(ib)%isp; ipe=dom(ib)%iep 
			kps=dom(ib)%ksp; kpe=dom(ib)%kep
			!
			! Checking mirror point  proximity to the subdomain boundaries 
			if((kd-2.ge.kps-3).and.(kd+1.le.kpe+3).and.
     & 		(id-2.ge.ips-3).and.(id+1.le.ipe+3)
     & 		)then
			!			if((kd.gt.kps-3).and.(kd.lt.kpe+3).and.
			!     & 		(id.gt.ips-3).and.(id.lt.ipe+3)
			!     & 		)then
			!
			!
			! lets flag this cell as a body cell
			dom(ib)%mpc(iq,jjc,kq) = qF
			!
			! Lets add the necesary information
			dom(ib)%mpcnn(iq,jjc,kq) = nn  ! nn for p ghost cells
			dom(ib)%mpcib(iq,jjc,kq) = ib  ! ib for p ghost cells
			dom(ib)%mpcll(iq,jjc,kq) = ll  ! ll for p ghost cells
			dom(ib)%mpci(iq, jjc,kq)  = iq  ! %x  id for p ghost cells
			dom(ib)%mpcj(iq, jjc,kq)  = jjc ! %yc id for p ghost cells
			dom(ib)%mpck(iq, jjc,kq)  = kq  ! %z  id for p ghost cells
			dom(ib)%mpcx(iq, jjc,kq)  = xq  ! %x  for p ghost cells
			dom(ib)%mpcy(iq, jjc,kq)  = yq  ! %yc for p ghost cells
			dom(ib)%mpcz(iq, jjc,kq)  = zq  ! %z  for p ghost cells
			dom(ib)%mpcmi(iq,jjc,kq) = id  ! %x  id for p mirror cells
			dom(ib)%mpcmj(iq,jjc,kq) = jjc ! %yc id for p mirror cells
			dom(ib)%mpcmk(iq,jjc,kq) = kd  ! %z  id for p mirror cells
			dom(ib)%mpcmx(iq,jjc,kq) = mrx ! %x  for p mirror cells
			dom(ib)%mpcmy(iq,jjc,kq) = yq  ! %yc for p mirror cells
			dom(ib)%mpcmz(iq,jjc,kq) = mrz ! %z  for p mirror cells
			!
			!
			else
				! debug
				St_k = ibmSt(M) ! number of station of the inmmersed body
				mksPS = ibmStMkrs(M)	! Markers per station
				mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				nnStart = 1 + (int(St_k/2.0d00))*mksPS
				!
				i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
				k_n_cells = dom(ib)%ttc_k
				!
				!
				if(kd-2.lt.kps-3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iic,jjc,kkc,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with kd-2.lt.kps-3",kd,abs(kps-3)
				write(*,*) ib, k_n_cells
				write(*,*) kps,kpe
				endif
				kd = kps - 1
				endif
				if(kd+1.gt.kpe+3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iic,jjc,kkc,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with kd+1.gt.kpe+3",kd,abs(kpe+3)
				write(*,*) ib, k_n_cells
				write(*,*) kps,kpe
				endif
				kd = kps + 2
				endif
				if(id-2.lt.ips-3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iic,jjc,kkc,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with id-2.lt.ips-3 ",id,abs(ips-3)
				write(*,*) ib, i_n_cells
				write(*,*) ips,ipe
				endif
				id = ips  - 1
				endif
				if(id+1.gt.ipe+3)then
				if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				write(*,*) "WARNING BOUNDARY ISSUE"
				write(*,*) nn,iic,jjc,kkc,qF
				write(6,*) id,kd
				write(6,*) mrx,mrz
				write(*,*) "mirror point with id+1.gt.ipe+3 ",id,abs(ipe+3)
				write(*,*) ib, i_n_cells
				write(*,*) ips,ipe
				endif
				id = ips  + 2
				endif
				!
				! lets flag this cell as a body cell
				dom(ib)%mpc(iq,jjc,kq) = qF
				!
				! Lets add the necesary information
				dom(ib)%mpcnn(iq,jjc,kq) = nn  ! nn for p ghost cells
				dom(ib)%mpcib(iq,jjc,kq) = ib  ! ib for p ghost cells
				dom(ib)%mpcll(iq,jjc,kq) = ll  ! ll for p ghost cells
				dom(ib)%mpci(iq, jjc,kq)  = iq  ! %x  id for p ghost cells
				dom(ib)%mpcj(iq, jjc,kq)  = jjc ! %yc id for p ghost cells
				dom(ib)%mpck(iq, jjc,kq)  = kq  ! %z  id for p ghost cells
				dom(ib)%mpcx(iq, jjc,kq)  = xq  ! %x  for p ghost cells
				dom(ib)%mpcy(iq, jjc,kq)  = yq  ! %yc for p ghost cells
				dom(ib)%mpcz(iq, jjc,kq)  = zq  ! %z  for p ghost cells
				dom(ib)%mpcmi(iq,jjc,kq) = id  ! %x  id for p mirror cells
				dom(ib)%mpcmj(iq,jjc,kq) = jjc ! %yc id for p mirror cells
				dom(ib)%mpcmk(iq,jjc,kq) = kd  ! %z  id for p mirror cells
				dom(ib)%mpcmx(iq,jjc,kq) = mrx ! %x  for p mirror cells
				dom(ib)%mpcmy(iq,jjc,kq) = yq  ! %yc for p mirror cells
				dom(ib)%mpcmz(iq,jjc,kq) = mrz ! %z  for p mirror cells
				!
			endif ! flag id, kd for proximity to control volume boundaries
			!
			endif

			!!! END PROCESOR HANDLING SUBDOMAIN IB
			endif

			endif

			CONTAINS


			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_px1, mirror_px2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjc,kd)
			!	ux2 = dom(ib)%u(id+1,jjc,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = pvec(1)	!dom(ib)%u(id,jjc,kd)
			ux2 = pvec(2) 	!dom(ib)%u(id-1,jjc,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_px1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjc,kd-1)
			!ux2 = dom(ib)%u(id+1,jjc,kd-1)

			! Alternative
			ux1 = pvec(3)	!dom(ib)%u(id,jjc,kd-1)
			ux2 = pvec(4)	!dom(ib)%u(id-1,jjc,kd-1)

			mirror_px2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_px1
			uz2 = mirror_px2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)

			!######################################################################
			END FUNCTION l1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################






!######################################################################		
			END SUBROUTINE setMirror_p
!######################################################################	 	

!######################################################################	
			subroutine gauss_seidel_solver(ab,n,x)
!######################################################################	

			integer, intent(in):: n 
			DOUBLE PRECISION,dimension(n,n+1),intent(in):: ab
			DOUBLE PRECISION,dimension(n,n+1):: aib
			DOUBLE PRECISION,intent(out),dimension(n,1)::x
			DOUBLE PRECISION::t1
			DOUBLE PRECISION, dimension(1)::t3	! Matrix diagonal

			integer:: ii,jj,kk

			aib = ab

			! Visual checking
			!print*
			!print*, "Matrix AiB is: "
			!call print_matrix2D(aib,n,n+1)


			loop1 : do ii = 1,n-1	! Sweeping matrix a diagomal

				loop2 : do jj = ii+1,n	! sweeping rows

					t1 = aib(jj,ii)

					loop3 : do kk = ii,n+1	! Sweeping columns

						aib(jj,kk) = aib(jj,kk) - aib(ii,kk)*t1/aib(ii,ii)

						! Visual checking
						!print*
						!print*, "Matrix AiB is: "
						!call print_matrix2D(aib,n,n+1)

					end do loop3
				
					! Visual checking
					!print*
					!print*, "Matrix AiB is: "
					!call print_matrix2D(aib,n,n+1)

				end do loop2 

			end do loop1

			!print*
			!print*, "Matrix AiB is: "
			!call print_matrix2D(aib,n,n+1)


			! Lets compute the solution
			do ii = n, 1, -1

				t3 = matmul(aib(ii,1:n),x) ! this matrix multiplication returns a 1d matrix

				x(ii,1) = ( aib(ii,n+1) - t3(1) ) / aib(ii,ii)

			end do

			!print*
			!print*
			!Print*,"Visual checking"
			!print*
			!print*, "Solution vector x is: "
			!call print_matrix1D(x,n)


!######################################################################	
			end subroutine gauss_seidel_solver
!######################################################################	


!######################################################################
			subroutine slice_f(sl,matrix,n,row,col)
!######################################################################
                
            	! subroutine for extracting a submatrix when calculating matrix determinants

            	implicit none
            	integer,intent(in)::n,row,col
            	DOUBLE PRECISION,dimension(n,n),intent(in)::matrix
            	DOUBLE PRECISION,dimension(n-1,n-1),intent(out)::sl	! submatrix
            	logical,dimension(n,n)::mask ! marker

            	mask = .true.
            	mask(row,:) = .false.
            	mask(:,col) = .false.

            	sl = reshape(pack(matrix,mask),(/n-1,n-1/))
!######################################################################
        	end subroutine slice_f
!######################################################################

			!######################################################################
			Subroutine LUDCMP(A,N,INDX,D,CODE)
			!######################################################################
			!*******************************************************
			!*    LU decomposition routines used by test_lu.f90    *
			!*                                                     *
			!*                 F90 version by J-P Moreau, Paris    *
			!*                        (www.jpmoreau.fr)            *
			!* --------------------------------------------------- *
			!* Reference:                                          *
			!*                                                     *
			!* "Numerical Recipes By W.H. Press, B. P. Flannery,   *
			!*  S.A. Teukolsky and W.T. Vetterling, Cambridge      *
			!*  University Press, 1986" [BIBLI 08].                *
			!*                                                     * 
			!*******************************************************
			! http://jean-pierre.moreau.pagesperso-orange.fr/Fortran/lu_f90.txt
			!  ***************************************************************
			!  * Given an N x N matrix A, this routine replaces it by the LU *
			!  * decomposition of a rowwise permutation of itself. A and N   *
			!  * are input. INDX is an output vector which records the row   *
			!  * permutation effected by the partial pivoting; D is output   *
			!  * as -1 or 1, depending on whether the number of row inter-   *
			!  * changes was even or odd, respectively. This routine is used *
			!  * in combination with LUBKSB to solve linear equations or to  *
			!  * invert a matrix. Return code is 1, if matrix is singular.   *
			!  ***************************************************************
			IMPLICIT NONE

			INTEGER, INTENT(IN):: N
			DOUBLE PRECISION:: A(n,n)
			INTEGER:: NMAX
			DOUBLE PRECISION:: TINY
			DOUBLE PRECISION::  AMAX,DUM, SUM
			DOUBLE PRECISION, ALLOCATABLE:: VV(:)
			INTEGER, INTENT(OUT):: CODE, D, INDX(N)
			INTEGER:: I,J,K, IMAX

			NMAX=100 
			ALLOCATE(VV(NMAX))
			TINY=1.5D-16
			D=1; CODE=0

			DO I=1,N
			AMAX=0.d0
			DO J=1,N
				IF (DABS(A(I,J)).GT.AMAX) AMAX=DABS(A(I,J))
			END DO ! j loop
			IF(AMAX.LT.TINY) THEN
				CODE = 1
				RETURN
			END IF
			VV(I) = 1.d0 / AMAX
			END DO ! i loop

			DO J=1,N
			DO I=1,J-1
				SUM = A(I,J)
				DO K=1,I-1
				SUM = SUM - A(I,K)*A(K,J) 
				END DO ! k loop
				A(I,J) = SUM
			END DO ! i loop
			AMAX = 0.d0
			DO I=J,N
				SUM = A(I,J)
				DO K=1,J-1
				SUM = SUM - A(I,K)*A(K,J) 
				END DO ! k loop
				A(I,J) = SUM
				DUM = VV(I)*DABS(SUM)
				IF(DUM.GE.AMAX) THEN
				IMAX = I
				AMAX = DUM
				END IF
			END DO ! i loop  
			
			IF(J.NE.IMAX) THEN
				DO K=1,N
				DUM = A(IMAX,K)
				A(IMAX,K) = A(J,K)
				A(J,K) = DUM
				END DO ! k loop
				D = -D
				VV(IMAX) = VV(J)
			END IF

			INDX(J) = IMAX
			IF(DABS(A(J,J)) < TINY) A(J,J) = TINY

			IF(J.NE.N) THEN
				DUM = 1.d0 / A(J,J)
				DO I=J+1,N
				A(I,J) = A(I,J)*DUM
				END DO ! i loop
			END IF 
			END DO ! j loop
			! debug
			!write(6,*)
			!write(6,*)
			!do I = 1,n
			!    write(6,*) A(1:n,I)
			!enddo
			!write(6,*)
			!write(6,*)

			END subroutine LUDCMP

			!######################################################################
			Subroutine LUBKSB(A,N,INDX,B)
			!######################################################################
			!*******************************************************
			!*    LU decomposition routines used by test_lu.f90    *
			!*                                                     *
			!*                 F90 version by J-P Moreau, Paris    *
			!*                        (www.jpmoreau.fr)            *
			!* --------------------------------------------------- *
			!* Reference:                                          *
			!*                                                     *
			!* "Numerical Recipes By W.H. Press, B. P. Flannery,   *
			!*  S.A. Teukolsky and W.T. Vetterling, Cambridge      *
			!*  University Press, 1986" [BIBLI 08].                *
			!*                                                     * 
			!*******************************************************
			! http://jean-pierre.moreau.pagesperso-orange.fr/Fortran/lu_f90.txt
			!  ******************************************************************
			!  * Solves the set of N linear equations A . X = B.  Here A is     *
			!  * input, not as the matrix A but rather as its LU decomposition, *
			!  * determined by the routine LUDCMP. INDX is input as the permuta-*
			!  * tion vector returned by LUDCMP. B is input as the right-hand   *
			!  * side vector B, and returns with the solution vector X. A, N and*
			!  * INDX are not modified by this routine and can be used for suc- *
			!  * cessive calls with different right-hand sides. This routine is *
			!  * also efficient for plain matrix inversion.                     *
			!  ******************************************************************
			IMPLICIT NONE

			INTEGER, INTENT(IN):: N
			DOUBLE PRECISION, INTENT(INOUT):: A(N,N),B(N)
			DOUBLE PRECISION::  SUM
			INTEGER:: INDX(N)
			INTEGER:: II,I, J, LL

			II = 0

			DO I=1,N
			LL = INDX(I)
			SUM = B(LL)
			B(LL) = B(I)
			IF(II.NE.0) THEN
				DO J=II,I-1
				SUM = SUM - A(I,J)*B(J)
				END DO ! j loop
			ELSE IF(SUM.NE.0.d0) THEN
				II = I
			END IF
			B(I) = SUM
			END DO ! i loop

			DO I=N,1,-1
			SUM = B(I)
			IF(I < N) THEN
				DO J=I+1,N
				SUM = SUM - A(I,J)*B(J)
				END DO ! j loop
			END IF
			B(I) = SUM / A(I,I)
			END DO ! i loop

			RETURN
			!######################################################################
			END subroutine LUBKSB
			!######################################################################

!######################################################################
            subroutine cramer_solver(x,a,b,n)
!######################################################################
                
	! Subroutine to solve a system of linear equations using Cramer's rule
				
	implicit none
				
	integer, intent(in):: n
	DOUBLE PRECISION,intent(in),dimension(n,n):: a ! a contains n+1 matrices
	DOUBLE PRECISION,intent(in),dimension(n):: b
	DOUBLE PRECISION,intent(out),dimension(n,1):: x	
	DOUBLE PRECISION,dimension(n,n,n+1):: a2 ! a contains n+1 matrices
	DOUBLE PRECISION:: det_a1 ! determinant ofthe 1st matrix, the matrix a that containing coeffcients
	integer:: ii

	! FUNCTION Declaration
	!DOUBLE PRECISION,external::det_f
	det_a1 = det_f(a(:,:),n) ! determinant ofthe 1st matrix, the matrix a that containing coeffcients
	if(det_a1.lt.1.00e-5) then
	!	write(6,*) "Warning: Cramer Determinant close to zero"
	endif

	x = 0.0d00
	loop1: do ii = 1,n
		a2(:,:,ii+1) = a(:,:) ! the (ii+1)th matrix is assigned the 1st matrix, the matrix a that containing coeffcients
		a2(:,ii,ii+1) = b ! we replace with column vector b the column of the current (ii+1)th matrix
	!! we apply crammers rule: we divide the determinat of the (ii+1)th matrix by the determinant of the 1st matrix
		x(ii,1) = det_f(a2(:,:,ii+1),n) / det_a1
		!write(6,*) x
	!! calculating first det_a1 saves time when doing calculation because this way, we do not have to evaluate det_f(a(:,:,1),n) in each iteration
	end do loop1
	!x = 0.0d00



	!!!!!! ++++++++++++++++++++ !!!!!!
	!!!!!! Function Declaration !!!!!!
	!!!!!! ++++++++++++++++++++ !!!!!!

		contains
		recursive DOUBLE PRECISION function det_f(matrix,n) result(det)
		! function for calculating matrix determinants
		implicit none
		integer, intent(in):: n
		DOUBLE PRECISION, intent(in), dimension(n,n):: matrix
		DOUBLE PRECISION, dimension(n-1,n-1):: sl !  submatrix
		integer:: ii
		det = 0
		if (n == 1) then
			det = matrix(1,1)
			return

		else if(n == 2) then
			det = matrix(1,1)*matrix(2,2) - matrix(1,2)*matrix(2,1)
			return
       	else
       	! lets sweep the columns of the matrix
       	do ii = 1,n
       	    call slice_f(sl, matrix,n,1,ii)
       	    det = det + ( (-1.0)**(1+ii) )*matrix(1,ii)*det_f(sl,n-1)
       	end do
       	return
       	end if
	
       	end function det_f

						
!######################################################################
	end subroutine cramer_solver
!######################################################################
 



!######################################################################
	SUBROUTINE pressureProbe(pout)
!######################################################################

	    use imb
	    use vars
	    use mpi
	    use multidata
		
	    implicit none

      DOUBLE PRECISION, INTENT(out):: pout(3)
      INTEGER 	:: M,L
	  
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn,mm,ll, vecID,searchID
	  INTEGER :: iic, jjc, kkc, iicm, jjcm, kkcm
	  ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! mm :
	  ! nn : index for nodes belonging to the M-th mody	  
	  ! 
	  INTEGER :: nnStart, nnFinish
	  
	  INTEGER :: is,ie,js,je,ks,ke
	  INTEGER :: i_n_cells ,j_n_cells,k_n_cells
	  
	  DOUBLE PRECISION :: cnx,cny,cnz ! Marker coordinates, cn
	  DOUBLE PRECISION :: coef1, coef2 ! Coefficients for computing pressure force coefficient
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: pcdx, pcdz ! pcdx(M) pressure force coefficinet on the M-th body
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: px, pz ! px(M) Total pressure applied on the M-th body
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: px2, pz2 ! px(M) Total pressure applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: pcdx2, pcdz2 ! pcdx(M) pressure force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::fxVecSt,fzVecSt ! fxVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::fxVecSt2,fzVecSt2 ! fxVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:,:) ::pxVecMks,pzVecMks ! pxVecMks(M,mm,nn)
	  DOUBLE PRECISION:: fxk, fzk, fxk2, fzk2, pnn(3)
	  DOUBLE PRECISION:: betha1, tanBetha1, cosBetha1, sinBetha1
	  ! fxVecSt: ox pressure component applied on the  mm-th station of the M-th body
	  ! pxVecMks: ox pressure component applied on the n-th pair of markers at the mm-th station of the M-th body
	  ! fxk : pressure force along the ox direction at markers location nds(1)
	  ! fzk : pressure force along the oz direction at markers location nds(2)
	  ! pnn(1) : pressure at markers location nds(1)
	  ! pnn(2) : pressure at markers location nds(2)

	  ! Boundary Margings
	  DOUBLE PRECISION:: dh, margin,dx_l,dy_l,dz_l,swapTemp
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  INTEGER:: layers2Sweep,mksPS
	  INTEGER:: mksEL, St_k, aa, bb
	  INTEGER:: threshold1,step
	  INTEGER:: firstNode, lastNode
	  DOUBLE PRECISION:: cmx, cmz, spam
	  
	  ! ys:  OZ coordinate of the intersection between the face od the pressure cells and the segment linking markers cn and cn2	
	  DOUBLE PRECISION:: origin_xc , origin_yc, origin_zc
	  DOUBLE PRECISION, DIMENSION(3):: ndsx,ndsy,ndsz
	  DOUBLE PRECISION:: ndsl, ndslx, ndsly, ndslz ! Distances between nds(1)) and nds(3)
	  DOUBLE PRECISION:: tempx, tempy, tempz, gamma1 ! Variable for tracking the location of the markers relative to the body centre of gravity
	  INTEGER:: vec1(8), vecm(8)	! Interface vector that stores some input variables for subroutine "get_f"

	  ! Flags
	  INTEGER :: qFlag,flag1, flag2
	  
	  ALLOCATE(pcdx(bodynum), pcdz(bodynum))
	  ALLOCATE(px(bodynum), pz(bodynum) )
	  ALLOCATE(pcdx2(bodynum), pcdz2(bodynum))
	  ALLOCATE(px2(bodynum), pz2(bodynum) )
	  pcdx = 0.0d00; pcdz = 0.0d00
	  px = 0.0d00;	pz = 0.0d00
	  pcdx2 = 0.0d00; pcdz2 = 0.0d00
	  px2 = 0.0d00;	pz2 = 0.0d00
	  if(Ubulk.gt.0.001)then
	  coef1 = 1/(0.5*1*(Ubulk**2)*1*0.6) ! coefficient for comparing drag and lift forces with previous results
	  coef2 = 1/(0.5*1*(Ubulk**2)*1)	   ! coefficient for comparing pressure and shear stress values with previous results
	  else
		coef1 = 1.0d00
		coef2 = 1.0d00
	  endif

	  do M = 1, bodynum	! Sweeping inmersed bodies

	  do ib = 1, nbp ! lets sweep subdomains assigned to the current processor

		!if (myrank.eq.0) then ! The control is passed down to the master processor
	  if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
												  ! markers are located
	   ! lets check if the subdomain has any marker at all
	!   if (imbinblk(ib) .gt. 0 ) then 	! ??? check there may only be 1 maker in the subdomain

			! Bounds for pressure p (NOT INCLUDING GHOST LAYERS)
		is = dom(ib)%isp; ie = dom(ib)%iep
		js = dom(ib)%jsp; je = dom(ib)%jep
		ks = dom(ib)%ksp; ke = dom(ib)%kep
				   
				   ! Including ghost layers:
				   ! is=dom(ib)%isu; ie=dom(ib)%ieu		

	   dx_l = dom(ib)%dx
	   dy_l= dom(ib)%dy
	   dz_l= dom(ib)%dz
	   dh = (dx_l*dy_l*dz_l)**(1.0D00/3)
	   margin = 1.0e-9	!1.0e-5	! Margin for searching if arkers are within the boundaries of a cell

	   origin_xc = dom(ib)%xc(1)
	   origin_yc = dom(ib)%yc(1)
	   origin_zc = dom(ib)%zc(1)
	   
	   ! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
	   is=dom(ib)%isu; ie=dom(ib)%ieu
	   js=dom(ib)%jsu; je=dom(ib)%jeu
	   ks=dom(ib)%ksu; ke=dom(ib)%keu
	   
	   i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
	   j_n_cells = dom(ib)%ttc_j
	   k_n_cells = dom(ib)%ttc_k


	   St_k = ibmSt(bodynum)
	   ! allocate(ibmSt(bodynum)) 
	   ! ibmSt : ofr each postion, it stores the number of stations defined in each body
	   ! ibmSt_k = 0	! counter of the total number of stations
	   ! do ii = 1, bodynum
	   ! 	ibmSt_k = ibmSt_k + ibmSt(ii)
	   ! enddo
	   ! allocate(ibmStMkrs(ibmSt_k)) ! for each postion jj, it stores the number of markers in station jj
	   ! ibmStMkrs( (M-1)*ibmSt(M-1) + M*k ) : number of markers at station k for body M
	   ! 
	   ! ibmStMkrs
	   mksPS = ibmStMkrs(ibmSt_k)
	   
	   
	   ! St_k = 0	! counter of the total number of stations
	   ! do ii = 1, bodynum
	   ! 	ibmSt_k = ibmSt_k + ibmSt(ii)
	   ! enddo
	   ! allocate(ibmMkrsEL(ibmSt_k)) ! for each postion jj, it stores the number of markers in the exterior layer in station jj
	   ! ibmMkrsEL( (M-1)*ibmSt(M-1) + M*k ) : number of markers at exterior layer in station k for body M
	   ! 
	   ! ibmMkrsEL
	   mksEL = ibmMkrsEL(ibmSt_k)


	   ALLOCATE(fxVecSt(bodynum,St_k))
	   ALLOCATE(fzVecSt(bodynum,St_k))
	   ALLOCATE(fxVecSt2(bodynum,St_k))
	   ALLOCATE(fzVecSt2(bodynum,St_k))
	   fxVecSt = 0.0d00; fzVecSt = 0.0d00
	   fxVecSt2 = 0.0d00; fzVecSt2 = 0.0d00


	   lastNode = mksEL + (St_k-1)*mksPS
	   firstNode = 1 + (1-1)*mksPS
	   do mm = 1, St_k	! sweeping stations

	   !layers2Sweep = 20
	   
	   nnFinish = mksEL + (mm-1)*mksPS
	   nnStart = 1 + (mm-1)*mksPS

	   ! Initializing pressure pnn on the link connecting nds1 and nds2
	   fxk = 0.0d00; fzk = 0.0d00
	   fxk2 = 0.0d00; fzk2 = 0.0d00
	   pnn(1) = 0.0d00; pnn(2) = 0.0d00
	   pnn(3) = 0.0d00

	   ! Lets optain pressure at node nds1
	   ll = 1
	   ! Extracting marker coordinates
	   ndsx(1) = nodex_loc(nnStart) 
	   ndsy(1) = nodey_loc(nnStart) 
	   ndsz(1) = nodez_loc(nnStart)
	   !
	   iic = int ( ( ndsx(1) - origin_xc - margin) /dx_l) + 2 
	   jjc = int ( ( ndsy(1) - origin_yc - margin) /dy_l) + 2
	   kkc = int ( ( ndsz(1) - origin_zc - margin) /dz_l) + 2
	   ! Check for not modifying the ghost layer beyoud the boundaries of the control volume
	   if (jjc .lt. js) then
		   jjc = js
	   endif
	   if (jjc .gt. je) then
		   jjc = je
	   endif
	   !
	   vec1(1) = nnStart	! Node nds1
	   vec1(2) = ib 
	   vec1(3) = ll
	   vec1(4) = iic 
	   vec1(5) = jjc 
	   vec1(6) = kkc 
	   vec1(8) = 4
	   !
	   call get_f(vec1,ndsx(1),ndsz(1),pnn(1))


	   !do nn = 1, maxnodeIBS	! sweeping markers
	   do nn = 1+(mm-1)*mksPS, mm*mksPS	!  sweeping markers of each station

		IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???

		   if( ( nn.ge.nnStart).and.(nn.le.nnFinish) ) then ! Filtering interior layers

		    	! Extracting marker coordinates
		    		ndsx(1) = nodex_loc(nn) 
		    		ndsy(1) = nodey_loc(nn) 
		    		ndsz(1) = nodez_loc(nn)
		    	! Extrancting coordinates of the neighbouring markers from the same layer
		    	if ( nn .eq. nnFinish) then
		    		! Coordinates of the next markers, cn2
		    		ndsx(2) = nodex_loc(nnStart)
		    		ndsy(2) = nodey_loc(nnStart)
		    		ndsz(2) = nodez_loc(nnStart)
		    	else
		    		! Coordinates of the next markers, cn2
		    		ndsx(2) = nodex_loc(nn+1)
		    		ndsy(2) = nodey_loc(nn+1)
		    		ndsz(2) = nodez_loc(nn+1)
		    	endif
		    		! Coordinates of the previous marker, cn3
		    	ndsx(3) = 0.5*(ndsx(1) + ndsx(2))
		    	ndsy(3) = 0.5*(ndsy(1) + ndsy(2))
		    	ndsz(3) = 0.5*(ndsz(1) + ndsz(2))
		    	!
		    	iic = int ( ( ndsx(2) - origin_xc - margin) /dx_l) + 2 
		    	jjc = int ( ( ndsy(2) - origin_yc - margin) /dy_l) + 2
		    	kkc = int ( ( ndsz(2) - origin_zc - margin) /dz_l) + 2
		    	!
		    	iicm = int ( ( ndsx(3) - origin_xc - margin) /dx_l) + 2 
		    	jjcm = int ( ( ndsy(3) - origin_yc - margin) /dy_l) + 2
		    	kkcm = int ( ( ndsz(3) - origin_zc - margin) /dz_l) + 2
		    	! Check for not modifying the ghost layer beyoud the boundaries of the control volume
		    	if (jjc .lt. js) then
		    		jjc = js
		    	endif
		    	if (jjc .gt. je) then
		    		jjc = je
		    	endif
                        if (dom(ib)%yc(jjc) .gt. 1.0d00) then
                                cycle
                        endif			!
				if( (kkc.gt.3).or.(kkcm.gt.3) )then ! kkk flag
		    	!
		    	vec1(1) = nn+1	! Node nds(2)
		    	vec1(2) = ib 
		    	vec1(3) = ll
		    	vec1(4) = iic 
		    	vec1(5) = jjc 
		    	vec1(6) = kkc
		    	vec1(8) = 4
		    	!
		    	vecm(1) = nn+1	! Node nds(1.5)
		    	vecm(2) = ib 
		    	vecm(3) = ll
		    	vecm(4) = iicm 
		    	vecm(5) = jjcm
		    	vecm(6) = kkcm
		    	vecm(8) = 4
		    	!
		    	ndslx = (ndsx(1) - ndsx(2))**2
		    	ndsly = (ndsy(1) - ndsy(2))**2
		    	ndslz = (ndsz(1) - ndsz(2))**2
		    	ndsl = sqrt(ndslx+ndsly+ndslz)
		    	!
		    	! ( 0, 90 ] First quadrant?
		    	if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
		    	if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
		    		vec1(7) = 1! qFlag = 1
		    		call get_f(vec1,ndsx(2),ndsz(2),pnn(2))
		    		call get_f(vecm,ndsx(3),ndsz(3),pnn(3))
		    tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
		    betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets obtain betha1
		    		cosBetha1 = DCOS(betha1*piNUm/180)
		    		sinBetha1 = DSIN(betha1*piNUm/180)
		    		fxk = 0.5*(pnn(1)+pnn(2))
		    		fxk = - fxk*ndsl*dy_l*sinBetha1
		    		!
		    		fxk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fxk2 = - fxk2*ndsl*dy_l*sinBetha1
		    		!
		    		fzk = 0.5*(pnn(1)+pnn(2))
		    		fzk = + fzk*ndsl*dy_l*cosBetha1
		    		!
		    		fzk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fzk2 = + fzk2*ndsl*dy_l*cosBetha1
		    	endif
		    	endif
		    	! ( 90, 180 ] 2nd quadrant?
		    	if ( (ndsx(2) - ndsx(1)) .le. -margin) then
		    	if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
		    		vec1(7) = 2	!qFlag = 2
		    		call get_f(vecm,ndsx(3),ndsz(3),pnn(3))
		    		call get_f(vec1,ndsx(2),ndsz(2),pnn(2))
		    tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
		    betha1 = abs(DATAN(tanBetha1))*180/piNUm	
		    		cosBetha1 = DCOS(betha1*piNUm/180)
		    		sinBetha1 = DSIN(betha1*piNUm/180)
		    		fxk = 0.5*(pnn(1)+pnn(2))
		    		fxk = - fxk*ndsl*dy_l*sinBetha1
		    		!
		    		fxk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fxk2 = - fxk2*ndsl*dy_l*sinBetha1
		    		!
		    		fzk = 0.5*(pnn(1)+pnn(2))
		    		fzk = - fzk*ndsl*dy_l*cosBetha1
		    		!
		    		fzk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fzk2 = - fzk2*ndsl*dy_l*cosBetha1
		    	endif
		    	endif
		    	! ( 180, 270 ] 3rd quadrant?
		    	if ( (ndsx(2) - ndsx(1)) .le. margin) then
		    	if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
		    		vec1(7) = 3	!qFlag = 3
		    		call get_f(vecm,ndsx(3),ndsz(3),pnn(3))
		    		call get_f(vec1,ndsx(2),ndsz(2),pnn(2))
		    tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
		    betha1 = abs(DATAN(tanBetha1))*180/piNUm
		    		cosBetha1 = DCOS(betha1*piNUm/180)
		    		sinBetha1 = DSIN(betha1*piNUm/180)
		    		fxk = 0.5*(pnn(1)+pnn(2))
		    		fxk = fxk*ndsl*dy_l*sinBetha1
		    		!
		    		fxk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fxk2 = fxk2*ndsl*dy_l*sinBetha1
		    		!
		    		fzk = 0.5*(pnn(1)+pnn(2))
		    		fzk = - fzk*ndsl*dy_l*cosBetha1
		    		!
		    		fzk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fzk2 = - fzk2*ndsl*dy_l*cosBetha1
		    	endif
		    	endif
		    	! ( 270, 360 ] 4th quadrant?
		    	if ( (ndsx(2) - ndsx(1)) .gt. margin) then
		    	if ( (ndsz(2) - ndsz(1)) .le. margin) then
		    		vec1(7) = 4	!qFlag = 4
		    		call get_f(vecm,ndsx(3),ndsz(3),pnn(3))
		    		call get_f(vec1,ndsx(2),ndsz(2),pnn(2))
		    tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
		    betha1 = abs(DATAN(tanBetha1))*180/piNUm
		    		cosBetha1 = DCOS(betha1*piNUm/180)
		    		sinBetha1 = DSIN(betha1*piNUm/180)
		    		fxk = 0.5*(pnn(1)+pnn(2))
		    		fxk = fxk*ndsl*dy_l*sinBetha1
		    		!
		    		fxk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fxk2 = fxk2*ndsl*dy_l*sinBetha1
		    		!
		    		fzk = 0.5*(pnn(1)+pnn(2))
		    		fzk = fzk*ndsl*dy_l*cosBetha1
		    		!
		    		fzk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fzk2 = fzk2*ndsl*dy_l*cosBetha1
		    	endif
		    	endif
				!
				bb = mksEL + (int(St_k/2.0d00))*mksPS
				aa = 1 + (int(St_k/2.0d00))*mksPS
				if( (nn.ge.aa).and.(nn.le.bb) ) then
     			!if((nn.gt.9240).and.(nn.lt.10561)) then
     				tempx = (ndsx(1) - 18.0d00)
     				tempz = (ndsz(1) - 10.5d00)
     				if (vec1(7).eq.3) then
     		gamma1 = - DATAN(tempz/tempx)*180/piNUm
     				elseif (vec1(7).eq.2) then
     		gamma1 = 180 - DATAN(tempz/tempx)*180/piNUm
     				elseif (vec1(7).eq.4) then
     		gamma1 = - DATAN(tempz/tempx)*180/piNUm
     				elseif (vec1(7).eq.1) then
     		gamma1 = -180 - DATAN(tempz/tempx)*180/piNUm
     				endif
	        		write(6,*) nn, gamma1, pnn(1)*coef2
			 !				write(6,*) pnn*coef2
     			!	write(6,*) dom(ib)%u(iic, jjc, kkc), fxk, fzk
     			!	write(6,*) dom(ib)%w(iic, jjc, kkc), fxk2, fzk2
     			endif
     			!
     	!			if(nn.eq.15) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!	write(6,*) dom(ib)%u(iic, jjc, kkc), fxk, fzk
     	!	write(6,*) dom(ib)%w(iic, jjc, kkc), fxk2, fzk2
     	!			endif
     	!			if(nn.eq.45) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!	write(6,*) dom(ib)%u(iic-1, jjc, kkc), fxk, fzk
     	!	write(6,*) dom(ib)%w(iic-1, jjc, kkc), fxk2, fzk2
     	!				endif
     	!			if(nn.eq.62) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!	write(6,*) dom(ib)%u(iic-1, jjc, kkc), fxk, fzk
     	!	write(6,*) dom(ib)%w(iic-1, jjc, kkc), fxk2, fzk2
     	!			endif
     	!			if(nn.eq.77) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!write(6,*) dom(ib)%u(iic-1, jjc, kkc-1), fxk, fzk
     	!write(6,*) dom(ib)%w(iic-1, jjc, kkc-1), fxk2, fzk2
     	!			endif
     	!			if(nn.eq.105) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!write(6,*) dom(ib)%u(iic, jjc, kkc-1), fxk, fzk
     	!write(6,*) dom(ib)%w(iic, jjc, kkc-1), fxk2, fzk2
     	!			endif
     	!			if(nn.eq.126) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!	write(6,*) dom(ib)%u(iic, jjc, kkc), fxk, fzk
     	!	write(6,*) dom(ib)%w(iic, jjc, kkc), fxk2, fzk2
     	!			endif
					!
					if ( (mm.eq.1).or.(mm.eq.St_k ) )then
						fxVecSt(M,mm) = 0.5*fxVecSt(M,mm)
						fxVecSt2(M,mm) = 0.5*fxVecSt2(M,mm)
						fzVecSt(M,mm)  = 0.5*fzVecSt(M,mm)
						fzVecSt2(M,mm) = 0.5*fzVecSt2(M,mm)
						!write(6,*) mm, fxVecSt(M,mm), fxVecSt2(M,mm)
					endif
                    ! check !!!
                    fxVecSt(M,mm) = fxVecSt(M,mm) + fxk 
                    fzVecSt(M,mm) = fzVecSt(M,mm) + fzk
                    fxVecSt2(M,mm) = fxVecSt2(M,mm) + fxk2 
                    fzVecSt2(M,mm) = fzVecSt2(M,mm) + fzk2
					!
					! Update of pnn(1)
                    pnn(1) = pnn(2)
	       else
			  ll = 2
	        endif! Filtering interior layers

		 endif	! Ensuring processor ID matches subdomain ID???
		endif	! kkk flag
		enddo	!  sweeping markers of each station
                    !
		px(M) = px(M) + fxVecSt(M,mm)
		pz(M) = pz(M) + fzVecSt(M,mm)
		px2(M) = px2(M) + fxVecSt2(M,mm)
		pz2(M) = pz2(M) + fzVecSt2(M,mm)
		!

		enddo	! sweeping stations

		DEALLOCATE(fxVecSt,fzVecSt)
		DEALLOCATE(fxVecSt2,fzVecSt2)

		spam = nodey_loc(lastNode) - nodey_loc(firstNode)
		coef1 = 1/(0.5*1*(Ubulk**2)*1*spam)
	    !p1(1) = px2(M)
	    !p1(2) = 0.0d0
		!p1(3) = pz2(M)
	    pout(1) = px2(M)
	    pout(2) = 0.0d0
	    pout(3) = pz2(M)
	    pcdx(M) = coef1*px(M) 
	    pcdz(M) = coef1*pz(M)
	    pcdx2(M) = coef1*px2(M) 
	    pcdz2(M) = coef1*pz2(M)
	    write(6,*) "px", px(M), px2(M)
	    write(6,*) "pcdx", pcdx(M), pcdx2(M)
	    write(6,*) "pz", pz(M), pz2(M)
	    write(6,*) "pcdz", pcdz(M), pcdz2(M)

	  endif ! Filtering out procesors

	  enddo ! End of the  loop sweeping the domains
		!
		!
	    enddo ! end of the loop sweeping the bodies
		!
		!
	    DEALLOCATE(pcdx, pcdz)
	    DEALLOCATE(px, pz )
	    DEALLOCATE(pcdx2, pcdz2)
	    DEALLOCATE(px2, pz2 )

!######################################################################		
	END SUBROUTINE pressureProbe
!######################################################################	 

!######################################################################
	SUBROUTINE shearStressProbe(shout)
!######################################################################

		use vars
		use imb
		use mpi
	    use multidata
		
		implicit none
		
      DOUBLE PRECISION, INTENT(out):: shout(3)

      INTEGER 	:: M,L
	  
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn,mm,ll, vecID,searchID
	  INTEGER :: iic, jjc, kkc, iicm, jjcm, kkcm,iiim,jjjm,kkkm

      ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! mm :
	  ! nn : index for nodes belonging to the M-th mody	  
	  ! 
	  INTEGER :: nnStart, nnFinish
	  
	  INTEGER :: is,ie,js,je,ks,ke
	  INTEGER :: i_n_cells ,j_n_cells,k_n_cells
	  
	  DOUBLE PRECISION :: cnx,cny,cnz ! Marker coordinates, cn
	  DOUBLE PRECISION :: coef1, coef2 ! Coefficients for computing shear stress force coefficient
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx, tz ! tx(M) Total shear stress applied on the M-th body
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx2, tz2 ! tx(M) Total shear stress applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx3, tz3 ! tx(M) Total shear stress applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx4, tz4 ! tx(M) Total shear stress applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx5, tz5 ! tx(M) Total shear stress applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx6, tz6 ! tx(M) Total shear stress applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx, tcdz ! tcdx(M) shear stress force coefficinet on the M-th body
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx2, tcdz2 ! tcdx(M) shear stress force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx3, tcdz3 ! tcdx(M) shear stress force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx4, tcdz4 ! tcdx(M) shear stress force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx5, tcdz5 ! tcdx(M) shear stress force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx6, tcdz6 ! tcdx(M) shear stress force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt,tzVecSt ! txVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt2,tzVecSt2 ! txVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt3,tzVecSt3 ! txVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt4,tzVecSt4 ! txVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt5,tzVecSt5 ! txVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt6,tzVecSt6 ! txVecSt(M,mm)
	  DOUBLE PRECISION:: txk, tzk, txk2, tzk2
	  DOUBLE PRECISION:: txk3, tzk3, txk4, tzk4
	  DOUBLE PRECISION:: tfx_t, tfz_t, tfx_s, tfz_s
	  ! txVecSt: ox shear stress component applied on the  mm-th station of the M-th body
	  ! txVecMks: ox shear stress component applied on the n-th pair of markers at the mm-th station of the M-th body
	  ! txk : shear stress force along the ox direction at markers location nds(1)
	  ! tzk : shear stress force along the oz direction at markers location nds(2)
	  DOUBLE PRECISION:: tempx, tempz, gamma1
	  !
      ! shear stress calculation varaibles
	  DOUBLE PRECISION:: unn(3), vnn(3), wnn(3)
	  ! unn(1) : u velocity value at markers location nds(1)
	  ! unn(2) : u velocity value at markers location nds(2)
	  DOUBLE PRECISION:: dudn(3),dwdn(3),musgs(3),tao(3)
	  DOUBLE PRECISION:: du_dz(3),du_dx(3),dw_dz(3),dw_dx(3)
	  DOUBLE PRECISION:: dudn2(3),dwdn2(3),tao2(3)
	  DOUBLE PRECISION:: tao_x_3(3),tao_z_3(3),tao_3(3)
	  DOUBLE PRECISION:: yplus,mkx1,mkz1,mkx2,mkz2,mkx3,mkz3
	  DOUBLE PRECISION:: betha1, tanBetha1, sinBetha1, cosBetha1
	  DOUBLE PRECISION:: betha2, tanBetha2, sinBetha2, cosBetha2
	  DOUBLE PRECISION:: betha3, tanBetha3, sinBetha3, cosBetha3
	  DOUBLE PRECISION:: betha4, tanBetha4, sinBetha4, cosBetha4
	  DOUBLE PRECISION:: factor2,v1(3),v2(3),v2m(3)
	  ! v1, v2 : auxiliary vectors for doing a dot porduct
	  !
	  ! Boundary Margings
	  DOUBLE PRECISION:: dh, margin,dx_l,dy_l,dz_l,swapTemp
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  INTEGER:: layers2Sweep,mksPS
	  INTEGER:: mksEL, St_k, aa, bb
	  INTEGER:: threshold1,step
	  INTEGER:: firstNode, lastNode
	  DOUBLE PRECISION:: cmx, cmz, spam
	  !
	  ! ys:  OZ coordinate of the intersection between the face od the shear stress cells and the segment linking markers cn and cn2	
      DOUBLE PRECISION:: origin_xc , origin_yc, origin_zc
	  DOUBLE PRECISION:: origin_x  , origin_y, origin_z
	  DOUBLE PRECISION, DIMENSION(3):: ndsx,ndsy,ndsz
	  DOUBLE PRECISION:: ndsl, ndslx, ndsly, ndslz ! Distances between nds(1)) and nds(3)
	  INTEGER:: vec1(8), vecm(8), vec2(8), vecm2(8)	! Interface vector that stores some input variables for subroutine "get_f"
	  INTEGER:: vec13(8), vec13m(8), vec11(8), vec11m(8)	
	  INTEGER:: vec33(8), vec33m(8), vec31(8), vec31m(8)	
	  !
	  ! Flags
	  INTEGER :: qFlag,flag1, flag2, flagWrite
	  
	!  if (myrank.eq. master ) then ! The control is passed down to the master processor
	  	flagWrite = 0
	  	IF ((mod(itime,n_out).eq.0).and.(itime.ge.itime_start)) then
			flagWrite = 1
		! Lets print to file for debugging
		! CSV format
87      format(1x, *(g0, " ")) 
        OPEN(unit = 93, access = "sequential", action = "write",
     &   status = "replace", file = "tao1.txt", form = "formatted")
	  	endif
		
		ALLOCATE(tcdx(bodynum), tcdz(bodynum))
		ALLOCATE(tx(bodynum), tz(bodynum) )
		ALLOCATE(tcdx2(bodynum), tcdz2(bodynum))
		ALLOCATE(tx2(bodynum), tz2(bodynum) )
		ALLOCATE(tcdx3(bodynum), tcdz3(bodynum))
		ALLOCATE(tx3(bodynum), tz3(bodynum) )
		ALLOCATE(tcdx4(bodynum), tcdz4(bodynum))
		ALLOCATE(tx4(bodynum), tz4(bodynum) )
		ALLOCATE(tcdx5(bodynum), tcdz5(bodynum))
		ALLOCATE(tx5(bodynum), tz5(bodynum) )
		ALLOCATE(tcdx6(bodynum), tcdz6(bodynum))
		ALLOCATE(tx6(bodynum), tz6(bodynum) )
		tx = 0.0d00;	tz = 0.0d00
		tx2 = 0.0d00;	tz2 = 0.0d00
		tx3 = 0.0d00;	tz3 = 0.0d00
		tx4 = 0.0d00;	tz4 = 0.0d00
		tx5 = 0.0d00;	tz5 = 0.0d00
		tx6 = 0.0d00;	tz6 = 0.0d00
		tcdx = 0.0d00; tcdz = 0.0d00
		tcdx2 = 0.0d00; tcdz2 = 0.0d00
		tcdx3 = 0.0d00; tcdz3 = 0.0d00
		tcdx4 = 0.0d00; tcdz4 = 0.0d00
		tcdx5 = 0.0d00; tcdz5 = 0.0d00
		tcdx6 = 0.0d00; tcdz6 = 0.0d00

		if(Ubulk.gt.0.001d00)then
		coef1 = 1/(0.5*1*(Ubulk**2)*1*0.3)
		coef2 = 1/(0.5*1*(Ubulk**2)*1)
		else
			coef1 = 1.0d00
			coef2 = 1.0d00
		endif

	    do M = 1, bodynum	! Sweeping inmersed bodies

		   do ib = 1, nbp ! lets sweep subdomains assigned to the current processor
	  
			  !if (myrank.eq.0) then ! The control is passed down to the master processor
		    if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
														! markers are located
			 ! lets check if the subdomain has any marker at all
		     !if (imbinblk(ib) .gt. 0 ) then 	! ??? check there may only be 1 maker in the subdomain
	  
				  ! Bounds for pressure p (NOT INCLUDING GHOST LAYERS)
			  is = dom(ib)%isp; ie = dom(ib)%iep
			  js = dom(ib)%jsp; je = dom(ib)%jep
			  ks = dom(ib)%ksp; ke = dom(ib)%kep
			  !   
				   ! Including ghost layers:
				   ! is=dom(ib)%isu; ie=dom(ib)%ieu		
			  !
			  dx_l = dom(ib)%dx
			  dy_l= dom(ib)%dy
			  dz_l= dom(ib)%dz
			  dh = (dx_l*dy_l*dz_l)**(1.0D00/3)
			  margin = 1.0e-9	!1.0e-5	! Margin for searching if arkers are within the boundaries of a cell
			  !
			  origin_xc = dom(ib)%xc(1)
			  origin_yc = dom(ib)%yc(1)
			  origin_zc = dom(ib)%zc(1)
			  !
			  ! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
			  is=dom(ib)%isu; ie=dom(ib)%ieu
			  js=dom(ib)%jsu; je=dom(ib)%jeu
			  ks=dom(ib)%ksu; ke=dom(ib)%keu
			  !
			  i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
			  j_n_cells = dom(ib)%ttc_j
			  k_n_cells = dom(ib)%ttc_k
			  !
			  St_k = ibmSt(bodynum)
			  ! allocate(ibmSt(bodynum)) 
			  ! ibmSt : ofr each postion, it stores the number of stations defined in each body
			  ! St_k = 0	! counter of the total number of stations
			  ! do ii = 1, bodynum
			  ! 	St_k = St_k + ibmSt(ii)
			  ! enddo
			  ! allocate(ibmStMkrs(St_k)) ! for each postion jj, it stores the number of markers in station jj
			  ! ibmStMkrs( (M-1)*ibmSt(M-1) + M*k ) : number of markers at station k for body M
			  ! 
			  ! ibmStMkrs
			  mksPS = ibmStMkrs(ibmSt_k)
			  !
			  ! St_k = 0	! counter of the total number of stations
			  ! do ii = 1, bodynum
			  ! 	St_k = St_k + ibmSt(ii)
			  ! enddo
			  ! allocate(ibmMkrsEL(St_k)) ! for each postion jj, it stores the number of markers in the exterior layer in station jj
			  ! ibmMkrsEL( (M-1)*ibmSt(M-1) + M*k ) : number of markers at exterior layer in station k for body M
			  ! 
			  ! ibmMkrsEL
			  mksEL = ibmMkrsEL(ibmSt_k)
			  !
			  !
			  ! Lets update the fluid velocity derivatives
			  call du_dv_dw_dh_WENO(ib)
			  !
			  !
			  ! lets check if the subdomain has any marker at all
			  !if (imbinblk(ib) .gt. 0 ) then 	! ??? check there may only be 1 maker in the subdomain
			  !
			  dx_l = dom(ib)%dx ! 
			  dy_l= dom(ib)%dy
			  dz_l= dom(ib)%dz
			  dh = (dx_l*dy_l*dz_l)**(1.0D00/3)
			  yplus = 1.0d00*dh
			  margin = 1.0e-9	!1.0e-5	! Margin for searching if markers are within the boundaries of a cell
			  !
			  origin_xc = dom(ib)%xc(1)
			  origin_yc = dom(ib)%yc(1)
			  origin_zc = dom(ib)%zc(1)
			  !
			  origin_x = dom(ib)%x(1)
			  origin_y = dom(ib)%y(1)
			  origin_z = dom(ib)%z(1)
			  !
			  !
			  ! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
			  is=dom(ib)%isu; ie=dom(ib)%ieu
			  js=dom(ib)%jsu; je=dom(ib)%jeu
			  ks=dom(ib)%ksu; ke=dom(ib)%keu
			  ! Including ghost layers:
			  ! is=dom(ib)%isu; ie=dom(ib)%ieu
			  !
			  i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
			  j_n_cells = dom(ib)%ttc_j
			  k_n_cells = dom(ib)%ttc_k
			  !
			  ALLOCATE(txVecSt(bodynum, St_k))
			  ALLOCATE(tzVecSt(bodynum, St_k))
			  ALLOCATE(txVecSt2(bodynum,St_k))
			  ALLOCATE(tzVecSt2(bodynum,St_k))
			  ALLOCATE(txVecSt3(bodynum,St_k))
			  ALLOCATE(tzVecSt3(bodynum,St_k))
			  ALLOCATE(txVecSt4(bodynum,St_k))
			  ALLOCATE(tzVecSt4(bodynum,St_k))
			  ALLOCATE(txVecSt5(bodynum,St_k))
			  ALLOCATE(tzVecSt5(bodynum,St_k))
			  ALLOCATE(txVecSt6(bodynum,St_k))
			  ALLOCATE(tzVecSt6(bodynum,St_k))
			  txVecSt = 0.0d00; tzVecSt = 0.0d00
			  txVecSt2 = 0.0d00; tzVecSt2 = 0.0d00
			  txVecSt3 = 0.0d00; tzVecSt3 = 0.0d00
			  txVecSt4 = 0.0d00; tzVecSt4 = 0.0d00
			  txVecSt5 = 0.0d00; tzVecSt5 = 0.0d00
			  txVecSt6 = 0.0d00; tzVecSt6 = 0.0d00
			  !
			  !
			  !
			  lastNode = mksEL + (St_k-1)*mksPS
			  firstNode = 1 + (1-1)*mksPS
			  do mm = 1, St_k	! sweeping stations
				!
				!layers2Sweep = 20
				!
			    nnFinish = mksEL + (mm-1)*mksPS
			    nnStart = 1 + (mm-1)*mksPS
			    !
			    ! Initializing shear stress unn on the link connecting nds1 and nds2
			    txk = 0.0d00; tzk = 0.0d00
			    txk2 = 0.0d00; tzk2 = 0.0d00
			    txk3 = 0.0d00; tzk3 = 0.0d00
			    txk4 = 0.0d00; tzk4 = 0.0d00
			    tfx_t = 0.0d00; tfz_t = 0.0d00
			    tfx_s = 0.0d00; tfz_s = 0.0d00
			    !
			    !
			    unn(1) = 0.0d00; unn(2) = 0.0d00
			    unn(3) = 0.0d00
			    !
			    wnn(1) = 0.0d00; wnn(2) = 0.0d00
			    wnn(3) = 0.0d00
			    !
			    !
			    du_dz(1) = 0.0d00; du_dz(2) = 0.0d00
			    du_dz(3) = 0.0d00
			    !
			    du_dx(1) = 0.0d00; du_dx(2) = 0.0d00
			    du_dx(3) = 0.0d00
			    !
			    dw_dz(1) = 0.0d00; dw_dz(2) = 0.0d00
			    dw_dz(3) = 0.0d00
			    !
			    dw_dx(1) = 0.0d00; dw_dx(2) = 0.0d00
			    dw_dx(3) = 0.0d00
			    !
			    !
			    tao(1) = 0.0d00; tao(2) = 0.0d00
			    tao(3) = 0.0d00
			    tao2(1) = 0.0d00; tao2(2) = 0.0d00
			    tao2(3) = 0.0d00
				!
				! Lets optain pressure at node nds1
			    ll = 1
				!
    			! Lets optain shear stress at node nds1
    			!
    			! Extracting first couple of marker coordinates
    			ndsx(1) = nodex_loc(nnStart) 
    			ndsy(1) = nodey_loc(nnStart) 
    			ndsz(1) = nodez_loc(nnStart)
    			ndsx(2) = nodex_loc(nnStart+1) 
    			ndsy(2) = nodey_loc(nnStart+1) 
    			ndsz(2) = nodez_loc(nnStart+1)
    	tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
    			betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets obtain betha1
    			cosBetha1 = DCOS(betha1*piNUm/180)
    			sinBetha1 = DSIN(betha1*piNUm/180)
    			!
    			! ( 0, 90 ] First quadrant?
    			if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
    			if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
    				vec1(7) = 1
    				mkx1 = ndsx(1) + yplus*sinBetha1
    				mkz1 = ndsz(1) - yplus*cosBetha1
    			endif
    			endif
    			! ( 90, 180 ] 2nd quadrant?
    			if ( (ndsx(2) - ndsx(1)) .le. -margin) then
    			if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
    				vec1(7) = 2
    				mkx1 = ndsx(1) + yplus*sinBetha1
    				mkz1 = ndsz(1) + yplus*cosBetha1
    			endif
    			endif
    			! ( 180, 270 ] 3rd quadrant?
    			if ( (ndsx(2) - ndsx(1)) .le. margin) then
    			if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
    				vec1(7) = 3
    				mkx1 = ndsx(1) - yplus*sinBetha1
    				mkz1 = ndsz(1) + yplus*cosBetha1
    			endif
    			endif
    			! ( 270, 360 ] 4th quadrant?
    			if ( (ndsx(2) - ndsx(1)) .gt. margin) then
    			if ( (ndsz(2) - ndsz(1)) .le. margin) then
    				vec1(7) = 4
    				mkx1 = ndsx(1) - yplus*sinBetha1
    				mkz1 = ndsz(1) - yplus*cosBetha1
    			endif
    			endif
    			!
    			iic = int ( ( ndsx(1) - origin_xc - margin) /dx_l) + 2 
    			jjc = int ( ( ndsy(1) - origin_yc - margin) /dy_l) + 2
    			kkc = int ( ( ndsz(1) - origin_zc - margin) /dz_l) + 2
    			!
    			iii = int ( ( ndsx(1) - origin_x - margin) /dx_l) + 2 
    			jjj = int ( ( ndsy(1) - origin_y - margin) /dy_l) + 2
    			kkk = int ( ( ndsz(1) - origin_z - margin) /dz_l) + 2
    			!
    			! Check for not modifying the ghost layer beyoud the boundaries of the control volume
    			if (jjc .lt. js) then
    				jjc = js
    			endif
    			if (jjc .gt. je) then
    				jjc = je
    			endif
                        if (dom(ib)%yc(jjc) .gt. 1.0d00) then
                                cycle
                        endif   
    			!
    			! lets obtain velocity component u at local node 1, unn(1)
    			vec1(1) = nnStart	! Node nds1
    			vec1(2) = ib 
    			vec1(3) = ll
    			vec1(4) = iii
    			vec1(5) = jjc
    			vec1(6) = kkc
    			!
    			vec1(8) = 1 ! lets ge u values
    			call get_f(vec1,mkx1,mkz1,unn(1))
    			!
    			! lets obtain velocity component w at local node 1, wnn(1)
    			vec2(1) = nnStart	! Node nds1
    			vec2(2) = ib 
    			vec2(3) = ll
    			vec2(4) = iic 
    			vec2(5) = jjc 
    			vec2(6) = kkk
    			vec2(7) = vec1(7)
    			vec2(8) = 3 ! lets get w values
    			call get_f(vec2,mkx1,mkz1,wnn(1))
    			!
    			!
    			!
				!elseif(fieldF.eq.10) then
				!	fvec(1) = dom(ib)%dudx(id-1,jd,kd-1) ! q11
				!elseif(fieldF.eq.11) then
				!	fvec(1) = dom(ib)%dudz(id-1,jd,kd-1) ! q11
				!elseif(fieldF.eq.12) then
				!	fvec(1) = dom(ib)%dwdx(id-1,jd,kd-1) ! q11
				!elseif(fieldF.eq.13) then
				!	fvec(1) = dom(ib)%dwdz(id-1,jd,kd-1) ! q11
    			!
    			! lets obtain velocity component dudz at local node 1, unn(1)
    			vec13(1) = nnStart	! Node nds1
    			vec13(2) = ib 
    			vec13(3) = ll
    			vec13(4) = iii
    			vec13(5) = jjc
    			vec13(6) = kkc
    			vec13(7) = vec1(7)
    			vec13(8) = 11 ! lets ge dudz values
    			call get_f(vec13,ndsx(1),ndsz(1),du_dz(1))
    			! lets obtain velocity component dudx at local node 1, unn(1)
    			vec11(1) = nnStart	! Node nds1
    			vec11(2) = ib 
    			vec11(3) = ll
    			vec11(4) = iii
    			vec11(5) = jjc
    			vec11(6) = kkc
    			vec11(7) = vec1(7)
    			vec11(8) = 10 ! lets ge dudz values
    			call get_f(vec11,ndsx(1),ndsz(1),du_dx(1))
    			!
    			! lets obtain velocity component dwdx at local node 1, wnn(1)
    			vec31(1) = nnStart	! Node nds1
    			vec31(2) = ib 
    			vec31(3) = ll
    			vec31(4) = iic 
    			vec31(5) = jjc 
    			vec31(6) = kkk
    			vec31(7) = vec1(7)
    			vec31(8) = 12 ! lets get dwdx values
    			call get_f(vec31,ndsx(1),ndsz(1),dw_dx(1))
    			! lets obtain velocity component dwdz at local node 1, wnn(1)
    			vec33(1) = nnStart	! Node nds1
    			vec33(2) = ib 
    			vec33(3) = ll
    			vec33(4) = iic 
    			vec33(5) = jjc 
    			vec33(6) = kkk
    			vec33(7) = vec1(7)
    			vec33(8) = 13 ! lets get dwdx values
    			call get_f(vec33,ndsx(1),ndsz(1),dw_dz(1))
				!
				!
				!
				!
		    	! lets obtain the shear stress value at local node 1, tao(1)
		    	if (vec1(7).eq.1) then ! We are in the 1st Quadrant
		    		!dudn(1) = ( unn(1)*cosBetha1 - (-unn(1)*cosBetha1) )/(2*dh)
		    		dudn(1) = unn(1)*cosBetha1/yplus ! central differences
		    		!dwdn = 0.5*( wnn(1)*sinBetha1 - (-wnn(1)*sinBetha1) )/dh
		    		dwdn(1) = wnn(1)*sinBetha1/yplus ! central differences
		    		!dwdn(1) = - wnn(1)*sinBetha1/yplus ! central differences
	!									factor2 = cosBetha1*sinBetha1
    !                            dudn2(1) = + du_dx(1)*cosBetha1*factor2 
    ! &                                     - du_dz(1)*cosBetha1*factor2
    !                            dwdn2(1) = + dw_dx(1)*sinBetha1*factor2
	! &                                     - dw_dz(1)*sinBetha1*factor2
					!
    !                            dudn2(1) = sqrt( (du_dx(1)*cosBetha1)**2 
    ! &                                     + (du_dz(1)*cosBetha1)**2 ) 
    !                            dwdn2(1) = sqrt( (dw_dx(1)*sinBetha1)**2
	! &                                     + (dw_dz(1)*sinBetha1)**2)
					!
					!
					! warning : check this
					musgs(1) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
					tao_x_3(1) = musgs(1)*(du_dx(1) + dw_dx(1))
					tao_z_3(1) = musgs(1)*(du_dz(1) + dw_dz(1))
					!
					!
    				v1(1) = sinBetha1
    				v1(2) = 0.0d0
    				v1(3) = -cosBetha1
    				v2(1) = du_dx(1)*cosBetha1
    				v2(2) = 0.0d0
    				v2(3) = du_dz(1)*cosBetha1 
    		dudn2(1) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
    				v2(1) = dw_dx(1)*sinBetha1
    				v2(2) = 0.0d00
    				v2(3) = dw_dz(1)*sinBetha1
            dwdn2(1) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
								!	tanBetha2 = (du_dz(1))/(du_dx(1))
								!	betha2 = abs(DATAN(tanBetha2))*180/piNUm	! lets obtain betha1
					!
			 	elseif (vec1(7).eq.2) then ! We are in the 2nd Quadrant
					! Check if this has been multiplied by the determinant of the transformation
			 		dudn(1) = unn(1)*cosBetha1/yplus ! central differences
			 		dwdn(1) = - wnn(1)*sinBetha1/yplus ! central differences
	!									factor2 = cosBetha1*sinBetha1
    !                            dudn2(1) = + du_dx(1)*cosBetha1*factor2 
    ! &                                     - du_dz(1)*cosBetha1*factor2
    !                            dwdn2(1) = - dw_dx(1)*sinBetha1*factor2
	! &                                     + dw_dz(1)*sinBetha1*factor2
					 !
    !                            dudn2(1) = sqrt( (du_dx(1)*cosBetha1)**2 
    ! &                                     + (du_dz(1)*cosBetha1)**2 )
    !                            dwdn2(1) = sqrt( (dw_dx(1)*sinBetha1)**2
    ! &                                     + (dw_dz(1)*sinBetha1)**2)
					!
					!
					! warning : check this
					musgs(1) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
					! Check if this has been multiplied by the determinant of the transformation
					tao_x_3(1) = -musgs(1)*(du_dx(1) + dw_dx(1))
					tao_z_3(1) = -musgs(1)*(du_dz(1) + dw_dz(1))
					!
					!
	    			v1(1) = sinBetha1
	    			v1(2) = 0.0d0
	    			v1(3) = cosBetha1
					! Check if this has been multiplied by the determinant of the transformation
	    			v2(1) = du_dx(1)*cosBetha1	! du_dx(1)*(-cosBetha1) chart
	    			v2(2) = 0.0d0
	    			v2(3) = du_dz(1)*cosBetha1  ! dw_dz(1)*(-cosBetha1) chart
	    	dudn2(1) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
	    			v2(1) = -dw_dx(1)*sinBetha1	! dw_dx(1)*sinBetha1	chart
	    			v2(2) = 0.0d00
	    			v2(3) = -dw_dz(1)*sinBetha1	! dw_dz(1)*sinBetha1	chart
		    dwdn2(1) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
				!
				 elseif (vec1(7).eq.3) then ! We are in the 3rd Quadrant
				 	dudn(1) = unn(1)*cosBetha1/yplus ! central differences
				 	dwdn(1) = wnn(1)*sinBetha1/yplus ! central differences
	!									factor2 = cosBetha1*sinBetha1
    !                            dudn2(1) = - du_dx(1)*cosBetha1*factor2 
    ! &                                     + du_dz(1)*cosBetha1*factor2
    !                            dwdn2(1) = - dw_dx(1)*sinBetha1*factor2
	! &                                     + dw_dz(1)*sinBetha1*factor2
					 !
    !                            dudn2(1) = sqrt( (du_dx(1)*cosBetha1)**2 
    ! &                                     + (du_dz(1)*cosBetha1)**2 )
    !                            dwdn2(1) = sqrt( (dw_dx(1)*sinBetha1)**2
    ! &                                     + (dw_dz(1)*sinBetha1)**2)
					!
					!
					! warning : check this
					musgs(1) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
					! Check if this has been multiplied by the determinant of the transformation
					tao_x_3(1) = -musgs(1)*(du_dx(1) + dw_dx(1))
					tao_z_3(1) = -musgs(1)*(du_dz(1) + dw_dz(1))
					!
					!
	    			v1(1) = -sinBetha1
	    			v1(2) = 0.0d0
	    			v1(3) = cosBetha1
					! Check if this has been multiplied by the determinant of the transformation
	    			v2(1) = du_dx(1)*cosBetha1 ! - du_dx(1)*cosBetha1 chart
	    			v2(2) = 0.0d0
	    			v2(3) = du_dz(1)*cosBetha1 ! - du_dz(1)*cosBetha1 chart
	    	dudn2(1) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
	    			v2(1) = dw_dx(1)*sinBetha1 ! - dw_dx(1)*sinBetha1 chart
	    			v2(2) = 0.0d00
	    			v2(3) = dw_dz(1)*sinBetha1 ! - dw_dz(1)*sinBetha1 chart
		    dwdn2(1) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
					!
				 elseif (vec1(7).eq.4) then ! We are in the 4th Quadrant
				 	dudn(1) = unn(1)*cosBetha1/yplus ! central differences
				 	dwdn(1) = - wnn(1)*sinBetha1/yplus ! central differences
	!									factor2 = cosBetha1*sinBetha1
    !                            dudn2(1) = - du_dx(1)*cosBetha1*factor2 
    ! &                                     + du_dz(1)*cosBetha1*factor2
    !                            dwdn2(1) = + dw_dx(1)*sinBetha1*factor2
	! &                                     - dw_dz(1)*sinBetha1*factor2
					 !
    !                            dudn2(1) = sqrt( (du_dx(1)*cosBetha1)**2 
    ! &                                     + (du_dz(1)*cosBetha1)**2 )
    !                            dwdn2(1) = sqrt( (dw_dx(1)*sinBetha1)**2
    ! &                                     + (dw_dz(1)*sinBetha1)**2)
					!
					!
					! warning : check this
					musgs(1) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
					tao_x_3(1) = musgs(1)*(du_dx(1) + dw_dx(1))
					tao_z_3(1) = musgs(1)*(du_dz(1) + dw_dz(1))
					!
					!
	    			v1(1) = -sinBetha1
	    			v1(2) = 0.0d0
	    			v1(3) = -cosBetha1
	    			v2(1) = du_dx(1)*cosBetha1
	    			v2(2) = 0.0d0
	    			v2(3) = du_dz(1)*cosBetha1 
	    	dudn2(1) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
	    			v2(1) = -dw_dx(1)*sinBetha1
	    			v2(2) = 0.0d00
	    			v2(3) = -dw_dz(1)*sinBetha1
	    	dwdn2(1) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
				 endif
				 !
				 ! warning : check this dynamic viscosity value
				 musgs(1) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
				 tao(1) = musgs(1)*(dudn(1) + dwdn(1))
				 tao2(1) = musgs(1)*(dudn2(1) + dwdn2(1))
				!
				!
				!
				!
			    do nn = 1+(mm-1)*mksPS, mm*mksPS	!  sweeping markers of each station
				 !
				 IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				  !
				  if( ( nn.ge.nnStart).and.(nn.le.nnFinish) ) then ! Filtering interior layers
					!
					!
					! Extracting marker coordinates
					ndsx(1) = nodex_loc(nn) 
					ndsy(1) = nodey_loc(nn) 
					ndsz(1) = nodez_loc(nn)
		    		! Extrancting coordinates of the neighbouring markers from the same layer
		    		if ( nn .eq. nnFinish) then
		    			! Coordinates of the next markers, cn2
		    			ndsx(2) = nodex_loc(nnStart)
		    			ndsy(2) = nodey_loc(nnStart)
		    			ndsz(2) = nodez_loc(nnStart)
		    		else
		    			! Coordinates of the next markers, cn2
		    			ndsx(2) = nodex_loc(nn+1)
		    			ndsy(2) = nodey_loc(nn+1)
		    			ndsz(2) = nodez_loc(nn+1)
		    		endif
		    			! Coordinates of cn3, the mid point between cn1 and cn2
		    		ndsx(3) = 0.5*(ndsx(1) + ndsx(2))
		    		ndsy(3) = 0.5*(ndsy(1) + ndsy(2))
		    		ndsz(3) = 0.5*(ndsz(1) + ndsz(2))
		    		!
		    		iic = int ( ( ndsx(2) - origin_xc - margin) /dx_l) + 2
		    		jjc = int ( ( ndsy(2) - origin_yc - margin) /dy_l) + 2
		    		kkc = int ( ( ndsz(2) - origin_zc - margin) /dz_l) + 2
		    		!
		    		iicm = int ( ( ndsx(3) - origin_xc - margin) /dx_l) + 2 
		    		jjcm = int ( ( ndsy(3) - origin_yc - margin) /dy_l) + 2
		    		kkcm = int ( ( ndsz(3) - origin_zc - margin) /dz_l) + 2
		    		!
		    		iii = int ( ( ndsx(2) - origin_x - margin) /dx_l) + 2 
		    		jjj = int ( ( ndsy(2) - origin_y - margin) /dy_l) + 2
		    		kkk = int ( ( ndsz(2) - origin_z - margin) /dz_l) + 2
		    		!
		    		iiim = int ( ( ndsx(3) - origin_x - margin) /dx_l) + 2 
		    		jjjm = int ( ( ndsy(3) - origin_y - margin) /dy_l) + 2
		    		kkkm = int ( ( ndsz(3) - origin_z - margin) /dz_l) + 2
		    		!
		    		! Check for not modifying the ghost layer beyoud the boundaries of the control volume
		    		if (jjc .lt. js) then
		    			jjc = js
		    		endif
		    		if (jjc .gt. je) then
		    			jjc = je
		    		endif
		    		!
					if( (kkc.gt.4).or.(kkk.gt.4)) then ! kkk flag
					!
		    		! Interface vector for u velocity component at cn2
		    		vec1(1) = nn+1	! Node nds(2)
		    		vec1(2) = ib 
		    		vec1(3) = ll
		    		vec1(4) = iii 
		    		vec1(5) = jjc 
		    		vec1(6) = kkc
		    		vec1(8) = 1 ! lets ge u values
					!
					!
		    		! Interface vector for u velocity component at cn3
		    		vecm(1) = nn+1	! It should be node nds(1.5)
		    		vecm(2) = ib 
		    		vecm(3) = ll
		    		vecm(4) = iiim 
		    		vecm(5) = jjcm
		    		vecm(6) = kkcm
		    		vecm(8) = 1 ! lets ge u values
		    		!
		    		! Interface vector for w velocity component at cn2
		    		vec2(1) = nn+1	! Node nds(2)
		    		vec2(2) = ib 
		    		vec2(3) = ll
		    		vec2(4) = iic 
		    		vec2(5) = jjc 
		    		vec2(6) = kkk
		    		vec2(8) = 3 ! lets ge w values
		    		!
		    		! Interface vector for w velocity component at cn3
		    		vecm2(1) = nn+1	! Node nds(1.5)
		    		vecm2(2) = ib 
		    		vecm2(3) = ll
		    		vecm2(4) = iicm 
		    		vecm2(5) = jjcm
		    		vecm2(6) = kkkm
		    		vecm2(8) = 3 ! lets ge u values
		    		!
		    		!
		    		!
		    	! lets obtain velocity component dudz at local node cn2
		    		vec13(1) = nnStart	! Node nds1
		    		vec13(2) = ib 
		    		vec13(3) = ll
		    		vec13(4) = iii
		    		vec13(5) = jjc
		    		vec13(6) = kkc
		    		vec13(8) = 11 ! lets ge dudz values
		    		!
		    		! lets obtain velocity component dudx at local node cn2
		    		vec11(1) = nnStart	! Node nds1
		    		vec11(2) = ib 
		    		vec11(3) = ll
		    		vec11(4) = iii
		    		vec11(5) = jjc
		    		vec11(6) = kkc
		    		vec11(8) = 10 ! lets ge dudx values
		    		!
		    		! lets obtain velocity component dudz at local node cn3
		    		vec13m(1) = nnStart	! Node nds1
		    		vec13m(2) = ib 
		    		vec13m(3) = ll
		    		vec13m(4) = iiim
		    		vec13m(5) = jjcm
		    		vec13m(6) = kkcm
		    		vec13m(8) = 11 ! lets ge dudz values
		    		!
		    		! lets obtain velocity component dudx at local node cn3
		    		vec11m(1) = nnStart	! Node nds1
		    		vec11m(2) = ib 
		    		vec11m(3) = ll
		    		vec11m(4) = iiim
		    		vec11m(5) = jjcm
		    		vec11m(6) = kkcm
		    		vec11m(8) = 10 ! lets ge dudx values
		    		!
		    		! lets obtain velocity component dwdx at local node cn2
		    		vec31(1) = nnStart	! Node nds1
		    		vec31(2) = ib 
		    		vec31(3) = ll
		    		vec31(4) = iic 
		    		vec31(5) = jjc 
		    		vec31(6) = kkk
		    		vec31(8) = 12 ! lets get dwdx values
		    		!
		    		! lets obtain velocity component dwdz at local node cn2
		    		vec33(1) = nnStart	! Node nds1
		    		vec33(2) = ib 
		    		vec33(3) = ll
		    		vec33(4) = iic 
		    		vec33(5) = jjc 
		    		vec33(6) = kkk
		    		vec33(8) = 13 ! lets get dwdz values
		    		!
		    		! lets obtain velocity component dwdx at local node cn3
		    		vec31m(1) = nnStart	! Node nds1
		    		vec31m(2) = ib 
		    		vec31m(3) = ll
		    		vec31m(4) = iicm
		    		vec31m(5) = jjcm
		    		vec31m(6) = kkkm
		    		vec31m(8) = 12 ! lets get dwdx values
		    		!
		    		! lets obtain velocity component dwdz at local node cn3
		    		vec33m(1) = nnStart	! Node nds1
		    		vec33m(2) = ib 
		    		vec33m(3) = ll
		    		vec33m(4) = iicm
		    		vec33m(5) = jjcm
		    		vec33m(6) = kkkm
		    		vec33m(8) = 13 ! lets get dwdz values
		    		!
		    		! lets compute the spacing between cn2 and cn1
		    		ndslx = (ndsx(1) - ndsx(2))**2
		    		ndsly = (ndsy(1) - ndsy(2))**2
		    		ndslz = (ndsz(1) - ndsz(2))**2
					ndsl = sqrt(ndslx+ndsly+ndslz)
					!
					!
					!
					! ( 0, 90 ] First quadrant?
					if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
						if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
							!
					tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
					betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets obtain betha1
							cosBetha1 = DCOS(betha1*piNUm/180)
							sinBetha1 = DSIN(betha1*piNUm/180)
							!
							vec1(7) = 1! qFlag = 1
							vec2(7) = 1! qFlag = 1
							mkx2 = ndsx(2) + yplus*sinBetha1
							mkz2 = ndsz(2) - yplus*cosBetha1
							call get_f(vec1,mkx2,mkz2,unn(2))
							call get_f(vec2,mkx2,mkz2,wnn(2))
							!
							vecm(7) = 1! qFlag = 1
							vecm2(7)= 1! qFlag = 1
							mkx3 = ndsx(3) + yplus*sinBetha1
							mkz3 = ndsz(3) - yplus*cosBetha1
							call get_f(vecm,mkx3,mkz3,unn(3))
							call get_f(vecm2,mkx3,mkz3,wnn(3))
							!
							dudn(2) = unn(2)*cosBetha1/yplus ! central differences
							dwdn(2) = wnn(2)*sinBetha1/yplus ! central differences
							!
							dudn(3) = unn(3)*cosBetha1/yplus ! central differences
							dwdn(3) = wnn(3)*sinBetha1/yplus ! central differences
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							tao(2) = musgs(2)*(dudn(2) + dwdn(2))
							!
							musgs(3) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							tao(3) = musgs(3)*(dudn(3) + dwdn(3))
							!
							! lets integrate the shear stress along the surface using the trapezoid method
							txk = 0.5*(tao(1)+tao(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk = txk*cosBetha1 ! shear stress force parallel to OX axis
							!
							! lets integrate the shear stress along the surface using Simpsom's method
							txk2 = (tao(1)+4*(tao(3))+tao(2))/6
							txk2 = txk2*ndsl*dy_l*cosBetha1
							!
							tzk = 0.5*(tao(1)+tao(2))
							tzk = tzk*ndsl*dy_l*sinBetha1
							!
							tzk2 = (tao(1)+4*(tao(3))+tao(2))/6
							tzk2 = tzk2*ndsl*dy_l*sinBetha1
							!
							vec13(7)  = 1! qFlag = 1
							vec11(7)  = 1! qFlag = 1
							vec33(7)  = 1! qFlag = 1
							vec31(7)  = 1! qFlag = 1
							vec13m(7) = 1! qFlag = 1
							vec11m(7) = 1! qFlag = 1
							vec33m(7) = 1! qFlag = 1
							vec31m(7) = 1! qFlag = 1
							call get_f(vec13,ndsx(2),ndsz(2),du_dz(2))
							call get_f(vec11,ndsx(2),ndsz(2),du_dx(2))
							call get_f(vec13m,ndsx(3),ndsz(3),du_dz(3))
							call get_f(vec11m,ndsx(3),ndsz(3),du_dx(3))
							call get_f(vec31,ndsx(2),ndsz(2),dw_dx(2))
							call get_f(vec33,ndsx(2),ndsz(2),dw_dz(2))
							call get_f(vec31m,ndsx(3),ndsz(3),dw_dx(3))
							call get_f(vec33m,ndsx(3),ndsz(3),dw_dz(3))
							!
!										factor2 = cosBetha1*sinBetha1
!							dudn2(2) = + du_dx(2)*cosBetha1*factor2 
! &                                     - du_dz(2)*cosBetha1*factor2
!							dwdn2(2) = + dw_dx(2)*sinBetha1*factor2
! &                                     - dw_dz(2)*sinBetha1*factor2
!							dudn2(3) = + du_dx(3)*cosBetha1*factor2 
! &                                     - du_dz(3)*cosBetha1*factor2
!							dwdn2(3) = + dw_dx(3)*sinBetha1*factor2
! &                                     - dw_dz(3)*sinBetha1*factor2

!                            dudn2(2) = sqrt( (du_dx(2)*cosBetha1)**2 
! &                                     + (du_dz(2)*cosBetha1)**2 )
!                            dwdn2(2) = sqrt( (dw_dx(2)*sinBetha1)**2
! &                                     + (dw_dz(2)*sinBetha1)**2)
!                            dudn2(3) = sqrt( (du_dx(3)*cosBetha1)**2 
! &                                     + (du_dz(3)*cosBetha1)**2 )
!                            dwdn2(3) = sqrt( (dw_dx(3)*sinBetha1)**2
! &                                     + (dw_dz(3)*sinBetha1)**2)
							!
							!
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							musgs(3) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							tao_x_3(2) = musgs(2)*(du_dx(2) + dw_dx(2))
							tao_z_3(2) = musgs(1)*(du_dz(2) + dw_dz(2))
							tao_x_3(3) = musgs(3)*(du_dx(3) + dw_dx(3))
							tao_z_3(3) = musgs(3)*(du_dz(3) + dw_dz(3))
							!
							tfx_t = 0.5*(tao_x_3(1)+tao_x_3(2)) ! shear stress force parallel to the surface
							tfx_t = tfx_t*ndsl*dy_l*cosBetha1 ! shear stress force parallel to OX axis
							!
							tfx_s = (tao_x_3(1)+4*(tao_x_3(3))+tao_x_3(2))/6
							tfx_s = tfx_s*ndsl*dy_l*cosBetha1
							!
							tfz_t = 0.5*(tao_z_3(1)+tao_z_3(2))
							tfz_t = tfz_t*ndsl*dy_l*sinBetha1
							!
							tfz_s = (tao_z_3(1)+4*(tao_z_3(3))+tao_z_3(2))/6
							tfz_s = tfz_s*ndsl*dy_l*sinBetha1
							!
							!
							!
							v1(1) = sinBetha1
							v1(2) = 0.0d0
							v1(3) = -cosBetha1
							v2(1) = du_dx(2)*cosBetha1
							v2(2) = 0.0d0
							v2(3) = du_dz(2)*cosBetha1 
					dudn2(2) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2(1) = dw_dx(2)*sinBetha1
							v2(2) = 0.0d00
							v2(3) = dw_dz(2)*sinBetha1
					dwdn2(2) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2m(1) = du_dx(3)*cosBetha1
							v2m(2) = 0.0d0
							v2m(3) = du_dz(3)*cosBetha1 
					dudn2(3) =  v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							v2m(1) = dw_dx(3)*sinBetha1
							v2m(2) = 0.0d00
							v2m(3) = dw_dz(3)*sinBetha1
					dwdn2(3) = v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							 !
							tao2(2) = musgs(2)*(dudn2(2) + dwdn2(2))
							tao2(3) = musgs(3)*(dudn2(3) + dwdn2(3))
							!
							txk3 = 0.5*(tao2(1)+tao2(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk3 = txk3*cosBetha1 ! shear stress force parallel to OX axis
							txk4 = (tao2(1)+4*(tao2(3))+tao2(2))/6
							txk4 = txk4*ndsl*dy_l*cosBetha1
							tzk3 = 0.5*(tao2(1)+tao2(2))
							tzk3 = tzk3*ndsl*dy_l*sinBetha1
							tzk4 = (tao2(1)+4*(tao2(3))+tao2(2))/6
							tzk4 = tzk4*ndsl*dy_l*sinBetha1
							!
						endif
						endif
						! ( 90, 180 ] 2nd quadrant?
						if ( (ndsx(2) - ndsx(1)) .le. -margin) then
						if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
					tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
					betha1 = abs(DATAN(tanBetha1))*180/piNUm	
							cosBetha1 = DCOS(betha1*piNUm/180)
							sinBetha1 = DSIN(betha1*piNUm/180)
							vec1(7) = 2! qFlag = 1
							vecm(7) = 2! qFlag = 1
							vec2(7) = 2! qFlag = 1
							vecm2(7)= 2! qFlag = 1
							mkx2 = ndsx(2) + yplus*sinBetha1
							mkz2 = ndsz(2) + yplus*cosBetha1
							mkx3 = ndsx(3) + yplus*sinBetha1
							mkz3 = ndsz(3) + yplus*cosBetha1
							call get_f(vec1,mkx2,mkz2,unn(2))
							call get_f(vecm,mkx3,mkz3,unn(3))
							call get_f(vec2,mkx2,mkz2,wnn(2))
							call get_f(vecm2,mkx3,mkz3,wnn(3))
							!
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							! remember to multiply by the determinan of the coordinates transfotmation
							dudn(2) = unn(2)*cosBetha1/yplus ! central differences	! - unn(2)*cosBetha1/yplus ! central differences
							dwdn(2) = - wnn(2)*sinBetha1/yplus ! central differences	! + wnn(2)*sinBetha1/yplus ! central differences
							tao(2) = musgs(2)*(dudn(2) + dwdn(2))
							! warning : check this
							musgs(3) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							! remember to multiply by the determinan of the coordinates transfotmation
							dudn(3) = unn(3)*cosBetha1/yplus ! central differences    
							dwdn(3) = - wnn(3)*sinBetha1/yplus ! central differences
							tao(3) = musgs(3)*(dudn(3) + dwdn(3))
							!
							txk = 0.5*(tao(1)+tao(2))
							txk = txk*ndsl*dy_l*cosBetha1
							!
							txk2 = (tao(1)+4*(tao(3))+tao(2))/6
							txk2 = txk2*ndsl*dy_l*cosBetha1
							!
							tzk = 0.5*(tao(1)+tao(2))
							tzk = - tzk*ndsl*dy_l*sinBetha1
							!
							tzk2 = (tao(1)+4*(tao(3))+tao(2))/6
							tzk2 = - tzk2*ndsl*dy_l*sinBetha1
							!
							vec13(7)  = 2
							vec11(7)  = 2
							vec33(7)  = 2
							vec31(7)  = 2
							vec13m(7) = 2
							vec11m(7) = 2
							vec33m(7) = 2
							vec31m(7) = 2
							call get_f(vec13,ndsx(2),ndsz(2),du_dz(2))
							call get_f(vec11,ndsx(2),ndsz(2),du_dx(2))
							call get_f(vec13m,ndsx(3),ndsz(3),du_dz(3))
							call get_f(vec11m,ndsx(3),ndsz(3),du_dx(3))
							call get_f(vec31,ndsx(2),ndsz(2),dw_dx(2))
							call get_f(vec33,ndsx(2),ndsz(2),dw_dz(2))
							call get_f(vec31m,ndsx(3),ndsz(3),dw_dx(3))
							call get_f(vec33m,ndsx(3),ndsz(3),dw_dz(3))
							!
							factor2 = cosBetha1*sinBetha1
!								dudn2(2) = + du_dx(2)*cosBetha1*factor2 
!   &                                     - du_dz(2)*cosBetha1*factor2
!  							dwdn2(2) = - dw_dx(2)*sinBetha1*factor2
!   &                                     + dw_dz(2)*sinBetha1*factor2
!  							dudn2(3) = + du_dx(3)*cosBetha1*factor2 
!   &                                     - du_dz(3)*cosBetha1*factor2
!  							dwdn2(3) = - dw_dx(3)*sinBetha1*factor2
!   &                                     + dw_dz(3)*sinBetha1*factor2

!                              dudn2(2) = sqrt( (du_dx(2)*cosBetha1)**2 
!   &                                     + (du_dz(2)*cosBetha1)**2 )
!                              dwdn2(2) = sqrt( (dw_dx(2)*sinBetha1)**2
!   &                                     + (dw_dz(2)*sinBetha1)**2)
!                              dudn2(3) = sqrt( (du_dx(3)*cosBetha1)**2 
!   &                                     + (du_dz(3)*cosBetha1)**2 )
!                              dwdn2(3) = sqrt( (dw_dx(3)*sinBetha1)**2
!   &                                     + (dw_dz(3)*sinBetha1)**2)
							!
							!
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							musgs(3) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							! remember to multiply by the determinan of the coordinates transfotmation
							tao_x_3(2) = -musgs(2)*(du_dx(2) + dw_dx(2))
							tao_z_3(2) = -musgs(1)*(du_dz(2) + dw_dz(2))
							tao_x_3(3) = -musgs(3)*(du_dx(3) + dw_dx(3))
							tao_z_3(3) = -musgs(3)*(du_dz(3) + dw_dz(3))
							!
							tfx_t = 0.5*(tao_x_3(1)+tao_x_3(2)) ! shear stress force parallel to the surface
							tfx_t = tfx_t*ndsl*dy_l*cosBetha1 ! shear stress force parallel to OX axis
							!
							tfx_s = (tao_x_3(1)+4*(tao_x_3(3))+tao_x_3(2))/6
							tfx_s = tfx_s*ndsl*dy_l*cosBetha1
							!
							tfz_t = 0.5*(tao_z_3(1)+tao_z_3(2))
							tfz_t = tfz_t*ndsl*dy_l*sinBetha1
							!
							tfz_s = (tao_z_3(1)+4*(tao_z_3(3))+tao_z_3(2))/6
							tfz_s = tfz_s*ndsl*dy_l*sinBetha1
							!
							!
							v1(1) = sinBetha1
							v1(2) = 0.0d0
							v1(3) = cosBetha1
							! remember to multiply by the determinan of the coordinates transfotmation
							v2(1) = du_dx(2)*cosBetha1	! - du_dx(2)*cosBetha1 chart
							v2(2) = 0.0d0
							v2(3) = du_dz(2)*cosBetha1	! - du_dz(2)*cosBetha1 chart
					dudn2(2) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2(1) = -dw_dx(2)*sinBetha1 ! dw_dx(2)*sinBetha1 chart
							v2(2) = 0.0d00
							v2(3) = -dw_dz(2)*sinBetha1 ! dw_dz(2)*sinBetha1 chart
					dwdn2(2) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2m(1) = du_dx(3)*cosBetha1
							v2m(2) = 0.0d0
							v2m(3) = du_dz(3)*cosBetha1 
					dudn2(3) =  v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							v2m(1) = -dw_dx(3)*sinBetha1
							v2m(2) = 0.0d00
							v2m(3) = -dw_dz(3)*sinBetha1
					dwdn2(3) = v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							!
							tao2(2) = musgs(2)*(dudn2(2) + dwdn2(2))
							tao2(3) = musgs(3)*(dudn2(3) + dwdn2(3))
							!
							txk3 = 0.5*(tao2(1)+tao2(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk3 = txk3*cosBetha1 ! shear stress force parallel to OX axis
							txk4 = (tao2(1)+4*(tao2(3))+tao2(2))/6
							txk4 = txk4*ndsl*dy_l*cosBetha1
							tzk3 = 0.5*(tao2(1)+tao2(2))
							tzk3 = - tzk3*ndsl*dy_l*sinBetha1
							tzk4 = (tao2(1)+4*(tao2(3))+tao2(2))/6
							tzk4 = - tzk4*ndsl*dy_l*sinBetha1
							!
						endif
						endif
						! ( 180, 270 ] 3rd quadrant?
						if ( (ndsx(2) - ndsx(1)) .le. margin) then
						if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
					tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
					betha1 = abs(DATAN(tanBetha1))*180/piNUm	
							cosBetha1 = DCOS(betha1*piNUm/180)
							sinBetha1 = DSIN(betha1*piNUm/180)
							vec1(7) = 3! qFlag = 1
							vecm(7) = 3! qFlag = 1
							vec2(7) = 3! qFlag = 1
							vecm2(7)= 3! qFlag = 1
							mkx2 = ndsx(2) - yplus*sinBetha1
							mkz2 = ndsz(2) + yplus*cosBetha1
							mkx3 = ndsx(3) - yplus*sinBetha1
							mkz3 = ndsz(3) + yplus*cosBetha1
							call get_f(vec1,mkx2,mkz2,unn(2))
							call get_f(vecm,mkx3,mkz3,unn(3))
							call get_f(vec2,mkx2,mkz2,wnn(2))
							call get_f(vecm2,mkx3,mkz3,wnn(3))
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							! remember to multiply by the determinan of the coordinates transfotmation
							dudn(2) = unn(2)*cosBetha1/yplus ! central differences    
							dwdn(2) = wnn(2)*sinBetha1/yplus ! central differences
							tao(2) = musgs(2)*(dudn(2) + dwdn(2))
							! warning : check this
							musgs(3) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							! remember to multiply by the determinan of the coordinates transfotmation
							dudn(3) = unn(3)*cosBetha1/yplus ! central differences	! - unn(3)*cosBetha1/yplus ! central differences
							dwdn(3) = wnn(3)*sinBetha1/yplus ! central differences	! - wnn(3)*sinBetha1/yplus ! central differences
							tao(3) = musgs(3)*(dudn(3) + dwdn(3))
							!
							txk = 0.5*(tao(1)+tao(2))
							txk = txk*ndsl*dy_l*cosBetha1
							!
							txk2 = (tao(1)+4*(tao(3))+tao(2))/6
							txk2 = txk2*ndsl*dy_l*cosBetha1
							!
							tzk = 0.5*(tao(1)+tao(2))
							tzk = tzk*ndsl*dy_l*sinBetha1
							!
							tzk2 = (tao(1)+4*(tao(3))+tao(2))/6
							tzk2 = tzk2*ndsl*dy_l*sinBetha1
							!
							vec13(7)  = 3
							vec11(7)  = 3
							vec33(7)  = 3
							vec31(7)  = 3
							vec13m(7) = 3
							vec11m(7) = 3
							vec33m(7) = 3
							vec31m(7) = 3
							call get_f(vec13,ndsx(2),ndsz(2),du_dz(2))
							call get_f(vec11,ndsx(2),ndsz(2),du_dx(2))
							call get_f(vec13m,ndsx(3),ndsz(3),du_dz(3))
							call get_f(vec11m,ndsx(3),ndsz(3),du_dx(3))
							call get_f(vec31,ndsx(2),ndsz(2),dw_dx(2))
							call get_f(vec33,ndsx(2),ndsz(2),dw_dz(2))
							call get_f(vec31m,ndsx(3),ndsz(3),dw_dx(3))
							call get_f(vec33m,ndsx(3),ndsz(3),dw_dz(3))
							!
							factor2 = cosBetha1*sinBetha1
!							dudn2(2) = - du_dx(2)*cosBetha1*factor2 
! &                                     + du_dz(2)*cosBetha1*factor2
!							dwdn2(2) = - dw_dx(2)*sinBetha1*factor2
! &                                     + dw_dz(2)*sinBetha1*factor2
!							dudn2(3) = - du_dx(3)*cosBetha1*factor2 
! &                                     + du_dz(3)*cosBetha1*factor2
!							dwdn2(3) = - dw_dx(3)*sinBetha1*factor2
! &                                     + dw_dz(3)*sinBetha1*factor2
!                             dudn2(2) = sqrt( (du_dx(2)*cosBetha1)**2 
!  &                                     + (du_dz(2)*cosBetha1)**2 )
!                             dwdn2(2) = sqrt( (dw_dx(2)*sinBetha1)**2
!  &                                     + (dw_dz(2)*sinBetha1)**2)
!                             dudn2(3) = sqrt( (du_dx(3)*cosBetha1)**2 
!  &                                     + (du_dz(3)*cosBetha1)**2 )
!                             dwdn2(3) = sqrt( (dw_dx(3)*sinBetha1)**2
!  &                                     + (dw_dz(3)*sinBetha1)**2)
							!
							!
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							musgs(3) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							! remember to multiply by the determinan of the coordinates transfotmation
							tao_x_3(2) = -musgs(2)*(du_dx(2) + dw_dx(2))
							tao_z_3(2) = -musgs(1)*(du_dz(2) + dw_dz(2))
							tao_x_3(3) = -musgs(3)*(du_dx(3) + dw_dx(3))
							tao_z_3(3) = -musgs(3)*(du_dz(3) + dw_dz(3))
							!
							tfx_t = 0.5*(tao_x_3(1)+tao_x_3(2)) ! shear stress force parallel to the surface
							tfx_t = tfx_t*ndsl*dy_l*cosBetha1 ! shear stress force parallel to OX axis
							!
							tfx_s = (tao_x_3(1)+4*(tao_x_3(3))+tao_x_3(2))/6
							tfx_s = tfx_s*ndsl*dy_l*cosBetha1
							!
							tfz_t = 0.5*(tao_z_3(1)+tao_z_3(2))
							tfz_t = tfz_t*ndsl*dy_l*sinBetha1
							!
							tfz_s = (tao_z_3(1)+4*(tao_z_3(3))+tao_z_3(2))/6
							tfz_s = tfz_s*ndsl*dy_l*sinBetha1
							!
							!
						v1(1) = -sinBetha1
						v1(2) = 0.0d0
						v1(3) = cosBetha1
						! remember to multiply by the determinan of the coordinates transfotmation
						v2(1) = du_dx(2)*cosBetha1
						v2(2) = 0.0d0
						v2(3) = du_dz(2)*cosBetha1 
				dudn2(2) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
						v2(1) = dw_dx(2)*sinBetha1
						v2(2) = 0.0d00
						v2(3) = dw_dz(2)*sinBetha1
				dwdn2(2) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
						v2m(1) = du_dx(3)*cosBetha1
						v2m(2) = 0.0d0
						v2m(3) = du_dz(3)*cosBetha1 
				dudn2(3) =  v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
						v2m(1) = dw_dx(3)*sinBetha1
						v2m(2) = 0.0d00
						v2m(3) = dw_dz(3)*sinBetha1
				dwdn2(3) = v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							 !
							tao2(2) = musgs(2)*(dudn2(2) + dwdn2(2))
							tao2(3) = musgs(3)*(dudn2(3) + dwdn2(3))
							!
							txk3 = 0.5*(tao2(1)+tao2(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk3 = txk3*cosBetha1 ! shear stress force parallel to OX axis
							txk4 = (tao2(1)+4*(tao2(3))+tao2(2))/6
							txk4 = txk4*ndsl*dy_l*cosBetha1
							tzk3 = 0.5*(tao2(1)+tao2(2))
							tzk3 = tzk3*ndsl*dy_l*sinBetha1
							tzk4 = (tao2(1)+4*(tao2(3))+tao2(2))/6
							tzk4 = tzk4*ndsl*dy_l*sinBetha1
							!
						endif
						endif
						! ( 270, 360 ] 4th quadrant?
						if ( (ndsx(2) - ndsx(1)) .gt. margin) then
						if ( (ndsz(2) - ndsz(1)) .le. margin) then
					tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
					betha1 = abs(DATAN(tanBetha1))*180/piNUm	
							cosBetha1 = DCOS(betha1*piNUm/180)
							sinBetha1 = DSIN(betha1*piNUm/180)
							vec1(7) = 4! qFlag = 1
							vecm(7) = 4! qFlag = 1
							vec2(7) = 4! qFlag = 1
							vecm2(7)= 4! qFlag = 1
							mkx2 = ndsx(2) - yplus*sinBetha1
							mkz2 = ndsz(2) - yplus*cosBetha1
							mkx3 = ndsx(3) - yplus*sinBetha1
							mkz3 = ndsz(3) - yplus*cosBetha1
							call get_f(vec1,mkx2,mkz2,unn(2))
							call get_f(vecm,mkx3,mkz3,unn(3))
							call get_f(vec2,mkx2,mkz2,wnn(2))
							call get_f(vecm2,mkx3,mkz3,wnn(3))
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							dudn(2) = unn(2)*cosBetha1/yplus ! central differences	
							dwdn(2) = - wnn(2)*sinBetha1/yplus ! central differences
							tao(2) = musgs(2)*(dudn(2) + dwdn(2))
							! warning : check this
							musgs(3) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							dudn(3) = unn(3)*cosBetha1/yplus ! central differences
							dwdn(3) = - wnn(3)*sinBetha1/yplus ! central differences
							tao(3) = musgs(3)*(dudn(3) + dwdn(3))
							!
							txk = 0.5*(tao(1)+tao(2))
							txk = txk*ndsl*dy_l*cosBetha1
							!
							txk2 = (tao(1)+4*(tao(3))+tao(2))/6
							txk2 = txk2*ndsl*dy_l*cosBetha1
							!
							tzk = 0.5*(tao(1)+tao(2))
							tzk = - tzk*ndsl*dy_l*sinBetha1
							!
							tzk2 = (tao(1)+4*(tao(3))+tao(2))/6
							tzk2 = - tzk2*ndsl*dy_l*sinBetha1
							!
							vec13(7)  = 4
							vec11(7)  = 4
							vec33(7)  = 4
							vec31(7)  = 4
							vec13m(7) = 4
							vec11m(7) = 4
							vec33m(7) = 4
							vec31m(7) = 4
							call get_f(vec13,ndsx(2),ndsz(2),du_dz(2))
							call get_f(vec11,ndsx(2),ndsz(2),du_dx(2))
							call get_f(vec13m,ndsx(3),ndsz(3),du_dz(3))
							call get_f(vec11m,ndsx(3),ndsz(3),du_dx(3))
							call get_f(vec31,ndsx(2),ndsz(2),dw_dx(2))
							call get_f(vec33,ndsx(2),ndsz(2),dw_dz(2))
							call get_f(vec31m,ndsx(3),ndsz(3),dw_dx(3))
							call get_f(vec33m,ndsx(3),ndsz(3),dw_dz(3))
							!
							factor2 = cosBetha1*sinBetha1
!							dudn2(2) = - du_dx(2)*cosBetha1*factor2 
! &                                     + du_dz(2)*cosBetha1*factor2
!							dwdn2(2) = + dw_dx(2)*sinBetha1*factor2
! &                                     - dw_dz(2)*sinBetha1*factor2
!							dudn2(3) = - du_dx(3)*cosBetha1*factor2 
! &                                     + du_dz(3)*cosBetha1*factor2
!							dwdn2(3) = + dw_dx(3)*sinBetha1*factor2
! &                                     - dw_dz(3)*sinBetha1*factor2
!                            dudn2(2) = sqrt( (du_dx(2)*cosBetha1)**2 
! &                                     + (du_dz(2)*cosBetha1)**2 )
!                            dwdn2(2) = sqrt( (dw_dx(2)*sinBetha1)**2
! &                                     + (dw_dz(2)*sinBetha1)**2)
!                            dudn2(3) = sqrt( (du_dx(3)*cosBetha1)**2 
! &                                     + (du_dz(3)*cosBetha1)**2 )
!                            dwdn2(3) = sqrt( (dw_dx(3)*sinBetha1)**2
! &                                     + (dw_dz(3)*sinBetha1)**2)
							!
							!
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							musgs(3) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							tao_x_3(2) = musgs(2)*(du_dx(2) + dw_dx(2))
							tao_z_3(2) = musgs(1)*(du_dz(2) + dw_dz(2))
							tao_x_3(3) = musgs(3)*(du_dx(3) + dw_dx(3))
							tao_z_3(3) = musgs(3)*(du_dz(3) + dw_dz(3))
							!
							tfx_t = 0.5*(tao_x_3(1)+tao_x_3(2)) ! shear stress force parallel to the surface
							tfx_t = tfx_t*ndsl*dy_l*cosBetha1 ! shear stress force parallel to OX axis
							!
							tfx_s = (tao_x_3(1)+4*(tao_x_3(3))+tao_x_3(2))/6
							tfx_s = tfx_s*ndsl*dy_l*cosBetha1
							!
							tfz_t = 0.5*(tao_z_3(1)+tao_z_3(2))
							tfz_t = tfz_t*ndsl*dy_l*sinBetha1
							!
							tfz_s = (tao_z_3(1)+4*(tao_z_3(3))+tao_z_3(2))/6
							tfz_s = tfz_s*ndsl*dy_l*sinBetha1
							!
							!
							v1(1) = -sinBetha1
							v1(2) = 0.0d0
							v1(3) = -cosBetha1
							v2(1) = du_dx(2)*cosBetha1
							v2(2) = 0.0d0
							v2(3) = du_dz(2)*cosBetha1 
					dudn2(2) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2(1) = -dw_dx(2)*sinBetha1
							v2(2) = 0.0d00
							v2(3) = -dw_dz(2)*sinBetha1
					dwdn2(2) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2m(1) = du_dx(3)*cosBetha1
							v2m(2) = 0.0d0
							v2m(3) = du_dz(3)*cosBetha1 
					dudn2(3) =  v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							v2m(1) = -dw_dx(3)*sinBetha1
							v2m(2) = 0.0d00
							v2m(3) = -dw_dz(3)*sinBetha1
					dwdn2(3) = v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							!
							tao2(2) = musgs(2)*(dudn2(2) + dwdn2(2))
							tao2(3) = musgs(3)*(dudn2(3) + dwdn2(3))
							!
							txk3 = 0.5*(tao2(1)+tao2(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk3 = txk3*cosBetha1 ! shear stress force parallel to OX axis
							txk4 = (tao2(1)+4*(tao2(3))+tao2(2))/6
							txk4 = txk4*ndsl*dy_l*cosBetha1
							tzk3 = 0.5*(tao2(1)+tao2(2))
							tzk3 = - tzk3*ndsl*dy_l*sinBetha1
							tzk4 = (tao2(1)+4*(tao2(3))+tao2(2))/6
							tzk4 = - tzk4*ndsl*dy_l*sinBetha1
							!
						endif
						endif
					!
					!
					coef2 = 1/(0.5*1*(Ubulk**2)*1)
					bb = mksEL + (int(St_k/2.0d00))*mksPS
					aa = 1 + (int(St_k/2.0d00))*mksPS
					if( (nn.ge.aa).and.(nn.le.bb) ) then
			 		!if((nn.gt.9240).and.(nn.lt.10561)) then
					cmx=nodex_loc(aa-0.5d00)
					cmz=nodez_loc(aa)
			 			tempx = (ndsx(1) - cmx)
						 !crazy
			 			tempz = (ndsz(1) - cmz)
			 			if (vec1(7).eq.3) then
			 	gamma1 = - DATAN(tempz/tempx)*180/piNUm
			 			elseif (vec1(7).eq.2) then
			 	gamma1 = 180 - DATAN(tempz/tempx)*180/piNUm
			 			elseif (vec1(7).eq.4) then
			 	gamma1 = - DATAN(tempz/tempx)*180/piNUm
			 			elseif (vec1(7).eq.1) then
			 	gamma1 = -180 - DATAN(tempz/tempx)*180/piNUm
			 			endif
						!
						tanBetha2 = (du_dz(2))/(du_dx(2))
						betha2 = abs(DATAN(tanBetha2))*180/piNUm	! lets obtain betha1
						tanBetha3 = (dw_dz(2))/(dw_dx(2))
						betha3 = abs(DATAN(tanBetha3))*180/piNUm	! lets obtain betha1
						!
						IF (flagWrite) then
						write(6,*) nn, gamma1, tao2(1)*coef2
						endif
					endif
					!
				bb = mksEL + (int(St_k/3.0d00))*mksPS
				aa = 1 + (int(St_k/3.0d00))*mksPS
					step = int((bb-aa)/11)
					do threshold1 = aa, bb, step ! sampling points
	   				if(nn.eq.threshold1) then
	   					write(6,*) nn, vec11(7)
						write(6,*) iic, jjc, kkc
	   					write(6,*) tao*coef2
	   					write(6,*) txk, tzk
	   					write(6,*) txk2, tzk2
						write(6,*) txk3,tzk3
						write(6,*) txk4,tzk4
			   			write(6,*) tfx_t, tfz_t
			   			write(6,*) tfx_s, tfz_s
	   				endif
					enddo
					!
					!
		        	!
		        	!	! check !!!
		        	txVecSt(M,mm)  = txVecSt(M,mm)  + txk 
		        	tzVecSt(M,mm)  = tzVecSt(M,mm)  + tzk
					!
		        	txVecSt2(M,mm) = txVecSt2(M,mm) + txk2 
		        	tzVecSt2(M,mm) = tzVecSt2(M,mm) + tzk2
					!
					!
		        	txVecSt3(M,mm) = txVecSt3(M,mm) + txk3 
		        	tzVecSt3(M,mm) = tzVecSt3(M,mm) + tzk3
					!
		        	txVecSt4(M,mm) = txVecSt4(M,mm) + txk4 
		        	tzVecSt4(M,mm) = tzVecSt4(M,mm) + tzk4
					!
					!
		        	txVecSt5(M,mm) = txVecSt5(M,mm) + tfx_t
		        	tzVecSt5(M,mm) = tzVecSt5(M,mm) + tfz_t
					!
		        	txVecSt6(M,mm) = txVecSt6(M,mm) + tfx_s 
		        	tzVecSt6(M,mm) = tzVecSt6(M,mm) + tfz_s
					!
		        	!
					! Update of unn(1)
					unn(1)   = unn(2)
					wnn(1)   = wnn(2)
					tao(1)   = tao(2)
					!
					du_dz(1) = du_dz(2)
					du_dx(1) = du_dx(2)
					dw_dz(1) = dw_dz(2)
					dw_dx(1) = dw_dx(2)
					tao2(1)  = tao2(2)
					!
					tao_x_3(1) = tao_x_3(2) 
					tao_z_3(1) = tao_z_3(2) 
		    		!
		    		!
					!
				  else
					ll = 2
				  endif! Filtering interior layers
				  !
				 endif	! Ensuring processor ID matches subdomain ID???
				 !
				endif	! kkk flag
			    enddo	!  sweeping markers of each station
				!
				!
				!
				!
				!
				!		! check !!!
				if ( (mm.eq.1).or.(mm.eq.St_k) )then
					txVecSt(M,mm) = 0.5*txVecSt(M,mm)
					txVecSt2(M,mm) = 0.5*txVecSt2(M,mm)
					tzVecSt(M,mm)  = 0.5*tzVecSt(M,mm)
					tzVecSt2(M,mm) = 0.5*tzVecSt2(M,mm)
					!
					txVecSt3(M,mm) = 0.5*txVecSt3(M,mm)
					txVecSt4(M,mm) = 0.5*txVecSt4(M,mm)
					tzVecSt3(M,mm) = 0.5*tzVecSt3(M,mm)
					tzVecSt4(M,mm) = 0.5*tzVecSt4(M,mm)
					!
					txVecSt5(M,mm) = 0.5*txVecSt5(M,mm)
					txVecSt6(M,mm) = 0.5*txVecSt6(M,mm)
					tzVecSt5(M,mm) = 0.5*tzVecSt5(M,mm)
					tzVecSt6(M,mm) = 0.5*tzVecSt6(M,mm)
					!write(6,*) mm, txVecSt(M,mm), txVecSt2(M,mm)
				endif
				!
				tx(M)  = tx(M)  + txVecSt(M,mm)
				tz(M)  = tz(M)  + tzVecSt(M,mm)
				!
				tx2(M) = tx2(M) + txVecSt2(M,mm)
				tz2(M) = tz2(M) + tzVecSt2(M,mm)
				!
				!
				tx3(M) = tx3(M) + txVecSt3(M,mm)
				tz3(M) = tz3(M) + tzVecSt3(M,mm)
				!
				tx4(M) = tx4(M) + txVecSt4(M,mm)
				tz4(M) = tz4(M) + tzVecSt4(M,mm)
				!
				!
				tx5(M) = tx5(M) + txVecSt5(M,mm)
				tz5(M) = tz5(M) + tzVecSt5(M,mm)
				!
				tx6(M) = tx6(M) + txVecSt6(M,mm)
				tz6(M) = tz6(M) + tzVecSt6(M,mm)
				!
				!
				!
			  enddo	! sweeping stations
			  !
			  !
			  DEALLOCATE(txVecSt,tzVecSt)
			  DEALLOCATE(txVecSt2,tzVecSt2)
			  DEALLOCATE(txVecSt3,tzVecSt3)
			  DEALLOCATE(txVecSt4,tzVecSt4)
			  DEALLOCATE(txVecSt5,tzVecSt5)
			  DEALLOCATE(txVecSt6,tzVecSt6)
			  !
		      !
		      !
			  !sh1(1) = tx2(M)
			  !sh1(2) = 0.0d0
			  !sh1(3) = tz2(M)
			  shout(1) = tx2(M) !tx4(M) !tx2(M)
			  shout(2) = 0.0d0
			  shout(3) = tz2(M) !tz4(M)	!tz2(M)
			  !
			  spam = nodey_loc(lastNode) - nodey_loc(firstNode)
			  coef1 = 1/(0.5*1*(Ubulk**2)*1*spam)
			  tcdx(M) = coef1*tx(M) 
			  tcdz(M) = coef1*tz(M)
			  tcdx2(M) = coef1*tx2(M) 
			  tcdz2(M) = coef1*tz2(M)
			  tcdx3(M) = coef1*tx3(M) 
			  tcdz3(M) = coef1*tz3(M)
			  tcdx4(M) = coef1*tx4(M) 
			  tcdz4(M) = coef1*tz4(M)
			  tcdx5(M) = coef1*tx5(M) 
			  tcdz5(M) = coef1*tz5(M)
			  tcdx6(M) = coef1*tx6(M) 
			  tcdz6(M) = coef1*tz6(M)
			  write(6,*) "tx", tx(M), tx2(M)
			  write(6,*) "tcdx", tcdx(M), tcdx2(M)
			  write(6,*) "tz", tz(M), tz2(M)
			  write(6,*) "tcdz", tcdz(M), tcdz2(M)
			  !
			  write(6,*) "tx", tx3(M), tx4(M)
			  write(6,*) "tcdx", tcdx3(M), tcdx4(M)
			  write(6,*) "tz", tz3(M), tz4(M)
			  write(6,*) "tcdz", tcdz3(M), tcdz4(M)
			  !
			  write(6,*) "tx", tx5(M), tx6(M)
			  write(6,*) "tcdx", tcdx5(M), tcdx6(M)
			  write(6,*) "tz", tz5(M), tz6(M)
			  write(6,*) "tcdz", tcdz5(M), tcdz6(M)
			  !
			  !
	        endif ! Filtering out procesors
		    !
		   enddo ! End of the  loop sweeping the domains
		   !
		   !
		   !
	    enddo ! end of the loop sweeping the bodies
	!endif ! the master processor reliquishes control

	    DEALLOCATE(tcdx, tcdz)
	    DEALLOCATE(tx, tz )
	    DEALLOCATE(tcdx2, tcdz2)
	    DEALLOCATE(tx2, tz2 )
	    DEALLOCATE(tx3, tz3 )
	    DEALLOCATE(tx4, tz4 )
	    DEALLOCATE(tcdx3, tcdz3)
	    DEALLOCATE(tcdx4, tcdz4)
	    DEALLOCATE(tcdx5, tcdz5)
	    DEALLOCATE(tcdx6, tcdz6)
	    !
	    !
	    close(93)
	    close(94)
	    close(95)
	    close(96)

!######################################################################		
	END SUBROUTINE shearStressProbe
!######################################################################	 

!######################################################################
	SUBROUTINE get_f(vec1,ndsx,ndsz,unn)
!######################################################################

        ! Function for obtaining one of the following filed values, u, v, w, p; 
        ! anywhere in the control volume, using interpolation.

				use imb
				use mpi
				use multidata

				implicit none

				! temporal variables
				DOUBLE PRECISION:: temp

				! Input valriables
				INTEGER, INTENT(IN):: vec1(8)
				DOUBLE PRECISION, INTENT(IN):: ndsx, ndsz
				! Location of cell face center of ghost cell 

				! Output variables
				DOUBLE PRECISION, INTENT(OUT):: unn
				! unn:  Pressure in the marker's location

				! Interfaces
				INTEGER:: nn, ib, ll, id, jd, kd, qF, fieldF

				! values for interpoation points
				DOUBLE PRECISION:: fvec(4) ! Pressure in the neighbouring fluid cells used in the interpolation scheme
				DOUBLE PRECISION:: nx(2), nz(2) ! Location of the interpolation points

				! intergace with interpolationF
				INTEGER:: vec2(8)
				DOUBLE PRECISION:: vec3(3)


			!	if (myrank.eq. master ) then ! The control is passed down to the master processor


				nn     = vec1(1)
				ib     = vec1(2)
				ll     = vec1(3)
				id     = vec1(4)
				jd     = vec1(5)
				kd     = vec1(6)
				qF     = vec1(7) ! this is defined in a finction later
                fieldF = vec1(8) ! flag for indicating which field to work with

				if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
					! markers are located

					IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???


                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				!!! BILINEAR INTERPOLATION
                   if (fieldF.eq.1) then
		       	 fvec(1) = dom(ib)%u(id-1,jd,kd-1) ! q11
		       	 fvec(2) = dom(ib)%u(id,jd,kd-1)   ! q21
		       	 fvec(3) = dom(ib)%u(id-1,jd,kd)   ! q12
                 fvec(4) = dom(ib)%u(id,jd,kd)	   ! q22
		       	 !fvec(5) = dom(ib)%u(id-1,jd-1,kd-1) ! q11
		       	 !fvec(6) = dom(ib)%u(id,jd-1,kd-1)   ! q21
		       	 !fvec(7) = dom(ib)%u(id-1,jd-1,kd)   ! q12
		       	 !fvec(8) = dom(ib)%u(id,jd-1,kd)	   ! q22
		       	 nx(1) = dom(ib)%x(id-1)
		       	 nx(2) = dom(ib)%x(id)
		       	 nz(1) = dom(ib)%zc(kd-1)
                 nz(2) = dom(ib)%zc(kd)
		       	 !ny(1) = dom(ib)%yc(id)
		       	 !ny(2) = dom(ib)%yc(id-1)
                   elseif(fieldF.eq.2) then
		       	 fvec(1) = dom(ib)%v(id-1,jd,kd-1) ! q11
		       	 fvec(2) = dom(ib)%v(id,jd,kd-1)   ! q21
		       	 fvec(3) = dom(ib)%v(id-1,jd,kd)   ! q12
                 fvec(4) = dom(ib)%v(id,jd,kd)	   ! q22
		       	 !fvec(5) = dom(ib)%v(id-1,jd-1,kd-1) ! q11
		       	 !fvec(6) = dom(ib)%v(id,jd-1,kd-1)   ! q21
		       	 !fvec(7) = dom(ib)%v(id-1,jd-1,kd)   ! q12
		       	 !fvec(8) = dom(ib)%v(id,jd-1,kd)	   ! q22
		       	 nx(1) = dom(ib)%xc(id-1)
		       	 nx(2) = dom(ib)%xc(id)
		       	 nz(1) = dom(ib)%zc(kd-1)
                 nz(2) = dom(ib)%zc(kd)
		       	 !ny(1) = dom(ib)%y(id)
		       	 !ny(2) = dom(ib)%y(id-1)
                   elseif(fieldF.eq.3) then
		       	 fvec(1) = dom(ib)%w(id-1,jd,kd-1) ! q11
		       	 fvec(2) = dom(ib)%w(id,jd,kd-1)   ! q21
		       	 fvec(3) = dom(ib)%w(id-1,jd,kd)   ! q12
             	 fvec(4) = dom(ib)%w(id,jd,kd)	   ! q22
		       	 !fvec(5) = dom(ib)%w(id-1,jd-1,kd-1) ! q11
		       	 !fvec(6) = dom(ib)%w(id,jd-1,kd-1)   ! q21
		       	 !fvec(7) = dom(ib)%w(id-1,jd-1,kd)   ! q12
		       	 !fvec(8) = dom(ib)%w(id,jd-1,kd)	   ! q22
		       	 nx(1) = dom(ib)%xc(id-1)
		       	 nx(2) = dom(ib)%xc(id)
		       	 nz(1) = dom(ib)%z(kd-1)
		       	 nz(2) = dom(ib)%z(kd)
		       	 !ny(1) = dom(ib)%yc(id)
			   	 !ny(2) = dom(ib)%yc(id-1)
		     elseif(fieldF.eq.4) then
             	!elseif(fieldF.eq.4) then
			 	fvec(1) = dom(ib)%p(id-1,jd,kd-1) ! q11
			 	fvec(2) = dom(ib)%p(id,jd,kd-1)   ! q21
			 	fvec(3) = dom(ib)%p(id-1,jd,kd)   ! q12
			 	fvec(4) = dom(ib)%p(id,jd,kd)	   ! q22
			 	!fvec(5) = dom(ib)%p(id-1,jd-1,kd-1) ! q11
			 	!fvec(6) = dom(ib)%p(id,jd-1,kd-1)   ! q21
			 	!fvec(7) = dom(ib)%p(id-1,jd-1,kd)   ! q12
			 	!fvec(8) = dom(ib)%p(id,jd-1,kd)	   ! q22
             	nx(1) = dom(ib)%xc(id-1)
			 	nx(2) = dom(ib)%xc(id)
			 	nz(1) = dom(ib)%zc(kd-1)
			 	nz(2) = dom(ib)%zc(kd)
			 	!ny(1) = dom(ib)%yc(id)
			 	!ny(2) = dom(ib)%yc(id-1)
             elseif(fieldF.eq.10) then
				fvec(1) = dom(ib)%dudx(id-1,jd,kd-1) ! q11
				fvec(2) = dom(ib)%dudx(id,jd,kd-1)   ! q21
				fvec(3) = dom(ib)%dudx(id-1,jd,kd)   ! q12
				fvec(4) = dom(ib)%dudx(id,jd,kd)	   ! q22
				nx(1) = dom(ib)%x(id-1)
				nx(2) = dom(ib)%x(id)
				nz(1) = dom(ib)%zc(kd-1)
				nz(2) = dom(ib)%zc(kd)
				!ny(1) = dom(ib)%yc(id)
				!ny(2) = dom(ib)%yc(id-1)
				!write(6,*) dom(ib)%dudx(id,jd,kd)
             elseif(fieldF.eq.11) then
				fvec(1) = dom(ib)%dudz(id-1,jd,kd-1) ! q11
				fvec(2) = dom(ib)%dudz(id,jd,kd-1)   ! q21
				fvec(3) = dom(ib)%dudz(id-1,jd,kd)   ! q12
				fvec(4) = dom(ib)%dudz(id,jd,kd)	   ! q22
				nx(1) = dom(ib)%x(id-1)
				nx(2) = dom(ib)%x(id)
				nz(1) = dom(ib)%zc(kd-1)
				nz(2) = dom(ib)%zc(kd)
				!ny(1) = dom(ib)%yc(id)
				!ny(2) = dom(ib)%yc(id-1)
             elseif(fieldF.eq.12) then
				fvec(1) = dom(ib)%dwdx(id-1,jd,kd-1) ! q11
				fvec(2) = dom(ib)%dwdx(id,jd,kd-1)   ! q21
				fvec(3) = dom(ib)%dwdx(id-1,jd,kd)   ! q12
				fvec(4) = dom(ib)%dwdx(id,jd,kd)	   ! q22
				nx(1) = dom(ib)%xc(id-1)
				nx(2) = dom(ib)%xc(id)
				nz(1) = dom(ib)%z(kd-1)
				nz(2) = dom(ib)%z(kd)
				!ny(1) = dom(ib)%yc(id)
				!ny(2) = dom(ib)%yc(id-1)
             elseif(fieldF.eq.13) then
				fvec(1) = dom(ib)%dwdz(id-1,jd,kd-1) ! q11
				fvec(2) = dom(ib)%dwdz(id,jd,kd-1)   ! q21
				fvec(3) = dom(ib)%dwdz(id-1,jd,kd)   ! q12
				fvec(4) = dom(ib)%dwdz(id,jd,kd)	   ! q22
				nx(1) = dom(ib)%xc(id-1)
				nx(2) = dom(ib)%xc(id)
				nz(1) = dom(ib)%z(kd-1)
				nz(2) = dom(ib)%z(kd)
				!ny(1) = dom(ib)%yc(id)
				!ny(2) = dom(ib)%yc(id-1)
            endif
	!		mirror_w = bilinear1(nn,nx,nz,fvec,mkx,mkz)
	!		if(nn.lt.127) then
	!			write(6,*) "Mirror w (Bilinear Interpolation: explicit)", nn, tx
	!		endif


			! Alternative (2nd order Least Squares & Cramer's solver)
	!		mirror_w = ls_2ndOrder_cramer(nn,nx,nz,fvec,mkx,mkz)
	!		if ( nn.lt.127 ) then
	!			write(6,*) "Mirror w (2nd order Least Squares: cramer)", nn, tx
	!		endif


			!!! LINEAR INTERPOLATION
			!mirror_w = l1(nn,nx,nz,fvec,mkx,mkz)
			!if(nn.lt.127) then
			!	write(6,*) "Mirror w (linear interpolation)",nn, tx
			!endif

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Alternative (Least Squares & Cramer's solver)
			!mirror_w = ls_cramer(nn,nx,nz,fvec,mkx,mkz)
			!if(nn.lt.127) then
			!	write(6,*) "Mirror w (Least Squares: cramer)",nn, tx
			!endif

			! Alternative: Bilinear Interpolation and Cramer's solver
			if (fieldF.eq.1)  unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			!if (fieldF.eq.2)  unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.3)  unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.4)  unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.10) unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.11) unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.12) unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.13) unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
		!	if ( nn.lt.127 ) then
		!		write(6,*) "Mirror unn (Bilinear Interpolation: cramer)", nn, unn
		!		write(6,*) fvec 
		!		write(6,*) id, jd, kd
		!		write(6,*) ndsx
		!		write(6,*) ndsz
		!		write(6,*) dom(ib)%xc(id), dom(ib)%xc(id-1)
		!		write(6,*) dom(ib)%zc(kd), dom(ib)%zc(kd-1)
		!		write(6,*) "==="
		!		write(6,*)
		!	endif
			!
			!Alternative: deltaFUnction
			if ((fieldF.ge.1).and.(fieldF.le.3)) then
			vec2(1) = nn	! Node nds(1.5)
			vec2(2) = ib 
			vec2(3) = ll
			vec2(4) = id 
			vec2(5) = jd
			vec2(6) = kd
			vec2(7) = qF
			vec2(8) = fieldF ! fieldFlag for selecting u velocity
			!
			vec3(1) = ndsx	!mrx
			vec3(2) = dom(ib)%y(jd) ! dom(ib)%yc(jd)
			vec3(3) = ndsz	!mrz
			!
			!call interpolationF(vec2,vec3,unn)
			!
			endif
			
			endif	! Ensuring processor ID matches subdomain ID???

			!!! END MASTER PROCESOR
			!endif	

			endif ! Filtering out procesors

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!!!!!!!!       FUNCTION DECLARATION       !!!!!!!!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			CONTAINS

			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Second order Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: q11, q21, q31, q41
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			!
			!
			q11 = uvec(1)  !dom(ib)%u(id-2,jjc,kd-1)
			q21 = uvec(2)  !dom(ib)%u(id-1,jjc,kd-1)
			q31 = uvec(3)  !dom(ib)%u(id  ,jjc,kd+0)
			q41 = uvec(4)  !dom(ib)%u(id+1,jjc,kd+0)
			!
			dx1 = nx(1) - mrx   !nx(1) - mrx
			dx2 = nx(2) - mrx   !nx(2) - mrx   !!!!!!!!!!!!!
			dz1 = nz(1) - mrz   !nz(1) - mrz
			dz2 = nz(2) - mrz   !nz(2) - mrz
			!
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = 0.5*dx1*dx1; a1(5,1) = 0.5*dz1*dz1
			a1(6,1) = dx1*dz1
			!
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = 0.5*dx2*dx2; a1(5,2) = 0.5*dz1*dz1 
			a1(6,2) = dx2*dz1
			!
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = 0.5*dx1*dx1; a1(5,3) = 0.5*dz2*dz2
			a1(6,3) = dx1*dz2
			!
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = 0.5*dx2*dx2; a1(5,4) = 0.5*dz2*dz2
			a1(6,4) = dx2*dz2
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			a2 = TRANSPOSE(a1)
			b1(1) =q11; b1(2) =q21
			b1(3) =q31; b1(4) =q41
			!
			b2 = 0
			a3 = 0
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			if(nn.eq.70)then
			print*,"===================== b2"
			print*,b2
			print*,"===================== a1"
			print*,a1
			print*,"===================== a3"
			print*,a3
			endif
			!
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_ux1, mirror_ux2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjj,kd)
			!	ux2 = dom(ib)%u(id+1,jjj,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = uvec(1)	!dom(ib)%u(id,jjj,kd)
			ux2 = uvec(2) 	!dom(ib)%u(id-1,jjj,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_ux1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjj,kd-1)
			!ux2 = dom(ib)%u(id+1,jjj,kd-1)

			! Alternative
			ux1 = uvec(3)	!dom(ib)%u(id,jjj,kd-1)
			ux2 = uvec(4)	!dom(ib)%u(id-1,jjj,kd-1)

			mirror_ux2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_ux1
			uz2 = mirror_ux2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)


			!######################################################################
			END FUNCTION l1
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################


!######################################################################		
			END SUBROUTINE get_f
!######################################################################

!##########################################################################
        subroutine du_dv_dw_dh_WENO(ibn)
!##########################################################################
            ! This a modified version of the subroutine rungek_convWENO defined in rungek.for
            ! This lines compute the spatial derivatives of the velocity:
            ! dudx, dudv, dudz
            ! dvdx, dvdv, dvdz
            ! dwdx, dwdv, dwdz

        use vars
        use mpi
	    use multidata
	    use imb
	    implicit none
	    integer, intent(in):: ibn
        integer :: i,j,k
        double precision :: du2dx,dv2dy,dw2dz
        double precision :: duvdx,duvdy,duwdx,duwdz,dvwdy,dvwdz
        double precision :: uijk,vijk,wijk

	!	if (myrank.eq. 0 ) then ! The control is passed down to the master processor
		if(imbinblock_loc(dom_id(ibn)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
			! markers are located

        call boundu
        call HJ_WENO_dx(1)
        call HJ_WENO_dy(1)
        call HJ_WENO_dz(1)

        !do ibn=1,nbp

           do k=dom(ibn)%ksu,dom(ibn)%keu
              do i=dom(ibn)%isu,dom(ibn)%ieu
				 do j=dom(ibn)%jsu,dom(ibn)%jeu

					if (dom(ibn)%u(i,j,k).gt.0.0) then
						dom(ibn)%dudx(i,j,k) = dom(ibn)%dphi_dxminus(i,j,k)
					else if (dom(ibn)%u(i,j,k).lt.0.0) then
						dom(ibn)%dudx(i,j,k) = dom(ibn)%dphi_dxplus(i,j,k)
					else  
						dom(ibn)%dudx(i,j,k) = 0.0  
					end if
					
					vijk=0.25*(dom(ibn)%v(i,j,k)+dom(ibn)%v(i+1,j,k)+
     &     dom(ibn)%v(i,j-1,k)+dom(ibn)%v(i+1,j-1,k))
					if (vijk.gt.0.0) then
						dom(ibn)%dudy(i,j,k) = dom(ibn)%dphi_dyminus(i,j,k)
					else if (vijk.lt.0.0) then  
						dom(ibn)%dudy(i,j,k) = dom(ibn)%dphi_dyplus(i,j,k)
					else  
						dom(ibn)%dudy(i,j,k) = 0.0   
					end if
					
					wijk=0.25*(dom(ibn)%w(i,j,k)+dom(ibn)%w(i+1,j,k)+
     &     dom(ibn)%w(i,j,k-1)+dom(ibn)%w(i+1,j,k-1))
					if (wijk.gt.0.0) then
						dom(ibn)%dudz(i,j,k) = dom(ibn)%dphi_dzminus(i,j,k)
					else if (wijk.lt.0.0) then 
						dom(ibn)%dudz(i,j,k) = dom(ibn)%dphi_dzplus(i,j,k)
					else 
						dom(ibn)%dudz(i,j,k) = 0.0    
					end if

                 !   du2dx=dom(ibn)%u(i,j,k)*dom(ibn)%dudx(i,j,k)
                 !   duvdy=vijk*dom(ibn)%dudy(i,j,k)
                 !   duwdz=wijk*dom(ibn)%dudz(i,j,k)

  !               dom(ibn)%ustar(i,j,k)=(dom(ibn)%uoo(i,j,k)-
  !   & dt*alfapr*(du2dx+duvdy+duwdz))

                 end do
              end do
           end do
        !end do

        call boundv
        call HJ_WENO_dx(2)
        call HJ_WENO_dy(2)
        call HJ_WENO_dz(2)

        !do ibn=1,nbp

!           do k=dom(ibn)%ksv,dom(ibn)%kev
!              do i=dom(ibn)%isv,dom(ibn)%iev
!				 do j=dom(ibn)%jsv,dom(ibn)%jev
!
!                    uijk=0.25*(dom(ibn)%u(i,j,k)+dom(ibn)%u(i,j+1,k)+
!     &     dom(ibn)%u(i-1,j,k)+dom(ibn)%u(i-1,j+1,k))
!                    if (uijk.gt.0.0) then
!                   dom(ibn)%dvdx(i,j,k) = dom(ibn)%dphi_dxminus(i,j,k)
!                    else if (uijk.lt.0.0) then
!                   dom(ibn)%dvdx(i,j,k) = dom(ibn)%dphi_dxplus(i,j,k)
!                    else  
!                       dom(ibn)%dvdx(i,j,k) = 0.0  
!                    end if             
!
!                    if (dom(ibn)%v(i,j,k).gt.0.0) then
!                    dom(ibn)%dvdy(i,j,k) = dom(ibn)%dphi_dyminus(i,j,k)
!                    else if (dom(ibn)%v(i,j,k).lt.0.0) then  
!                   dom(ibn)%dvdy(i,j,k) = dom(ibn)%dphi_dyplus(i,j,k)
!                    else  
!                       dom(ibn)%dvdy(i,j,k) = 0.0   
!                    end if     
!
!                    wijk=0.25*(dom(ibn)%w(i,j,k)+dom(ibn)%w(i,j+1,k)+
!     &     dom(ibn)%w(i,j,k-1)+dom(ibn)%w(i,j+1,k-1))
!                    if (wijk.gt.0.0) then
!                   dom(ibn)%dvdz(i,j,k) = dom(ibn)%dphi_dzminus(i,j,k)
!                    else if (wijk.lt.0.0) then 
!                   dom(ibn)%dvdz(i,j,k) = dom(ibn)%dphi_dzplus(i,j,k)
!                    else 
!                       dom(ibn)%dvdz(i,j,k) = 0.0    
!                    end if
!
!               !     duvdx=uijk*dom(ibn)%dvdx(i,j,k)
!               !     dv2dy=dom(ibn)%v(i,j,k)*dom(ibn)%dvdy(i,j,k)
!               !     dvwdz=wijk*dom(ibn)%dvdz(i,j,k)
!
!  !               dom(ibn)%vstar(i,j,k)=(dom(ibn)%voo(i,j,k)-
!  !   & dt*alfapr*(duvdx+dv2dy+dvwdz))
!
!                 end do
!              end do
!           end do
!        !end do
!

        call boundw
        call HJ_WENO_dx(3)
        call HJ_WENO_dy(3)
        call HJ_WENO_dz(3)

        !do ibn=1,nbp

           do k=dom(ibn)%ksw,dom(ibn)%kew
              do i=dom(ibn)%isw,dom(ibn)%iew
                 do j=dom(ibn)%jsw,dom(ibn)%jew

                    uijk=0.25*(dom(ibn)%u(i,j,k)+dom(ibn)%u(i,j,k+1)+
     &     dom(ibn)%u(i-1,j,k)+dom(ibn)%u(i-1,j,k+1))
                    if (uijk.gt.0.0) then
                    dom(ibn)%dwdx(i,j,k) = dom(ibn)%dphi_dxminus(i,j,k)
                    else if (uijk.lt.0.0) then
                   dom(ibn)%dwdx(i,j,k) = dom(ibn)%dphi_dxplus(i,j,k)
                    else  
                       dom(ibn)%dwdx(i,j,k) = 0.0  
                    end if             

                    vijk=0.25*(dom(ibn)%v(i,j,k)+dom(ibn)%v(i,j,k+1)+
     &     dom(ibn)%v(i,j-1,k)+dom(ibn)%v(i,j-1,k+1))
                    if (vijk.gt.0.0) then
                   dom(ibn)%dwdy(i,j,k) = dom(ibn)%dphi_dyminus(i,j,k)
                    else if (vijk.lt.0.0) then  
                   dom(ibn)%dwdy(i,j,k) = dom(ibn)%dphi_dyplus(i,j,k)
                    else  
                       dom(ibn)%dwdy(i,j,k) = 0.0   
                    end if     

                    if (dom(ibn)%w(i,j,k).gt.0.0) then
                   dom(ibn)%dwdz(i,j,k) = dom(ibn)%dphi_dzminus(i,j,k)
                    else if (dom(ibn)%w(i,j,k).lt.0.0) then 
                   dom(ibn)%dwdz(i,j,k) = dom(ibn)%dphi_dzplus(i,j,k)
                    else 
                       dom(ibn)%dwdz(i,j,k) = 0.0    
                    end if

                    !duwdx=uijk*dom(ibn)%dwdx(i,j,k)
                    !dvwdy=vijk*dom(ibn)%dwdy(i,j,k)
                    !dw2dz=dom(ibn)%w(i,j,k)*dom(ibn)%dwdz(i,j,k)

  !                  dom(ibn)%wstar(i,j,k)=(dom(ibn)%woo(i,j,k)-
  !   & dt*alfapr*(duwdx+dvwdy+dw2dz))  

                 end do
              end do
           end do

		!end do
		
		endif ! master processor

		return
!######################################################################
        end subroutine du_dv_dw_dh_WENO
!######################################################################

!######################################################################
      SUBROUTINE PartLoc 
!######################################################################
      use vars
      use imb
      use mpi
      use multidata
	  
	  implicit none
      
      INTEGER 	:: M,L,ii,nxdom,nydom,nzdom,tnm,N,nx,ny,nz	  
      DOUBLE PRECISION :: lxdom(idom+1),lydom(jdom+1),lzdom(kdom+1)
	DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::nodex_mas,nodey_mas
	DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::nodez_mas
	INTEGER,ALLOCATABLE,DIMENSION(:)::lag_bod_mas

	! debugging variables
	integer :: missingMarkers
	
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn, vecID,searchID
	  ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! nn : index for nodes belonging to the M-th mody	  
	  ! 
	  INTEGER :: is,ie,js,je,ks,ke,zz
	  INTEGER :: i_n_cells ,j_n_cells,k_n_cells
	  
	  ! Variables for writting to file
	  DOUBLE PRECISION :: as,bs,cs
	  DOUBLE PRECISION :: as2,bs2,cs2
	  DOUBLE PRECISION :: as3,bs3,cs3
	  DOUBLE PRECISION :: ae3,be3,ce3
	  DOUBLE PRECISION :: ae,be,ce	  
	  DOUBLE PRECISION :: cnx,cny,cnz,uc,vc,wc ! Node coordinates and cell velocity components u, v, w
	  INTEGER, ALLOCATABLE, DIMENSION(:) :: matchVec ! vector for checking if a markers has been located in more that 1 fluid cell
	  ! Boundary Margings
	  DOUBLE PRECISION:: dh, margin,dx_l,dy_l,dz_l
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  
	  
       IF(myrank.eq.master)THEN
!Variables used by the master than involve all the markers	
	allocate(lag_bod_mas(maxnodeIBS),nodex_mas(maxnodeIBS))
	allocate(nodey_mas(maxnodeIBS),nodez_mas(maxnodeIBS))
	
	lxdom=0 		; lydom=0 		; lzdom=0
	lxdom(1)=xst 	; lydom(1)=yst 	; lzdom(1)=zst
	do N=2,idom+1
	  lxdom(N)=(xcor(N-2,2)-xcor(N-2,1))+lxdom(N-1)
	enddo
	do N=2,jdom+1
	  lydom(N)=(ycor((N-2)*idom,2)-ycor((N-2)*idom,1))+lydom(N-1)
	enddo
	do N=2,kdom+1
	 lzdom(N)=
     &	 (zcor((N-2)*idom*jdom,2)-zcor((N-2)*idom*jdom,1))+lzdom(N-1)
	enddo

	 imbinblock_loc=0 ; imbinblk=0  	!# Points in each block
	 imb_block=0  				!Block id to which every particle belongs
	 ii=0  ;	tnm=0		
	 nxdom = 0; nydom = 0; nzdom = 0	! ??? Check Why this variables have not been initialized before?????
	do M=1,bodynum  			!Perform this operation to all IB bodies
	    DO L=1,nodes(M)		!Analyze all IB poins of the body.
		ii=ii+1
	  Do nx=1,idom 
	   if( (nodex(M,L)-1.d-11).gt.lxdom(nx) .and. 
     &		(nodex(M,L)-1.d-11).le.lxdom(nx+1) )THEN
		nxdom=nx-1
	 	GOTO 490
	   endif 	
	  Enddo
490	CONTINUE
	  Do ny=1,jdom 
	   if( (nodey(M,L)-1.d-11).gt.lydom(ny) .and. 
     &		(nodey(M,L)-1.d-11).le.lydom(ny+1) )THEN
		nydom=ny-1
	 	GOTO 491
	   endif 	
	  Enddo
491	CONTINUE
	  Do nz=1,kdom 
	   if( (nodez(M,L)-1.d-11).gt.lzdom(nz) .and. 
     &		(nodez(M,L)-1.d-11).le.lzdom(nz+1) )THEN
		nzdom=nz-1
	 	GOTO 492
	   endif 	
	  Enddo
492	CONTINUE
		imb_block(ii) = idom*jdom*nzdom + idom*nydom + nxdom
		imbinblk(imb_block(ii)+1)=imbinblk(imb_block(ii)+1)+1
	    ENDDO
	enddo 

	do L=1,num_domains		!Check in all the domains
	 tnm=tnm+imbinblk(L)
	 missingMarkers = maxnodeIBS - tnm
!	 write(*,*) missingMarkers
	 IF (itime.eq.itime_start .AND. imbinblk(L).ne.0)  
     &	   write(6,*)'Dom,#markrs',L-1,imbinblk(L),tnm
!     &	   write(6,*)'Dom,#markrs',L-1,imbinblk(L),tnm, maxnodeIBS  
	 imbinblock_loc(L)=imbinblk(L) !New variable for all the other MPI
	enddo



	write(*,*) tnm			! Uncomment for not having missing markers
	write(*,*) maxnodeIBS		! Uncomment for not having missing markers
!	write(*,*) missingMarkers


!Warning if some point is not assigned to some domain
	IF(tnm.lt.maxnodeIBS) THEN
!     		write(6,*)'Some Lagrangian are not assigned to a domain!!!CHECK'
		write(*,*) tnm
	ENDIF



	


  	ii=0
	 DO M=1,bodynum
	    DO L=1,nodes(M)
	      ii=ii+1
		imb_block_loc(ii)=imb_block(ii)
		lag_bod_loc(ii)=M 
	      nodex_loc(ii)=nodex(M,L) ; nodey_loc(ii)=nodey(M,L)
	      nodez_loc(ii)=nodez(M,L)

	     IF (itime.eq.itime_start) then !THIS IS DONE ONCE
		R0_loc(ii)=R0(M,L) ; alpha0_loc(ii)=alpha0(M,L)
	     ENDIF 
		rott_loc(ii)=1 	!Moving Lagrangian
		IF(rotating(M).eq..false.)rott_loc(ii)=2  	!Static Lagrangian
	  ENDDO
	 Enddo
	ENDIF !master
	
!Now the properties of the markers owned by each processor is scattered
!We can't use BCAST because then we share all the vectors (+memory)
	IF(itime.eq.itime_start) then
	  call MPI_BCAST(lag_bod_loc,maxnodeIBS,MPI_INTEGER,
     &			master,MPI_COMM_WORLD,ierr)	!# of the body to which the Lag is.
        call MPI_BCAST(alpha0_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     &			master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(R0_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     &			master,MPI_COMM_WORLD,ierr)
	ENDIF

        call MPI_BCAST(rott_loc,maxnodeIBS,MPI_INTEGER,
     &			master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(imbinblock_loc,num_domains,MPI_INTEGER,
     & 		master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(imb_block_loc,maxnodeIBS,MPI_INTEGER,
     & 		master,MPI_COMM_WORLD,ierr)
	
        call MPI_BCAST(nodex_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     & 		master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(nodey_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     &			master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(nodez_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     &			master,MPI_COMM_WORLD,ierr)

	if(myrank.eq.master) then
	 deallocate(nodex_mas,nodey_mas,nodez_mas)
	endif




      RETURN
	  
	  
      END
!######################################################################
      SUBROUTINE Deltah
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      DOUBLE PRECISION :: dh,dhtotal
      INTEGER :: I,J,L,ib,K,nnnmls
	 nnnmls=0
	IF(nnnmls.eq.0) then

	Do ib=1,nbp  !Loop through all the blocks of one processor
       if (imbinblock_loc(dom_id(ib)+1).ne.0) then !IF THERE ARE ANY POINTS IN THE BLOCK AT ALL
      Do L = 1,maxnodeIBS !investigate all the IB points
      	nl=0 ;dhtotal=0.d0
	IF(imb_block_loc(L).EQ.dom_id(ib)) THEN !If the IB point is not in the present block
	IF(rott_loc(L).eq.2) THEN	!If the Lagrangian is dynamic:exit
!NEIGHBOURS FOR THE U-GRID
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%x(i) .ge.(nodex_loc(L)-nxl*dom(ib)%dx) .AND.
     &     dom(ib)%x(i) .lt.(nodex_loc(L)+nxl*dom(ib)%dx)) THEN
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.(nodey_loc(L)-nxl*dom(ib)%dy) .AND.
     &     dom(ib)%yc(j).lt.(nodey_loc(L)+nxl*dom(ib)%dy)) THEN
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.(nodez_loc(L)-nxl*dom(ib)%dz) .AND.
     &     dom(ib)%zc(k).lt.(nodez_loc(L)+nxl*dom(ib)%dz)) THEN 
!nl indicates the number of the neighbour and dh1 the delta functions value.
	nl=nl+1
 	  dh1_loc(L,nl)=dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%X(I),dom(ib)%YC(J),dom(ib)%ZC(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase) 
!The index of the neighbours number nl to the Lagrangian L are:    
	  I_nr_U(L,nl)=I ;  J_nr_U(L,nl)=J ;  K_nr_U(L,nl)=K
	  dhtotal=dhtotal+dh1_loc(L,nl)
	  if(dhtotal.ge.0.99999) goto 876
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        dh1_loc(L,nl)=dh1_loc(L,nl)/dhtotal
876	continue       
	kmaxU(L)=nl !# of neighbours of the Lagrangian L
!NEIGHBOURS FOR THE V-GRID
      	nl=0 ;dhtotal=0.d0
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.(nodex_loc(L)-nxl*dom(ib)%dx) .AND.
     &     dom(ib)%xc(i).lt.(nodex_loc(L)+nxl*dom(ib)%dx)) THEN
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%y(j) .ge.(nodey_loc(L)-nxl*dom(ib)%dy) .AND.
     &     dom(ib)%y(j) .lt.(nodey_loc(L)+nxl*dom(ib)%dy)) THEN
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.(nodez_loc(L)-nxl*dom(ib)%dz) .AND.
     &     dom(ib)%zc(k).lt.(nodez_loc(L)+nxl*dom(ib)%dz) ) THEN 
	nl=nl+1
 	  dh2_loc(L,nl)=dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%Y(J),dom(ib)%ZC(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase)  
	 I_nr_V(L,nl)=I ;  J_nr_V(L,nl)=J ;  K_nr_V(L,nl)=K
	 dhtotal=dhtotal+dh2_loc(L,nl)
	  if(dhtotal.ge.0.99999) goto 877
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        dh2_loc(L,nl)=dh2_loc(L,nl)/dhtotal
877	continue              
	kmaxV(L)=nl 
!NEIGHBOURS FOR THE W-GRID
      	nl=0 ;dhtotal=0.d0
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.(nodex_loc(L)-nxl*dom(ib)%dx) .AND.
     &     dom(ib)%xc(i).lt.(nodex_loc(L)+nxl*dom(ib)%dx) )  THEN 
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.(nodey_loc(L)-nxl*dom(ib)%dy) .AND.
     &     dom(ib)%yc(j).lt.(nodey_loc(L)+nxl*dom(ib)%dy) )  THEN 
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%z(k) .ge.(nodez_loc(L)-nxl*dom(ib)%dz) .AND.
     &     dom(ib)%z(k) .lt.(nodez_loc(L)+nxl*dom(ib)%dz) )  THEN 
	nl=nl+1
 	  dh3_loc(L,nl)=dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%YC(J),dom(ib)%Z(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase)  
	 I_nr_W(L,nl)=I ;  J_nr_W(L,nl)=J ;  K_nr_W(L,nl)=K
	 dhtotal=dhtotal+dh3_loc(L,nl)
	  if(dhtotal.ge.0.99999) goto 878
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        dh3_loc(L,nl)=dh3_loc(L,nl)/dhtotal
878	 continue                     
	kmaxW(L)=nl 	
	ENDIF
	ENDIF
        Enddo
       ENDIF  
      ENDDO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	ELSE !MLS IS USED        
	Do ib=1,nbp  
     	if(myrank.eq.master)	 write(6,*)'Starting MLS in block#',ib
          if (imbinblock_loc(dom_id(ib)+1).eq.0) GOTO 601 !IF THERE ARE NO POINTS IN THE BLOCK
          Do L = 1,maxnodeIBS
	   IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 701 
	   IF(rott_loc(L).ne.2) GOTO 701	!Rotating
	   call ShapeFunction_MLS(1,L,ib)
	   call ShapeFunction_MLS(2,L,ib)
	   call ShapeFunction_MLS(3,L,ib)
701	CONTINUE   
        Enddo
     	if(myrank.eq.master)	 write(6,*)'Ended MLS in block #',ib
       ENDDO	!ib blocks
601	 CONTINUE
	ENDIF	 !Delta functions or MLS

	 call MPI_BARRIER(MPI_COMM_WORLD,IERR)	
!	 if(myrank.eq.master)write(6,*)'Delta functions generated'
      RETURN
	  END


!######################################################################
      SUBROUTINE interpolationF(vec2,vec3,fieldVal)
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      INTEGER :: I,J,K,L,M,ib,nt,nnmls,KK,iii
      DOUBLE PRECISION :: dh,dhtotal
	  DOUBLE PRECISION :: PI,UIB_loc,VIB_loc,WIB_loc,A1,A2,R1,R2,fbeta
	  
	  !interface variables
	  integer,intent(in):: vec2(8)
	  double precision,intent(in)::vec3(3)
	  double precision,intent(out)::fieldVal
	  integer:: St_k,mksPS,mksEL,nnFinish,nnStart
	  integer:: nn,ll,id,jd,kd,qF,fieldF,flag1
      double precision:: mrx,mry,mrz,uf,vf,wf
      

	   nn = vec2(1)	! Node nds(1.5)  	! Node nds(1.5)
	   ib = vec2(2)
	   ll = vec2(3)
	   id = vec2(4)
	   jd = vec2(5)
	   kd = vec2(6)
	   flag1 = vec2(7)
	   fieldF  = vec2(8) ! fieldFlag for selecting u velocity  ! fieldFlag for selecting u velocity
	   mrx = vec3(1)
	   mry = vec3(2)!dom(ib)%yc(jd)!vec3(2)
	   mrz = vec3(3)

	   
	U_Beta1_loc=0.d0 ; U_Beta2_loc=0.d0 ; U_Beta3_loc=0.d0	!Pablo
	!Do ib=1,nbp

	 ! if (imbinblock_loc(dom_id(ib)+1).ne.0) THEN	! cheking if there is any marker in that the current 
													! processor handling this subdomain need to take care of 

	if (maxnodeIBS.le.100) nt = 1
	if (maxnodeIBS.gt.100) nt = OMP_threads

	call OMP_SET_NUM_THREADS(nt)

	nnmls=2
	IF (nnmls.eq.1) then	! checking deltaF or mls
!!$OMP parallel DEFAULT(SHARED)PRIVATE(I,J,K,L,nl)
!!$OMP DO SCHEDULE(DYNAMIC,50)
	  !Do L = 1,maxnodeIBS
	  L = nn
	  IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 901 	! cheking processor and domain ID???
        IF(rott_loc(L).eq.1 ) then
	  call ShapeFunction_MLS(1,L,ib) !u-velocity
	  call ShapeFunction_MLS(2,L,ib) !v-velocity
	  call ShapeFunction_MLS(3,L,ib) !w-velocity
		ENDIF

		if(fieldF.eq.1) then ! interpolating only u velocities
       Do nl=1,KmaxU(L)
	  I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
        uf=uf+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)      
	   Enddo 
	  endif

	  if(fieldF.eq.2) then ! interpolating only v velocities
       Do nl=1,KmaxV(L)
        I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl) ;  K=K_nr_V(L,nl)
        vf=vf+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)
	   Enddo
	  endif

	  if(fieldF.eq.1) then ! interpolating only u velocities
       Do nl=1,KmaxW(L)
	 I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl) ;  K=K_nr_W(L,nl)
        wf=wf+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
	   Enddo
	  endif
901	 CONTINUE   
      !Enddo
!!$OMP end DO
!!$OMP END PARALLEL	

	else


!Using delta functions. Interpolation of U-velocities
!!$OMP parallel DEFAULT(SHARED)PRIVATE(I,J,K,L,nl)


	  if(fieldF.eq.1) then ! interpolating only u velocities
!!$OMP DO SCHEDULE(DYNAMIC,50)
	!  Do L = 1,maxnodeIBS	! loop sweeping markers
	L = nn
	 nl=0 
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 IF( rott_loc(L).eq.1 )then
		  DO I = 1, dom(ib)%ttc_i 
          !DO I = id-deps, id+deps 
       IF (dom(ib)%x(i) .ge.(mrx-nxl*dom(ib)%dx) .and.
     &     dom(ib)%x(i) .lt.(mrx+nxl*dom(ib)%dx)) THEN
		   DO J = 1, dom(ib)%ttc_j
           !DO J = jd-deps, jd+deps  
       IF (dom(ib)%yc(j).ge.(mry-nxl*dom(ib)%dy) .and.
     &     dom(ib)%yc(j).lt.(mry+nxl*dom(ib)%dy)) THEN
			DO K = 1, dom(ib)%ttc_k
            !DO K = kd-deps, kd+deps  
       IF (dom(ib)%zc(k).ge.(mrz-nxl*dom(ib)%dz) .and.
     &     dom(ib)%zc(k).lt.(mrz+nxl*dom(ib)%dz)) THEN 
	 nl=nl+1
        dh1_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%X(I),dom(ib)%YC(J),dom(ib)%ZC(K)
     & ,mrx,mry,mrz,yangcase)  
		 !
			uf=uf+dom(ib)%ucpy(I,J,K)*dh1_loc(L,nl)
	!	if(flag1.eq.0)then
	!		uf=uf+dom(ib)%uoo(I,J,K)*dh1_loc(L,nl)
	!		!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
	!		!if((nn.gt.0).and.(nn.lt.(0+3))) then
	!		!	write(*,*) "u field, flag1 = 0", nn, flag1,ll,id,jd,kd
	!		 !endif
	!	elseif(flag1.eq.1) then
	!		uf=uf+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)
	!!		!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
	!!		if((nn.gt.9240).and.(nn.lt.(9240+2))) then
	!!			write(*,*) "u field, flag1 = 1", nn, flag1
	!!		 endif
	!	elseif(flag1.eq.2) then
	!		uf=uf+dom(ib)%u(I,J,K)*dh1_loc(L,nl)
	!!		!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
	!!		if((nn.gt.9240).and.(nn.lt.(9240+2))) then
	!!			write(*,*) "u field, flag1 = 2", nn, flag1
	!!		 endif
	!	endif
		!
        KmaxU(L)=nl ; I_nr_U(L,nl)=I ; J_nr_U(L,nl)=J ; K_nr_U(L,nl)=K    

		if (yangcase.eq.2 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.4 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.7 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.3 .and. nl.ge.64)  GOTO 700
		if (yangcase.eq.6 .and. nl.ge.64)  GOTO 700
		if (yangcase.eq.1 .and. nl.ge.27)  GOTO 700
		if (yangcase.eq.5 .and. nl.ge.27)  GOTO 700
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
	   if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'
	   !debug
	   if (nl.eq.0) then
		St_k = ibmSt(M) ! number of station of the inmmersed body
		mksPS = ibmStMkrs(M)	! Markers per station
		mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
		nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
		nnStart = 1 + (int(St_k/2.0d00))*mksPS
	   if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
	   !if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		write(*,*) "mucx____mucx____mucx____mucx____mucx____mucx"
		write(6,*) L,'nl is equal to 0!!'
		write(6,*) vec2
		write(6,*) vec3
		write(6,*) uf
		return
	   endif
	   endif
        
	ELSE
	  Do nl=1,KmaxU(L)
	  I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
	 	!
		!if(flag1.eq.0)then
		!	uf=uf+dom(ib)%uoo(I,J,K)*dh1_loc(L,nl)
		!	if (nl.eq.0) then
		!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!		 write(*,*) "mucx____mucx____mucx____mucx____mucx____mucx"
		!		 write(6,*) L,'nl is equal to 0!!'
		!		 write(6,*) vec2
		!		 write(6,*) vec3
		!		 write(6,*) uf
		!		 return
		!		endif
		!		endif
		!elseif(flag1.eq.1) then
		!	uf=uf+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)
		!	if (nl.eq.0) then
		!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!		 write(*,*) "mucx____mucx____mucx____mucx____mucx____mucx"
		!		 write(6,*) L,'nl is equal to 0!!'
		!		 write(6,*) vec2
		!		 write(6,*) vec3
		!		 write(6,*) uf
		!		 return
		!		endif
		!		endif
		!elseif(flag1.eq.2) then
		!	uf=uf+dom(ib)%u(I,J,K)*dh1_loc(L,nl)
		!	if (nl.eq.0) then
		!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!		 write(*,*) "mucx____mucx____mucx____mucx____mucx____mucx"
		!		 write(6,*) L,'nl is equal to 0!!'
		!		 write(6,*) vec2
		!		 write(6,*) vec3
		!		 write(6,*) uf
		!		 return
		!		endif
		!		endif
		!endif
			uf=uf+dom(ib)%ucpy(I,J,K)*dh1_loc(L,nl)
			if (nl.eq.0) then
				St_k = ibmSt(M) ! number of station of the inmmersed body
				mksPS = ibmStMkrs(M)	! Markers per station
				mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				nnStart = 1 + (int(St_k/2.0d00))*mksPS
			   if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				 write(*,*) "mucx____mucx____mucx____mucx____mucx____mucx"
				 write(6,*) L,'nl is equal to 0!!'
				 write(6,*) vec2
				 write(6,*) vec3
				 write(6,*) uf
				 return
				endif
				endif
		!
  	  Enddo  	 
	 ENDIF
700 	continue
	endif
      !Enddo	! loop sweeping markers
!!$OMP END DO
	  !endif ! u velocities iterpolation

	  elseif(fieldF.eq.2) then ! interpolating only u velocities
!!$OMP DO SCHEDULE(DYNAMIC,50)
	!  Do L = 1,maxnodeIBS
	L = nn
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 nl=0 
	IF( rott_loc(L).eq.1 )then
		  DO I = 1, dom(ib)%ttc_i
		!DO I = id-deps, id+deps 
       IF (dom(ib)%xc(i).ge.(mrx-nxl*dom(ib)%dx) .and.
     &     dom(ib)%xc(i).lt.(mrx+nxl*dom(ib)%dx)) then
		   DO J = 1, dom(ib)%ttc_j 
          ! DO J = jd-deps, jd+deps  
       IF (dom(ib)%y(j) .ge.(mry-nxl*dom(ib)%dy) .and.
     &     dom(ib)%y(j) .lt.(mry+nxl*dom(ib)%dy)) then
			DO K = 1, dom(ib)%ttc_k
           ! DO K = kd-deps, kd+deps 
       IF (dom(ib)%zc(k).ge.(mrz-nxl*dom(ib)%dz) .and.
     &     dom(ib)%zc(k).lt.(mrz+nxl*dom(ib)%dz)) then 
	 nl=nl+1
        dh2_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%Y(J),dom(ib)%ZC(K)
     & ,mrx,mry,mrz,yangcase) 		!June 2015
	 	!
	 vf=vf+dom(ib)%vcpy(I,J,K)*dh2_loc(L,nl)

		!!if(flag1.eq.0)then
		!!	vf=vf+dom(ib)%voo(I,J,K)*dh2_loc(L,nl)
		!!elseif(flag1.eq.1) then
		!!	vf=vf+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)
		!!elseif(flag1.eq.2) then
		!!	vf=vf+dom(ib)%v(I,J,K)*dh2_loc(L,nl)
		!!endif
		!
        KmaxV(L)=nl ; I_nr_V(L,nl)=I ; J_nr_V(L,nl)=J ; K_nr_V(L,nl)=K

	if (yangcase.eq.2 .and. nl.ge.125) GOTO 701
	if (yangcase.eq.4 .and. nl.ge.125) GOTO 701
	if (yangcase.eq.7 .and. nl.ge.125) GOTO 701
	if (yangcase.eq.3 .and. nl.ge.64)  GOTO 701
	if (yangcase.eq.6 .and. nl.ge.64)  GOTO 701
	if (yangcase.eq.1 .and. nl.ge.27)  GOTO 701
	if (yangcase.eq.5 .and. nl.ge.27)  GOTO 701
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
       if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'     
	   if (nl.eq.0) then
			St_k = ibmSt(M) ! number of station of the inmmersed body
			mksPS = ibmStMkrs(M)	! Markers per station
			mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
			nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
			nnStart = 1 + (int(St_k/2.0d00))*mksPS
		   if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
			write(*,*) "mvcx____muvx____muvx____muvx____mvcx____mvcx"
			write(6,*) L,'nl is equal to 0!!'
			write(6,*) vec2
			write(6,*) vec3
			write(6,*) vf
			return
		   endif
		   endif
	ELSE
	 Do nl=1,KmaxV(L)
	  I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl) ;  K=K_nr_V(L,nl)
	 vf=vf+dom(ib)%vcpy(I,J,K)*dh2_loc(L,nl)
	 if (nl.eq.0) then
		  St_k = ibmSt(M) ! number of station of the inmmersed body
		  mksPS = ibmStMkrs(M)	! Markers per station
		  mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
		  nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
		  nnStart = 1 + (int(St_k/2.0d00))*mksPS
		 if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
		  write(*,*) "mvcx____muvx____muvx____muvx____mvcx____mvcx"
		  write(6,*) L,'nl is equal to 0!!'
		  write(6,*) vec2
		  write(6,*) vec3
		  write(6,*) vf
		  return
		 endif
		 endif
	 	!
		!!if(flag1.eq.0)then
		!!	vf=vf+dom(ib)%voo(I,J,K)*dh2_loc(L,nl)
		!!elseif(flag1.eq.1) then
		!!	vf=vf+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)
		!!elseif(flag1.eq.2) then
		!!	vf=vf+dom(ib)%v(I,J,K)*dh2_loc(L,nl)
		!!endif
		!
  	 Enddo
	ENDIF
701	continue
	endif
      !Enddo
!!$OMP END DO
	  !endif ! v velocities interpolation

	  elseif(fieldF.eq.3) then ! interpolating only u velocities
!!!$OMP DO SCHEDULE(DYNAMIC,50)
	!  Do L = 1,maxnodeIBS
	L = nn
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 nl=0 
	IF( rott_loc(L).eq.1 )then
		  DO I = 1, dom(ib)%ttc_i
		!DO I = id-deps, id+deps 
       IF (dom(ib)%xc(i).ge.(mrx-nxl*dom(ib)%dx) .and.
     &     dom(ib)%xc(i).lt.(mrx+nxl*dom(ib)%dx)) then 
		   DO J = 1, dom(ib)%ttc_j
           !DO J = jd-deps, jd+deps  
       IF (dom(ib)%yc(j).ge.(mry-nxl*dom(ib)%dy) .and.
     &     dom(ib)%yc(j).lt.(mry+nxl*dom(ib)%dy)) then
			DO K = 1, dom(ib)%ttc_k
            !DO K = kd-deps, kd+deps 
       IF (dom(ib)%z(k) .ge.(mrz-nxl*dom(ib)%dz) .and.
     &     dom(ib)%z(k) .lt.(mrz+nxl*dom(ib)%dz)) then
	 nl=nl+1
        dh3_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%YC(J),dom(ib)%Z(K)
     & ,mrx,mry,mrz,yangcase)  		!June 2015
		 !
			wf=wf+dom(ib)%wcpy(I,J,K)*dh3_loc(L,nl)
			if (nl.eq.0) then
				St_k = ibmSt(M) ! number of station of the inmmersed body
				mksPS = ibmStMkrs(M)	! Markers per station
				mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				nnStart = 1 + (int(St_k/2.0d00))*mksPS
			   if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
				 write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
				 write(6,*) L,'nl is equal to 0!!'
				 write(6,*) vec2
				 write(6,*) vec3
				 write(6,*) wf
				 return
				endif
			endif
		!if(flag1.eq.0)then
		!	wf=wf+dom(ib)%wcpy(I,J,K)*dh3_loc(L,nl)
		!	if (nl.eq.0) then
		!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!		 write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
		!		 write(6,*) L,'nl is equal to 0!!'
		!		 write(6,*) vec2
		!		 write(6,*) vec3
		!		 write(6,*) wf
		!		 return
		!		endif
		!		endif
		!elseif(flag1.eq.1) then
		!	wf=wf+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
		!	if (nl.eq.0) then
		!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!		 write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
		!		 write(6,*) L,'nl is equal to 0!!'
		!		 write(6,*) vec2
		!		 write(6,*) vec3
		!		 write(6,*) wf
		!		 return
		!		endif
		!		endif
		!elseif(flag1.eq.2) then
		!	wf=wf+dom(ib)%w(I,J,K)*dh3_loc(L,nl)
		!	if (nl.eq.0) then
		!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!		 write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
		!		 write(6,*) L,'nl is equal to 0!!'
		!		 write(6,*) vec2
		!		 write(6,*) vec3
		!		 write(6,*) wf
		!		 return
		!		endif
		!		endif
		!endif
	!	!
        KmaxW(L)=nl ;  I_nr_W(L,nl)=I ; J_nr_W(L,nl)=J ; K_nr_W(L,nl)=K

	if (yangcase.eq.2 .and. nl.ge.125) GOTO 702		!March 2016
	if (yangcase.eq.4 .and. nl.ge.125) GOTO 702
	if (yangcase.eq.7 .and. nl.ge.125) GOTO 702
	if (yangcase.eq.3 .and. nl.ge.64)  GOTO 702
	if (yangcase.eq.6 .and. nl.ge.64)  GOTO 702
	if (yangcase.eq.1 .and. nl.ge.27)  GOTO 702
	if (yangcase.eq.5 .and. nl.ge.27)  GOTO 702
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'
       ELSE
	  Do nl=1,KmaxW(L)
	  I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl) ;  K=K_nr_W(L,nl)
	! 	!
			wf=wf+dom(ib)%wcpy(I,J,K)*dh3_loc(L,nl)
			if (nl.eq.0) then
				St_k = ibmSt(M) ! number of station of the inmmersed body
				mksPS = ibmStMkrs(M)	! Markers per station
				mksEL = ibmMkrsEL(M)	! markers in exterior layer of each stations
				nnFinish = mksEL + (int(St_k/2.0d00))*mksPS
				nnStart = 1 + (int(St_k/2.0d00))*mksPS
			   if( (nn.ge.nnStart).and.(nn.le.nnFinish) ) then
				!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
				 write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
				 write(6,*) L,'nl is equal to 0!!'
				 write(6,*) vec2
				 write(6,*) vec3
				 write(6,*) wf
				 return
				endif
			endif
		!if(flag1.eq.0)then
		!	wf=wf+dom(ib)%woo(I,J,K)*dh3_loc(L,nl)
		!	if (nl.eq.0) then
		!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!		 write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
		!		 write(6,*) L,'nl is equal to 0!!'
		!		 write(6,*) vec2
		!		 write(6,*) vec3
		!		 write(6,*) wf
		!		 return
		!		endif
		!		endif
		!elseif(flag1.eq.1) then
		!	wf=wf+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
		!	if (nl.eq.0) then
		!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!		 write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
		!		 write(6,*) L,'nl is equal to 0!!'
		!		 write(6,*) vec2
		!		 write(6,*) vec3
		!		 write(6,*) wf
		!		 return
		!		endif
		!		endif
		!elseif(flag1.eq.2) then
		!	wf=wf+dom(ib)%w(I,J,K)*dh3_loc(L,nl)
		!	if (nl.eq.0) then
		!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!		 write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
		!		 write(6,*) L,'nl is equal to 0!!'
		!		 write(6,*) vec2
		!		 write(6,*) vec3
		!		 write(6,*) wf
		!		 return
		!		endif
		!		endif
		!endif
	!	!
  	  Enddo
	 ENDIF
702	continue
	endif
      !Enddo
!!!$OMP end DO
	endif ! w velocities interpolation

!!$OMP END PARALLEL	
	  endif	! checking deltaF or mls
	 !ENDIF	! cheking if there is any marker in that the current 
			! processor handling this subdomain need to take care of 
    !Enddo !ib-loop
     
		if(fieldF.eq.1) then
			fieldVal = uf
		elseif(fieldF.eq.2) then
			fieldVal = vf
		elseif(fieldF.eq.3) then
			fieldVal = wf
		endif
		!debug
		!if((nn.gt.9289).and.(nn.lt.9310)) then
			!write(6,*) qF, fieldF, fieldVal
			!write(6,*) vec2(1),vec2(2),vec2(3)
			!write(6,*) vec2(4),vec2(5),vec2(6)
			!write(6,*) vec2(7),vec2(8)
			!write(6,*) vec3(1),vec3(2),vec3(3)
			!write(6,*) "======================="
		!endif
  
     
!######################################################################
	  END SUBROUTINE interpolationF	!imb_openmp
!######################################################################



!######################################################################
      SUBROUTINE imb_openmp
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      INTEGER :: I,J,K,L,M,ib,nt,nnmls,KK,iii
      DOUBLE PRECISION :: dh,dhtotal
      DOUBLE PRECISION :: PI,UIB_loc,VIB_loc,WIB_loc,A1,A2,R1,R2,fbeta

	U_Beta1_loc=0.d0 ; U_Beta2_loc=0.d0 ; U_Beta3_loc=0.d0	!Pablo
	Do ib=1,nbp

      if (imbinblock_loc(dom_id(ib)+1).ne.0) THEN

	if (maxnodeIBS.le.100) nt = 1
	if (maxnodeIBS.gt.100) nt = OMP_threads

	call OMP_SET_NUM_THREADS(nt)

	nnmls=2
	IF (nnmls.eq.1) then
!$OMP parallel DEFAULT(SHARED)PRIVATE(I,J,K,L,nl)
!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	  IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 901 
        IF(rott_loc(L).eq.1 ) then
	  call ShapeFunction_MLS(1,L,ib) !u-velocity
	  call ShapeFunction_MLS(2,L,ib) !v-velocity
	  call ShapeFunction_MLS(3,L,ib) !w-velocity
        ENDIF
       Do nl=1,KmaxU(L)
	  I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
        U_Beta1_loc(L)=U_Beta1_loc(L)+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)      
       Enddo 
       Do nl=1,KmaxV(L)
        I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl) ;  K=K_nr_V(L,nl)
        U_Beta2_loc(L)=U_Beta2_loc(L)+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)
       Enddo
       Do nl=1,KmaxW(L)
	 I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl) ;  K=K_nr_W(L,nl)
        U_Beta3_loc(L)=U_Beta3_loc(L)+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
       Enddo
901	 CONTINUE   
      Enddo
!$OMP end DO
!$OMP END PARALLEL	

	else


!Using delta functions. Interpolation of U-velocities
!$OMP parallel DEFAULT(SHARED)PRIVATE(I,J,K,L,nl)

!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	 nl=0 
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 IF( rott_loc(L).eq.1 )then
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%x(i) .ge.(nodex_loc(L)-nxl*dom(ib)%dx) .and.
     &     dom(ib)%x(i) .lt.(nodex_loc(L)+nxl*dom(ib)%dx)) THEN
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.(nodey_loc(L)-nxl*dom(ib)%dy) .and.
     &     dom(ib)%yc(j).lt.(nodey_loc(L)+nxl*dom(ib)%dy)) THEN
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.(nodez_loc(L)-nxl*dom(ib)%dz) .and.
     &     dom(ib)%zc(k).lt.(nodez_loc(L)+nxl*dom(ib)%dz)) THEN 
	 nl=nl+1
        dh1_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%X(I),dom(ib)%YC(J),dom(ib)%ZC(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase)  
        U_Beta1_loc(L)=U_Beta1_loc(L)+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)     
        KmaxU(L)=nl ; I_nr_U(L,nl)=I ; J_nr_U(L,nl)=J ; K_nr_U(L,nl)=K    

		if (yangcase.eq.2 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.4 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.7 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.3 .and. nl.ge.64)  GOTO 700
		if (yangcase.eq.6 .and. nl.ge.64)  GOTO 700
		if (yangcase.eq.1 .and. nl.ge.27)  GOTO 700
		if (yangcase.eq.5 .and. nl.ge.27)  GOTO 700
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
       if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'
        
	ELSE
	  Do nl=1,KmaxU(L)
	  I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
        U_Beta1_loc(L)=U_Beta1_loc(L)+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)       
  	  Enddo  	 
	 ENDIF
700 	continue
	endif
      Enddo
!$OMP END DO

!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 nl=0 
	IF( rott_loc(L).eq.1 )then
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.(nodex_loc(L)-nxl*dom(ib)%dx) .and.
     &     dom(ib)%xc(i).lt.(nodex_loc(L)+nxl*dom(ib)%dx)) then
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%y(j) .ge.(nodey_loc(L)-nxl*dom(ib)%dy) .and.
     &     dom(ib)%y(j) .lt.(nodey_loc(L)+nxl*dom(ib)%dy)) then
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.(nodez_loc(L)-nxl*dom(ib)%dz) .and.
     &     dom(ib)%zc(k).lt.(nodez_loc(L)+nxl*dom(ib)%dz)) then 
	 nl=nl+1
        dh2_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%Y(J),dom(ib)%ZC(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase) 		!June 2015
        U_Beta2_loc(L)=U_Beta2_loc(L)+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)         
        KmaxV(L)=nl ; I_nr_V(L,nl)=I ; J_nr_V(L,nl)=J ; K_nr_V(L,nl)=K

	if (yangcase.eq.2 .and. nl.ge.125) GOTO 701
	if (yangcase.eq.4 .and. nl.ge.125) GOTO 701
	if (yangcase.eq.7 .and. nl.ge.125) GOTO 701
	if (yangcase.eq.3 .and. nl.ge.64)  GOTO 701
	if (yangcase.eq.6 .and. nl.ge.64)  GOTO 701
	if (yangcase.eq.1 .and. nl.ge.27)  GOTO 701
	if (yangcase.eq.5 .and. nl.ge.27)  GOTO 701
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
       if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'         
	ELSE
	 Do nl=1,KmaxV(L)
	  I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl) ;  K=K_nr_V(L,nl)
        U_Beta2_loc(L)=U_Beta2_loc(L)+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)
  	 Enddo
	ENDIF
701	continue
	endif
      Enddo
!$OMP END DO
!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 nl=0 
	IF( rott_loc(L).eq.1 )then
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.(nodex_loc(L)-nxl*dom(ib)%dx) .and.
     &     dom(ib)%xc(i).lt.(nodex_loc(L)+nxl*dom(ib)%dx)) then 
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.(nodey_loc(L)-nxl*dom(ib)%dy) .and.
     &     dom(ib)%yc(j).lt.(nodey_loc(L)+nxl*dom(ib)%dy)) then
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%z(k) .ge.(nodez_loc(L)-nxl*dom(ib)%dz) .and.
     &     dom(ib)%z(k) .lt.(nodez_loc(L)+nxl*dom(ib)%dz)) then
	 nl=nl+1
        dh3_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%YC(J),dom(ib)%Z(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase)  		!June 2015
        U_Beta3_loc(L)=U_Beta3_loc(L)+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
        KmaxW(L)=nl ;  I_nr_W(L,nl)=I ; J_nr_W(L,nl)=J ; K_nr_W(L,nl)=K

	if (yangcase.eq.2 .and. nl.ge.125) GOTO 702		!March 2016
	if (yangcase.eq.4 .and. nl.ge.125) GOTO 702
	if (yangcase.eq.7 .and. nl.ge.125) GOTO 702
	if (yangcase.eq.3 .and. nl.ge.64)  GOTO 702
	if (yangcase.eq.6 .and. nl.ge.64)  GOTO 702
	if (yangcase.eq.1 .and. nl.ge.27)  GOTO 702
	if (yangcase.eq.5 .and. nl.ge.27)  GOTO 702
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'
       ELSE
	  Do nl=1,KmaxW(L)
	  I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl) ;  K=K_nr_W(L,nl)
        U_Beta3_loc(L)=U_Beta3_loc(L)+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
  	  Enddo
	 ENDIF
702	continue
	endif
      Enddo
!$OMP end DO
!$OMP END PARALLEL	
	  endif
	 ENDIF
	Enddo !ib-loop
!#################   SUBROUTINE calfl   #################################
	 FX1_loc = 0.d0     ; FX2_loc = 0.d0	; FX3_loc = 0.d0
 
	DO ib=1,nbp
	IF (imbinblock_loc(dom_id(ib)+1).NE.0) THEN !No points within the block

!$OMP parallel DEFAULT(SHARED)PRIVATE(L)
!$OMP DO SCHEDULE(DYNAMIC,50)
        Do L = 1,maxnodeIBS
	  IF(imb_block_loc(L).EQ.dom_id(ib)) THEN              !REMOVE GOTO
	   UIB_loc = 0.d0; VIB_loc = 0.d0; WIB_loc = 0.d0
		M=lag_bod_loc(L) 

 	  IF (imb_shape(M).eq.5 .and. turax(M).eq.3) THEN	!Pablo 09/2017
		call ActuatorLine(M,L,ib)
	  ELSE
	   IF(ibturbine(M).eq..TRUE.) then 			!If it is a turbine
	    IF (turax(M).eq.1) then			! Vertical Axis Turbine
	      UIB_loc=-radsin(M)*R0_loc(L)*dcos(rads(M)+alpha0_loc(L))
	      VIB_loc=-radsin(M)*R0_loc(L)*dsin(rads(M)+alpha0_loc(L))
	      WIB_loc= 0.d0	
	    ENDIF	     
	    IF (turax(M).eq.2) then 		! Horizontal Axis Turbine
	      UIB_loc= 0.d0			
	      VIB_loc= radsin(M)*R0_loc(L)*dcos(rads(M)+alpha0_loc(L))
	      WIB_loc=-radsin(M)*R0_loc(L)*dsin(rads(M)+alpha0_loc(L))
	    ENDIF	     
	   ENDIF
	    IF (ibturbine(M).eq..FALSE. .AND. imb_shape(M).eq.5
     &			.and. rotating(M).eq..true.) then	! from file but moving
!	      UIB_loc=-radsin(M)*R0_loc(L)*dcos(rads(M)+alpha0_loc(L)) !Pitching airfoil simu
!	      VIB_loc=-radsin(M)*R0_loc(L)*dsin(rads(M)+alpha0_loc(L))
!	      WIB_loc= 0.d0	
!		A1=-radsin(M)*3.1416D0/180.D0*DSIN(0.1983*(CTIME-dt))
!		A2=-radsin(M)*3.1416D0/180.D0*DSIN(0.1983*CTIME)
		R1=R0_loc(L)*DSIN(A1+alpha0_loc(L))
		R2=R0_loc(L)*DSIN(A2+alpha0_loc(L))
		UIB_loc=(R2-R1)/dt

		R1=R0_loc(L)*DCOS(A1+alpha0_loc(L))
		R2=R0_loc(L)*DCOS(A2+alpha0_loc(L))
		VIB_loc=(R2-R1)/dt
		WIB_loc=0.D0
	    ENDIF

        FX1_loc(L)=UIB_loc-U_Beta1_loc(L)	! 
        FX2_loc(L)=VIB_loc-U_Beta2_loc(L)
        FX3_loc(L)=WIB_loc-U_Beta3_loc(L)  
	
	endif!actuator line

	   ENDIF
	  ENDDO  
!$OMP end DO
!$OMP END PARALLEL
                         
	ENDIF
       Enddo !ib-loop	

!Accumulate the forces as MDF can be performed
	   Do L=1,maxnodeIBS
	    FX1NF(L)=FX1_loc(L)+FX1NF(L)
	    FX2NF(L)=FX2_loc(L)+FX2NF(L)
	    FX3NF(L)=FX3_loc(L)+FX3NF(L)
	   ENDDO
!!################   SUBROUTINE distfbeta   ###################
	Do ib=1,nbp
       if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN
!$OMP parallel DEFAULT(SHARED)PRIVATE(L)
!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	IF(imb_block_loc(L).EQ.dom_id(ib)) THEN      !REMOVE GOTO
	 Do nl=1,KmaxU(L)
          I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
          fbeta = FX1_loc(L)*dh1_loc(L,nl)*reddelta(lag_bod_loc(L))    
          dom(ib)%USTAR(I,J,K) = dom(ib)%USTAR(I,J,K) + fbeta 
  	 Enddo	
	 Do nl=1,KmaxV(L)
	   I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl);  K=K_nr_V(L,nl)
          fbeta = FX2_loc(L)*dh2_loc(L,nl)*reddelta(lag_bod_loc(L))   
          dom(ib)%VSTAR(I,J,K) = dom(ib)%VSTAR(I,J,K) + fbeta
  	 Enddo
	 Do nl=1,KmaxW(L)
	   I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl);  K=K_nr_W(L,nl)
          fbeta = FX3_loc(L)*dh3_loc(L,nl)*reddelta(lag_bod_loc(L))      
          dom(ib)%WSTAR(I,J,K) = dom(ib)%WSTAR(I,J,K) + fbeta
  	 Enddo
	ENDIF
      End do 
!$OMP end DO
!$OMP END PARALLEL
	ENDIF
	Enddo !ib-loop 
	
      RETURN
      END
!######################################################################
      SUBROUTINE caldrag
!######################################################################
	use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER :: N,M,L,j,iii,inipts,finpts,totalpoints
      DOUBLE PRECISION::PI,fx_loc,fy_loc,fz_loc,alpharads
      DOUBLE PRECISION::ft_loc,fn_loc,ft2_loc,fn2_loc,M_loc
      DOUBLE PRECISION::sumvel,l1normU,l1normV
	DOUBLE PRECISION,allocatable,dimension(:)::FX1_mas,FX2_mas
	DOUBLE PRECISION,allocatable,dimension(:)::FX3_mas

      allocate (FX1_mas(maxnodeIBS))
      allocate (FX2_mas(maxnodeIBS))
      allocate (FX3_mas(maxnodeIBS))
	FX1_mas =0.d0 ; FX2_mas =0.d0 ; FX3_mas =0.d0 
	FX1_loc =0.d0 ; FX2_loc =0.d0 ; FX3_loc =0.d0 
        
      PI = 4.D0*DATAN(1.D0)
! To gather the forces ordered by the marker global index L
! the forces calculated by the masters are sent to the MASTER PROC
	   Do L=1,maxnodeIBS
	    FX1_loc(L)=FX1NF(L) ;FX2_loc(L)=FX2NF(L) ; FX3_loc(L)=FX3NF(L)
	   ENDDO
        call MPI_ALLREDUCE (FX1_loc,FX1_mas,maxnodeIBS,
     &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
        call MPI_ALLREDUCE (FX2_loc,FX2_mas,maxnodeIBS,
     &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
        call MPI_ALLREDUCE (FX3_loc,FX3_mas,maxnodeIBS,
     &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!Now the forces are transmitted, the resultants are calcualted by the MASTER
	IF (Myrank.EQ.master) THEN
	 FX1=0.d0;FX2=0.d0;FX3=0.d0 
	N=0 
	Do M=1,bodynum
	 Do L=1,nodes(M)
	  N=N+1
	  FX1(M,L)=FX1_mas(N) ; FX2(M,L)=FX2_mas(N) ; FX3(M,L)=FX3_mas(N)
	 enddo
	enddo

	J=0
	Do M = 1,bodynum
	IF (imb_shape(M).eq.5 .and. rotating(M).eq..true.) then
	  Do iii=1,imbnumber(M)
		J=J+1 ; forcefilej=399+J    
 	  fx_loc = 0.d0   ; fy_loc = 0.d0 ; fz_loc = 0.d0 
	  ft_loc = 0.d0	; fn_loc = 0.d0 ; ft2_loc = 0.d0 ; fn2_loc = 0.d0
	  totalpoints=nodes(M)/imbnumber(M)
	  inipts=(iii-1)*totalpoints+1 
	  finpts=iii*totalpoints
	  alpharads= (rads(M)+(iii-1)*2.*PI/imbnumber(M))*180.d0/PI
!!!!!
	if (turax(M).eq.2) then !HATT
	 do L=1,nodes(M)
	  fx_loc=fx_loc+FX1(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt	
	  fy_loc=fy_loc+FX2(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt 	
	  fz_loc=fz_loc+FX3(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt
	  ft_loc=ft_loc+(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &   	FX3(M,L)*dsin(rads(M)+alpha0(M,L)))*R0(M,L)/dt
     &  	*dxm*dym*dzm*reddelta(lag_bod_loc(L)) 	
	 end do
       write(forcefilej,88)alpharads,fx_loc,fy_loc,fz_loc,ft_loc
!!!!!
	ELSE IF (turax(M).eq.1) then 	!VATT
	M_loc=0.d0
	 do L=inipts,finpts
	  fx_loc=fx_loc+FX1(M,L)*dxm*dym*dzm/dt!*reddelta(lag_bod_loc(L))
	  fy_loc=fy_loc+FX2(M,L)*dxm*dym*dzm/dt  	
!	  fz_loc = fz_loc+FX3(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt
	  ft_loc=ft_loc+(FX1(M,L)*dcos(rads(M)+alpha0(M,L))+
     &     FX2(M,L)*dsin(rads(M)+alpha0(M,L)))*R0(M,L)/dt*dxm*dym*dzm
	  ft2_loc=ft2_loc+(FX1(M,L)*dcos(rads(M)+alpha0(M,L))-
     &     FX2(M,L)*dsin(rads(M)+alpha0(M,L)))*R0(M,L)/dt*dxm*dym*dzm
	  fn_loc=fn_loc+(FX1(M,L)*dsin(rads(M)+alpha0(M,L))+
     &     FX2(M,L)*dcos(rads(M)+alpha0(M,L)))/dt*dxm*dym*dzm
	  fn2_loc=fn2_loc+(FX1(M,L)*dsin(rads(M)+alpha0(M,L))-
     &     FX2(M,L)*dcos(rads(M)+alpha0(M,L)))/dt*dxm*dym*dzm
	   M_loc=M_loc+
     &     (FX1(M,L)*(R0(M,L)*dcos(alpha0(M,L))-
     &                R(M)*dcos(rads(M)+(iii-1)*2.*PI/imbnumber(M)))+
     &      FX2(M,L)*(R0(M,L)*dsin(alpha0(M,L))-
     &                R(M)*dsin(rads(M)+(iii-1)*2.*PI/imbnumber(M))))
     &	/dt*dxm*dym*dzm
	 end do

	If(LSELFST(M).eq..true.) SUMtorque_ST(M) = SUMtorque_ST(M)+ ft_loc !Self-starting 07_2017

         write(forcefilej,88)alpharads,fx_loc,fy_loc
     &	,ft_loc,ft2_loc,fn_loc,fn2_loc,M_loc
	ENDIF

	  Enddo !iii-loop

!!!!! Actuator line - Pablo 09/2017
	IF (turax(M).eq.3) then 	!AL
		fx_loc = 0.d0   ; ft_loc = 0.d0 ;forcefilej=400   
	  	alpharads=rads(M)*180.d0/PI 
	 do L=1,nodes(M)
	  fx_loc=fx_loc+ FX1(M,L)*dzm*c_act(L)	
	  ft_loc=ft_loc+(FX2(M,L)*dcos(rads(M)+alpha0(M,L))
     &    		    -FX3(M,L)*dsin(rads(M)+alpha0(M,L)))
     &  		    *R0(M,L)*dzm*c_act(L)
	 end do
	call ActuatorLine_FEM(M)
!For the AL plot the coefficients of thrust and power:
       write(forcefilej,88)alpharads
     &  ,2.d0*fx_loc/(PI*0.135**2*ubulk**2)
     &  ,2.d0*ft_loc*radsin(M)/(PI*0.135**2*ubulk**3)
       write(6,88)alpharads,2.d0*fx_loc/(PI*0.135**2*ubulk**2)
     &  ,2.d0*ft_loc*radsin(M)/(PI*0.135**2*ubulk**3)
	ENDIF
!!!!!
	ELSE
  	  fx_loc = 0.d0   ; fy_loc = 0.d0 ; fz_loc = 0.d0 
	  J=J+1 ;	 forcefilej=399+J    
	  do L=1,nodes(M)	
	   fx_loc=fx_loc+FX1(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt	
	   fy_loc=fy_loc+FX2(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt 	
	   fz_loc=fz_loc+FX3(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt
	  end do
         write(forcefilej,88) CTIME,fx_loc,fy_loc,fz_loc
	ENDIF

       End do !M loop

!l2-norm is calculated in reference to the final velocitiy field
	sumvel=0.d0 ; l1normU=0.d0 ; l1normV=0.d0 ; l2norm=0.d0
	DO M=1,bodynum
	 Do L=1,nodes(M)
    	   sumvel=sumvel+(FX1(M,L)**2+FX2(M,L)**2+FX3(M,L)**2)
	   l1normU=l1normU+(ABS(FX1(M,L)))!+ABS(FX2(M,L)+ABS(FX3(M,L))
	   l1normV=l1normV+(ABS(FX2(M,L)))!+ABS(FX2(M,L)+ABS(FX3(M,L))
 	 End Do
	 l2norm(M)=DSQRT(sumvel/nodes(M)) 
	 l1normU=l1normU/nodes(M)	;  l1normV=l1normV/nodes(M)
	End do
	 if(bodynum.eq.1) write(757,'(4F20.7)')
     &       CTIME,l2norm(1),l1normU,l1normV
	 if(bodynum.ge.2) write(757,'(3F20.7)')CTIME,l2norm(1),l2norm(2)

	ENDIF !master

	deallocate (FX1_mas,FX2_mas,FX3_mas)

   88 FORMAT (14f15.7)
   98 FORMAT (14E15.7)
      RETURN
      END SUBROUTINE caldrag
!#############################################################
      SUBROUTINE imb_pressure
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER      :: ib,M,L,I,J,K,strlen,strlen2,Geom_Time1    
      CHARACTER*8  :: char_block,ibnum
      CHARACTER*31 :: gridfile1

	IF (myrank.eq.master) then

	Do M=1,bodynum
	
	IF (rotating(M).eq..TRUE.) then
         write(ibnum,'(I2)') M
           strlen2=LEN(TRIM(ADJUSTL(ibnum)))
           ibnum=REPEAT('0',(2-strlen2))//TRIM(ADJUSTL(ibnum))
           write(char_block,'(I6)') itime
           strlen=LEN(TRIM(ADJUSTL(char_block)))
           char_block=REPEAT('0',(6-strlen))//TRIM(ADJUSTL(char_block))
           gridfile1='PnFint_'//TRIM(ADJUSTL(char_block))//
     &	   '_'//TRIM(ADJUSTL(ibnum))//'.plt'
         open (unit=Geom_Time1, file=gridfile1)
	   write(Geom_Time1,*)'TITLE = "Forces at IB body"'
	   write(Geom_Time1,*)'VARIABLES=x,y,z,Fx,Fy,Fz'
	   write(Geom_Time1,*)'zone i= ',nodes(M),'DATAPACKING = POINT'
	  do L=1,nodes(M)
	   write (Geom_Time1,89) nodex(M,L),nodey(M,L),nodez(M,L),
     &  FX1(M,L)*dxm*dym*dzm*reddelta(M)/dt*1000.d0,
     &  FX2(M,L)*dxm*dym*dzm*reddelta(M)/dt*1000.d0,
     &  FX3(M,L)*dxm*dym*dzm*reddelta(M)/dt*1000.d0
	  enddo
	 close(Geom_Time1)
	
	ENDIF !rotating

	Enddo !M

	ENDIF

   89 FORMAT (17e14.5)
        RETURN
		END SUBROUTINE	
!#############################################################
      SUBROUTINE ghostCell_forces
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER      :: ib,M,L,I,J,K,strlen,strlen2,Geom_Time1   
      INTEGER:: filegh 
      DOUBLE PRECISION:: f1(3),pf1(3),shf1(3)
      CHARACTER*8  :: char_block,ibnum
      CHARACTER*31 :: gridfile2, gridfile
!  call MPI_ALLREDUCE (f1,3,
! &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
!  call MPI_ALLREDUCE (pf1,3,
! &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
!  call MPI_ALLREDUCE (shf1,3,
! &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
      do ib = 1, nbp
       if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN
           IF(imb_block_loc(1).eq.dom_id(ib)) then
       !IF (myrank.eq.master) then ! The master procesor takes controls
	   !
        ! File for keeping track of the forces at play in the ghost cell method
        gridfile = 'F_gh_'//TRIM(ADJUSTL('01'))//'.dat'
        filegh = 31
		open (unit=filegh, file=gridfile)
		if (itime.eq.itime_start) then
			write (filegh,*)'Variables=CTIME,Fx,Fy,Fz'
		endif
        !
        ! obtaining pressure force around the body
        call pressureProbe(pf1)
        call shearStressProbe(shf1)
       ! call pressureProbe(p1)
       ! call shearStressProbe(sh1)
		!
		!
		!
      f1(1) = pf1(1) + shf1(1)
      f1(2) = pf1(2) + shf1(2)
      f1(3) = pf1(3) + shf1(3)
      write(filegh,87) CTIME,f1(1),f1(2),f1(3),
     & 		pf1(1),pf1(2),pf1(3),shf1(1),shf1(2),shf1(3)
      		!
     		!tf1(1) = p1(1) + sh1(1)
     		!tf1(2) = p1(2) + sh1(2)
     		!tf1(3) = p1(3) + sh1(3)
     		!write(filegh,87) CTIME,tf1(1),tf1(2),tf1(3),
     		!& p1(1),p1(2),p1(3),sh1(1),sh1(2),sh1(3)
          endif
       endif
      enddo
!ENDIF ! End master processor

! csv format
87      format(1x, *(g0, ",")) 
      RETURN
!#############################################################
		END SUBROUTINE	
!#############################################################

!######################################################################
      SUBROUTINE imb_FEM
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER          :: M,L,K,numblades  
      DOUBLE PRECISION :: dh,alpharads,PI,x1,x2,x3,Rhub
      DOUBLE PRECISION :: Mxtot(3),Mqtot(3),Mzytot(3),Mzxtot(3)
	DOUBLE PRECISION,allocatable,dimension(:)::Mx,Mq,Tx,Tq
	DOUBLE PRECISION,allocatable,dimension(:)::R0_x,R0_y,R0_z

	IF (myrank.eq.master) then
      PI = 4.D0*DATAN(1.D0)
	Do M=1,1!bodynum
	 numblades=3
	  if(itime.eq.itime_start+1) then
         open (unit=1414, file='FEM_1.dat')
	   write(1414,*)'TITLE = "Forces at IB. Fx(kN), Mom (Nm)"'
	   write(1414,*)'VARIABLES=Deg,X1,X2,X3',
     &  ',BR1,BR2,BR3,BT1,BT2,BT3,TX1,TX2,TX3,TQ1,TQ2,TQ3'
	  endif

!Distances of each marker
	 allocate(R0_y(nodes(M)),R0_z(nodes(M)),R0_x(nodes(M)))
	   Rhub=0.0475d0 ; R0_x=0.d0 ; R0_y=0.d0 ; R0_z=0.d0 ;
	   do L=1,nodes(M)/numblades
!		R0_z(L)= ABS(R0(M,L)*cos(alpha0(M,L)))-Rhub	!Always>0 
		R0_z(L)= R0(M,L)-Rhub	!Pablo 07_2017
		R0_y(L)= R0(M,L)*sin(alpha0(M,L))
		R0_x(L)=nodexlocal(M,L)-Rhub-0.035*0.25-0.0048525

	 if(R0_z(L).le.0.d0) write(6,*)'FEM Ro_z',L,'Very small',R0_z(L)
	   enddo
	   do L=1,nodes(M)/numblades
		R0_x(L+nodes(M)/numblades)=R0_x(L) 
		R0_x(L+2*nodes(M)/numblades)=R0_x(L)
		R0_y(L+nodes(M)/numblades)=R0_y(L) 
		R0_y(L+2*nodes(M)/numblades)=R0_y(L)
		R0_z(L+nodes(M)/numblades)=R0_z(L) 
		R0_z(L+2*nodes(M)/numblades)=R0_z(L)	
	   enddo

	 allocate(Mx(nodes(M)),Tx(nodes(M)),Tq(nodes(M)))
	 allocate(Mq(nodes(M)))

	 Mx=0.d0 ; Mq=0.d0 ; Tx=0.d0 ; Tq=0.d0 
	 Mxtot=0.d0 ; Mqtot=0.d0 ; Mzytot=0.d0 ; Mzxtot=0.d0
	 x1=0.d0 ; x2=0.d0 ; x3=0.d0 
!Thrust produced at each blade:
	  do L=1,nodes(M)/numblades
	   x1=x1+FX1(M,L)*dxm*dym*dzm/dt*1000.d0
	   x2=x2+FX1(M,L+1*nodes(M)/numblades)*dxm*dym*dzm/dt*1000.d0
	   x3=x3+FX1(M,L+2*nodes(M)/numblades)*dxm*dym*dzm/dt*1000.d0
	  enddo

!Bending moments:
!Flapwise bending moment:
	  do L=1,nodes(M)
	   Mx(L)=FX1(M,L)*R0_z(L)*dxm*dym*dzm*reddelta(M)/dt*1000.d0
	  enddo
	  do k=1,numblades
	    do L=1,nodes(M)/numblades
	 	Mxtot(k)=Mxtot(k)+Mx(L+nodes(M)/numblades*(k-1))
	    enddo
	  enddo

!Edgewise or radial bending moment:
	  do L=1,nodes(M)
	   Mq(L)=(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &   	FX3(M,L)*dsin(rads(M)+alpha0(M,L)))*R0_z(L)
     &      *dxm*dym*dzm*reddelta(M)/dt*1000.d0
	  enddo
	  do k=1,numblades
	    do L=1,nodes(M)/numblades
		Mqtot(k)=Mqtot(k)+Mq(L+nodes(M)/numblades*(k-1))
	    enddo
	  enddo

!Torsional moments:
	  do L=1,nodes(M)
	   Tx(L)=(FX1(M,L)*dxm*dym*dzm*reddelta(M)/dt)*R0_y(L)*1000.d0
	   Tq(L)=(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &   	    FX3(M,L)*dsin(rads(M)+alpha0(M,L)))
     &          *dxm*dym*dzm*reddelta(M)/dt*R0_x(L)*1000.d0
	  enddo
	 do k=1,numblades
	    do L=1,nodes(M)/numblades
	 	Mzxtot(k)=Mzxtot(k)+Tx(L+nodes(M)/numblades*(k-1))
		Mzytot(k)=Mzytot(k)+Tq(L+nodes(M)/numblades*(k-1))
	    enddo
	 enddo

	  alpharads=rads(M)*180.d0/PI

	  write (1414,89)alpharads,x1,x2,x3,
     &  Mxtot(1),Mxtot(2),Mxtot(3),Mqtot(1),Mqtot(2),Mqtot(3),
     &  Mzxtot(1),Mzxtot(2),Mzxtot(3),Mzytot(1),Mzytot(2),Mzytot(3)
	
	 deallocate(Mx,Mq,Tx,Tq,R0_x,R0_y,R0_z)
	  
	Enddo !M
	ENDIF

   89 FORMAT (16e15.5)
        RETURN
        END SUBROUTINE	
!#############################################################
      SUBROUTINE imb_FEM_oneblade
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
	INTEGER,parameter	:: numsections=5,numblades=3
      INTEGER          :: M,L,K 
      DOUBLE PRECISION :: alpharads,Rhub,PI
      DOUBLE PRECISION :: fx,fx_tot,ft,ft_tot,Mx,Mq,Mx_tot,Mq_tot
	DOUBLE PRECISION,dimension(numsections)::Mxtot,Mqtot
	DOUBLE PRECISION,dimension(numsections)::Xtot,Qtot

	IF (myrank.eq.master) then
      PI = 4.D0*DATAN(1.D0)

	 Do M=1,1!bodynum

	 if(itime.eq.itime_start+1) then
	  if (M.eq.1) then
         open (unit=1414, file='FEM_1.dat')
	   write(1414,*)'TITLE = "Forces at IB#1. Fx(kN), Mom (Nm)"'
	   write(1414,*)'VARIABLES=Deg,T1,T2,T3,T4,T5,Q1,Q2,Q3,Q4,Q5,',
     &  'MX1,MX2,MX3,MX4,MX5,MQ1,MQ2,MQ3,MQ4,MQ5'
	  else
         open (unit=1415, file='FEM_2.dat')
	   write(1415,*)'TITLE = "Forces at IB#2. Fx(kN), Mom (Nm)"'
	   write(1415,*)'VARIABLES=Deg,T1,T2,T3,T4,T5,Q1,Q2,Q3,Q4,Q5,',
     &  'MX1,MX2,MX3,MX4,MX5,MQ1,MQ2,MQ3,MQ4,MQ5'
	  endif
	 endif
		Rhub=0.0500d0 

	 Mx=0.d0 ; Mq=0.d0 ; Mx_tot=0.d0 ; Mq_tot=0.d0
       fx=0.d0 ; ft=0.d0 ; fx_tot=0.d0 ; ft_tot=0.d0
	 Mxtot=0.d0 ; Mqtot=0.d0 ; Xtot=0.d0 ; Qtot=0.d0

!Thrust produced at each blade:
	 do L=1,nodes(M)/numblades
         fx=FX1(M,L)*dxm*dym*dzm*reddelta(1)/dt*1000.d0
         fx_tot=fx_tot+fx
           if (L.ge.1 .and. L.lt.nodes(M)/numblades/numsections)
     &     Xtot(1)=Xtot(1)+fx

           if     (L.ge.nodes(M)/numblades*1/numsections 
     &       .and. L.lt.nodes(M)/numblades*2/numsections)
     &     Xtot(2)=Xtot(2)+fx

           if     (L.ge.nodes(M)/numblades*2/numsections 
     &       .and. L.lt.nodes(M)/numblades*3/numsections) 
     &     Xtot(3)=Xtot(3)+fx

           if     (L.ge.nodes(M)/numblades*3/numsections 
     &       .and. L.lt.nodes(M)/numblades*4/numsections) 
     &     Xtot(4)=Xtot(4)+fx

           if     (L.ge.nodes(M)/numblades*4/numsections 
     &       .and. L.le.nodes(M)/numblades*5/numsections) 
     &     Xtot(5)=Xtot(5)+fx

	 enddo

!Torque produced at each blade:
         do L=1,nodes(M)/numblades
          ft=(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &       FX3(M,L)*dsin(rads(M)+alpha0(M,L)))*R0(M,L)/dt
     &       *dxm*dym*dzm*reddelta(lag_bod_loc(L))*1000.d0   
          ft_tot=ft_tot+ft
           if (L.ge.1 .and. L.lt.nodes(M)/numblades/numsections)
     &     Qtot(1)=Qtot(1)+ft

           if  (L.ge.nodes(M)/numblades*1/numsections 
     &    .and. L.lt.nodes(M)/numblades*2/numsections)
     &    Qtot(2)=Qtot(2)+ft

           if  (L.ge.nodes(M)/numblades*2/numsections 
     &    .and. L.lt.nodes(M)/numblades*3/numsections)
     &    Qtot(3)=Qtot(3)+ft

           if  (L.ge.nodes(M)/numblades*3/numsections 
     &    .and. L.lt.nodes(M)/numblades*4/numsections)
     &    Qtot(4)=Qtot(4)+ft

           if  (L.ge.nodes(M)/numblades*4/numsections 
     &    .and. L.le.nodes(M)/numblades*5/numsections)
     &    Qtot(5)=Qtot(5)+ft
         enddo


!Flapwise bending moment:
         do L=1,nodes(M)/numblades
	    Mx=FX1(M,L)*(R0(M,L)-Rhub)*dxm*dym*dzm*reddelta(M)/dt*1000.d0
          Mx_tot=Mx_tot+Mx

           if (L.ge.1 .and. L.lt.nodes(M)/numblades/numsections)
     &    Mxtot(1)=Mxtot(1)+Mx

           if  (L.ge.nodes(M)/numblades*1/numsections 
     &    .and. L.lt.nodes(M)/numblades*2/numsections)
     &    Mxtot(2)=Mxtot(2)+Mx

           if  (L.ge.nodes(M)/numblades*2/numsections 
     &    .and. L.lt.nodes(M)/numblades*3/numsections)
     &    Mxtot(3)=Mxtot(3)+Mx

           if  (L.ge.nodes(M)/numblades*3/numsections 
     &    .and. L.lt.nodes(M)/numblades*4/numsections)
     &    Mxtot(4)=Mxtot(4)+Mx

           if  (L.ge.nodes(M)/numblades*4/numsections 
     &    .and. L.le.nodes(M)/numblades*5/numsections)
     &    Mxtot(5)=Mxtot(5)+Mx
         enddo

!Edgewise or radial bending moment:
         do L=1,nodes(M)/numblades
	    Mq=(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &   	  FX3(M,L)*dsin(rads(M)+alpha0(M,L)))*(R0(M,L)-Rhub)
     &        *dxm*dym*dzm*reddelta(M)/dt*1000.d0
          Mq_tot=Mq_tot+Mq

           if (L.ge.1 .and. L.lt.nodes(M)/numblades/numsections)
     &    Mqtot(1)=Mqtot(1)+Mq

           if  (L.ge.nodes(M)/numblades*1/numsections 
     &    .and. L.lt.nodes(M)/numblades*2/numsections)
     &    Mqtot(2)=Mqtot(2)+Mq

           if  (L.ge.nodes(M)/numblades*2/numsections 
     &    .and. L.lt.nodes(M)/numblades*3/numsections)
     &    Mqtot(3)=Mqtot(3)+Mq

           if  (L.ge.nodes(M)/numblades*3/numsections 
     &    .and. L.lt.nodes(M)/numblades*4/numsections)
     &    Mqtot(4)=Mqtot(4)+Mq

           if  (L.ge.nodes(M)/numblades*4/numsections 
     &    .and. L.le.nodes(M)/numblades*5/numsections)
     &    Mqtot(5)=Mqtot(5)+Mq
         enddo


	  alpharads=DABS(rads(M))*180.d0/PI

	 if (M.eq.1) then
	  write (1414,89)alpharads,Xtot(:),Qtot(:),Mxtot(:),Mqtot(:)
	 else
	  write (1415,89)alpharads,Xtot(:),Qtot(:),Mxtot(:),Mqtot(:)
	 endif

	Enddo !M
	ENDIF

   89 FORMAT (1f15.5,25e15.6)
        RETURN
        END SUBROUTINE	
!######################################################################
      SUBROUTINE imb_vel_to_zero
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      DOUBLE PRECISION :: dh,umin,xmax,xmin,ymax,ymin,zmax,zmin
      INTEGER :: I,J,K,L,ib

	xmax=0.d0;  xmin=10000.d0  ;ymax=0.d0;  ymin=10000.d0   
	zmax=0.d0;  zmin=10000.d0   

	umin=1.d-0
	
	Do ib=1,nbp  !Loop through all the blocks of one processor

       if (imbinblock_loc(dom_id(ib)+1).eq.0) GOTO 600 !IF THERE ARE NO POINTS IN THE BLOCK

      Do L = 1,maxnodeIBS !investigate all the IB points
	IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 700 !If the IB point is not in the present block
	xmax=max(xmax,nodex_loc(L)) ;	xmin=min(xmin,nodex_loc(L))
	ymax=max(ymax,nodey_loc(L)) ;	ymin=min(ymin,nodey_loc(L))
	zmax=max(zmax,nodez_loc(L)) ;	zmin=min(zmin,nodez_loc(L))
700 	CONTINUE
       Enddo !L

      Do L = 1,maxnodeIBS !investigate all the IB points
	IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 705 !If the IB point is not in the present block
!NEIGHBOURS FOR THE U-GRID
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.xmin .and. dom(ib)%xc(i) .le.xmax) THEN
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.ymin .and. dom(ib)%yc(j) .le.ymax) THEN
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.zmin .and. dom(ib)%zc(k) .le.zmax) THEN
!nl indicates the number of the neighbour and dh1 the delta functions value.
!The index of the neighbours number nl to the Lagrangian L are:    
	   dom(ib)%U(I,J,K)=umin ; dom(ib)%V(I,J,K)=umin
	   dom(ib)%W(I,J,K)=umin
	ENDIF
            END DO
	ENDIF
           END DO
	ENDIF
          END DO
705 	CONTINUE
       Enddo !L

!      Do L = 1,maxnodeIBS !investigate all the IB points
!	IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 700 !If the IB point is not in the present block
!NEIGHBOURS FOR THE U-GRID
!          DO I = 1, dom(ib)%ttc_i 
!       IF (dom(ib)%xc(i) .gt.(nodex_loc(L)+nxl*dom(ib)%dx) .or.
!     &     dom(ib)%xc(i) .lt.(nodex_loc(L)-nxl*dom(ib)%dx)) GOTO 210
!           DO J = 1, dom(ib)%ttc_j 
!       IF (dom(ib)%yc(j).gt.(nodey_loc(L)+nxl*dom(ib)%dy) .or.
!     &     dom(ib)%yc(j).lt.(nodey_loc(L)-nxl*dom(ib)%dy)) GOTO 211
!            DO K = 1, dom(ib)%ttc_k 
!       IF (dom(ib)%zc(k).gt.(nodez_loc(L)+nxl*dom(ib)%dz) .or.
!     &     dom(ib)%zc(k).lt.(nodez_loc(L)-nxl*dom(ib)%dz)) GOTO 212 
!nl indicates the number of the neighbour and dh1 the delta functions value.
!The index of the neighbours number nl to the Lagrangian L are:    
!	   dom(ib)%U(I,J,K)=umin
!	   dom(ib)%V(I,J,K)=umin
!	   dom(ib)%U(I,J,K)=umin
!212         CONTINUE
!            END DO
!211         CONTINUE
!           END DO
!210         CONTINUE
!          END DO
!700 	CONTINUE
!       Enddo !L
600	CONTINUE   
	Enddo !ib
      RETURN
      END
!#############################################################
      SUBROUTINE imb_averaging
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      double precision    :: facp1,facm1,facp2,facm2
      INTEGER      :: ib,M,L,I,J,K,strlen,strlen2,Geom_Time1    
      CHARACTER*8  :: char_block,ibnum
      CHARACTER*31 :: gridfile1

	IF (myrank.eq.master) then

	
!.....For first order moments
        if (ctime.ge.t_start_averaging1) then
           facp1 = 1./( ((ctime-t_start_averaging1)/dt) + 1)
        else
           facp1 = 1.
        endif
           facm1 = 1. - facp1
!.....For second order moments
        if (ctime.ge.t_start_averaging2) then
           facp2 = 1./( ((ctime-t_start_averaging2)/dt) + 1)
        else
           facp2 = 1.
        endif
           facm2 = 1. - facp2

	Do M=1,bodynum ; do L=1,nodes(M)
	   FX1M(M,L)=facm1*FX1M(M,L)+facp1*FX1(M,L)
	   FX2M(M,L)=facm1*FX2M(M,L)+facp1*FX2(M,L)
	   FX3M(M,L)=facm1*FX3M(M,L)+facp1*FX3(M,L)
	ENDDO; enddo

! Write out the mean values
      if (mod(itime,n_out).eq.0) then
	Do M=1,bodynum

         write(ibnum,'(I2)') M
           strlen2=LEN(TRIM(ADJUSTL(ibnum)))
           ibnum=REPEAT('0',(2-strlen2))//TRIM(ADJUSTL(ibnum))
           write(char_block,'(I6)') itime
           strlen=LEN(TRIM(ADJUSTL(char_block)))
           char_block=REPEAT('0',(6-strlen))//TRIM(ADJUSTL(char_block))
           gridfile1='PnFmean_'//TRIM(ADJUSTL(char_block))//
     &	   '_'//TRIM(ADJUSTL(ibnum))//'.plt'
         open (unit=Geom_Time1, file=gridfile1)
	   write(Geom_Time1,*)'TITLE = "Mean Forces at IBs"'
	   write(Geom_Time1,*)'VARIABLES=x,y,z,FxM,FyM,FzM'
	   write(Geom_Time1,*)'zone i= ',nodes(M),'DATAPACKING = POINT'
	  do L=1,nodes(M)
	   write (Geom_Time1,89) nodex(M,L),nodey(M,L),nodez(M,L),
     & 	FX1M(M,L)*dxm*dym*dzm*1000.D0/dt,
     &  	FX2M(M,L)*dxm*dym*dzm*1000.D0/dt,
     &  	FX3M(M,L)*dxm*dym*dzm*1000.D0/dt
	  enddo
	 close(Geom_Time1)
	Enddo !M

	endif

	ENDIF !master

   89 FORMAT (17e14.5)
        RETURN
        END SUBROUTINE	
!######################################################################
      SUBROUTINE move_ST
!######################################################################
      use vars
      use imb
      use mpi
      implicit none
      DOUBLE PRECISION    :: Tgen,Tfric,Initial_time,massI
	INTEGER :: STfilej,m

      IF (Myrank.ne.master) RETURN

	Initial_time=0.01d0  !Develop flow field
	massI=2.686d-3      !kg m^2

	Do M=1,bodynum
		Tgen  = 0.0018*radsin(M)+0.199  	!Parameters from Maitre et al 2013
		Tfric = 0.d0 

	acc_ST(M)=-(SUMtorque_ST(M) - (Tfric+Tgen))/ massI

      IF (CTIME .le. Initial_time) acc_ST(M)=0.d0

	radsin(M)= radsin(M) + acc_ST(M)*dt
	rads(M)  = rads(M)   + radsin(M)*dt

      write(6,*)'Ang,Vel,Q',rads(M),radsin(M),SUMtorque_ST(M)
	STfilej=5452+M
      write(STfilej,88) 
     &   ctime,acc_ST(M),radsin(M),rads(M),SUMtorque_ST(M)

	enddo !M
   88 FORMAT (1f12.6,5e15.7)
      RETURN
      END SUBROUTINE 
!######################################################################
	subroutine MLS_interpolation(UorV,L,mrx,mry,mrz,ib)
!######################################################################
         use vars
	 use multidata
         use mpi
	 use imb
         implicit none
         INTEGER :: order_mls,nbase,MAXCELL,MAXNEIG
	 LOGICAL :: vanella_mls
         INTEGER, intent(in) :: UorV,L,ib
         Double precision, intent(in) :: mrx,mry,mrz
         INTEGER :: I,J,K,ipface,inodehalo,nn,neignum
         INTEGER:: MVefx(126),MVefy(126),MVefz(126)
         Double precision :: vmaxdist,xN,yN,zN,h0,xv2,yv2,zv2
    	 Double precision::  Xf(126),Yf(126),Zf(126),hx,hy,hz
         Double precision :: offsety,offsetx,offsetz,ratioHKx1,ratioHKx2
         Double precision :: ratioHKy1,ratioHKy2,ratioHKz1,ratioHKz2
         Double precision :: kwx1,kwx2,kwy1,kwy2,kwz1,kwz2,dist_ff
	 Double precision :: parametros(9),W(126),difx(126)
	 Double precision :: dify(126),difz(126)
         Double precision :: dX2(126),dY2(126),dZ2(126)
         Double precision :: FF(126),dFFX(126),dFFY(126),dFFZ(126)
         Double precision :: ddFFXX(126),ddFFXY(126),ddFFYY(126)
         Double precision :: ddFFXZ(126),ddFFZZ(126),ddFFYZ(126)
	 Double precision :: nmls,k_mls
         INTEGER :: MLS_neignum(maxnodeIBS)

!"""  Data for MLS

	MAXCELL=27!1000  
	MAXNEIG=27!65 
	MLS_neignum=MAXNEIG
	order_mls=2
	k_mls=5.0d+00

        if (order_mls .eq. 1) nbase=4
        if (order_mls .eq. 2) nbase=10
        if (order_mls .eq. 3) nbase=20
!""""

	Do i=1,MAXNEIG
 	  MVefx(i)=0 ; MVefy(i)=0 ; MVefz(i)=0 
	Enddo
	nn=0  ; nxl=1.00001d00!1.9999999

	IF (UorV.eq.1) then
       DO I = 1, dom(ib)%ttc_i 
       IF ( dom(ib)%x(i).gt.(mrx+nxl*dom(ib)%dx) .or.
     &      dom(ib)%x(i).lt.(mrx-nxl*dom(ib)%dx))  GOTO 100
        DO J = 1, dom(ib)%ttc_j
       IF (dom(ib)%yc(j).gt.(mry+nxl*dom(ib)%dy) .or.
     &     dom(ib)%yc(j).lt.(mry-nxl*dom(ib)%dy))  GOTO 101
          DO K = 1, dom(ib)%ttc_k
       IF (dom(ib)%zc(k).gt.(mrz+nxl*dom(ib)%dz) .or.
     &     dom(ib)%zc(k).lt.(mrz-nxl*dom(ib)%dz) )  GOTO 102
		nn=nn+1
	IF (nn.gt.MAXNEIG) write(6,*)'More Neighbours than MAXNEIG!',nn
	    MVefx(nn)=I   ;  MVefy(nn)=J	;  MVefz(nn)=K
           Xf(nn)=dom(ib)%x(i)  ; Yf(nn)=dom(ib)%yc(j)
	    Zf(nn)=dom(ib)%zc(k)
102 	CONTINUE
         END DO
101 	CONTINUE
        END DO
100 	CONTINUE
       END DO
	ENDIF
	IF (UorV.eq.2) then
       DO I = 1, dom(ib)%ttc_i
       IF ( dom(ib)%xc(i).gt.(mrx+nxl*dom(ib)%dx) .or.
     &      dom(ib)%xc(i).lt.(mrx-nxl*dom(ib)%dx) )  GOTO 200 
        DO J = 1, dom(ib)%ttc_j
       IF (dom(ib)%y(j) .gt.(mry+nxl*dom(ib)%dy) .or.
     &     dom(ib)%y(j) .lt.(mry-nxl*dom(ib)%dy) )  GOTO 201
          DO K = 1, dom(ib)%ttc_k
	IF( dom(ib)%zc(k).gt.(mrz+nxl*dom(ib)%dz) .or.
     &     dom(ib)%zc(k).lt.(mrz-nxl*dom(ib)%dz) )  GOTO 202
		nn=nn+1
	IF (nn.gt.MAXNEIG)
     &       write(6,*)'More Neighbours than MAXNEIG!',nn,nxl
		MVefx(nn)=I   ;  MVefy(nn)=J	;  MVefz(nn)=K
              Xf(nn)=dom(ib)%xc(i)  
	       Yf(nn)=dom(ib)%y(j)
	       Zf(nn)=dom(ib)%zc(k)
202 	CONTINUE
         END DO
201 	CONTINUE
        END DO
200 	CONTINUE
       END DO
	ENDIF
	IF (UorV.eq.3) then
       DO I = 1, dom(ib)%ttc_i 
       IF ( dom(ib)%xc(i).gt.(mrx+nxl*dom(ib)%dx) .or.
     &      dom(ib)%xc(i).lt.(mrx-nxl*dom(ib)%dx)) GOTO 300
        DO J = 1, dom(ib)%ttc_j
       IF ( dom(ib)%yc(j).gt.(mry+nxl*dom(ib)%dy) .or.
     &      dom(ib)%yc(j).lt.(mry-nxl*dom(ib)%dy)) GOTO 301
          DO K = 1, dom(ib)%ttc_k
       IF ( dom(ib)%z(k) .gt.(mrz+nxl*dom(ib)%dz) .or.
     &      dom(ib)%z(k) .lt.(mrz-nxl*dom(ib)%dz) ) GOTO 302
		nn=nn+1
	IF (nn.gt.MAXNEIG)
     &       write(6,*)'More Neighbours than MAXNEIG!',nn,nxl
		MVefx(nn)=I   ;  MVefy(nn)=J	;  MVefz(nn)=K
              Xf(nn)=dom(ib)%xc(i)  
	       Yf(nn)=dom(ib)%yc(j)
	       Zf(nn)=dom(ib)%z(k)
302 	CONTINUE
         END DO
301 	CONTINUE
        END DO
300 	CONTINUE
       END DO
	ENDIF

	neignum=nn
	MLS_neignum(L)=neignum	
!--------------------------------------------------------
        vmaxdist= 0.d+00   
    	 do j=1, neignum
	  difx(j)= 0.d+0 ;    dify(j)= 0.d+0;    difz(j)= 0.d+00
	 enddo

    	  do j=1, neignum   ! initializing weights???
	 dist_ff=DSQRT((mrx-Xf(j))**2+(mry-Yf(j))**2
     &		+(mrz-Zf(j))**2)
	    if(dist_ff.gt.vmaxdist) vmaxdist= dist_ff
	     	difx(j)=Xf(j)-mrx
		dify(j)=Yf(j)-mry
		difz(j)=Zf(j)-mrz
	  enddo

	h0=1.0d+00
	hx= h0*maxval(DABS(difx(1:neignum)))
	hy= h0*maxval(DABS(dify(1:neignum)))
	hz= h0*maxval(DABS(difz(1:neignum)))

	parametros(1)= k_mls
	parametros(2)= k_mls
	parametros(3)= k_mls
	parametros(4)= k_mls
	parametros(5)= k_mls
	parametros(6)= k_mls
	parametros(7)= 0.0d+00
	parametros(8)= 0.0d+00
	parametros(9)= 0.0d+00

	ratioHKx1= parametros(1)
	ratioHKx2= parametros(2)
	ratioHKy1= parametros(3)
	ratioHKy2= parametros(4)
	ratioHKz1= parametros(5)
	ratioHKz2= parametros(6)
	offsetx  = parametros(7)
	offsety  = parametros(8)
	offsetz  = parametros(9)

	h0= 1.0d+00
	kwx1= h0*ratioHKx1
	kwx2= h0*ratioHKx2
	kwy1= h0*ratioHKy1
	kwy2= h0*ratioHKy2
	kwz1= h0*ratioHKz1
	kwz2= h0*ratioHKz2

	call  kerneltododer(W,dX2,dY2,dZ2,difx,dify,difz,hx,hy,hz,
     &  neignum,kwx1,kwx2,kwy1,kwy2,kwz1,kwz2,MAXNEIG)

        call forma3Dder(FF,W,dX2,dY2,dZ2,neignum,Xf,Yf,Zf
     & ,mrx,mry,mrz,hx,hy,hz,
     & dFFX,dFFY,dFFZ,ddFFXX,ddFFXY,ddFFXZ,ddFFYY,ddFFYZ,ddFFZZ,
     &  MAXNEIG,nbase)

	  do j=1, MLS_neignum(L)
	   IF (UorV.eq.1) then
	   	dh1_loc(L,j)=FF(j)  	;I_nr_U(L,j)=MVefx(j)
	    	J_nr_U(L,j)=MVefy(j)	;K_nr_U(L,j)=MVefz(j)
	   ELSEIF(UorV.eq.2) then
	    	dh2_loc(L,j)=FF(j)	;I_nr_V(L,j)=MVefx(j)
		J_nr_V(L,j)=MVefy(j)	;K_nr_V(L,j)=MVefz(j)
	   ELSEIF(UorV.eq.3) then
	   	dh3_loc(L,j)=FF(j)	;I_nr_W(L,j)=MVefx(j)
		J_nr_W(L,j)=MVefy(j)	;K_nr_W(L,j)=MVefz(j)
	   ENDIF
          enddo

		  write(6,*) FF
	  IF(UorV.eq.1) KmaxU(L)=MLS_neignum(L)
	  IF(UorV.eq.2) KmaxV(L)=MLS_neignum(L)
	  IF(UorV.eq.3) KmaxW(L)=MLS_neignum(L)

	return
	end
